ca65 V2.19 - Git de30a57
Main file   : pacman.asm
Current file: pacman.asm

000000r 1               .setcpu "6502"
000000r 1               .feature c_comments						; Allow C language type comments (/* comments */)
000000r 1               .feature underline_in_numbers			; Allow notation %1010_0010
000000r 1               .feature string_escapes					; Allow \t, \n, \" and so on
000000r 1               .linecont +								; Allow line breaks in the middle of lines if you put a backslash at the end of the line
000000r 1               
000000r 1               
000000r 1               .segment "HEADER"
000000r 1  4E 45 53 1A  		.byte $4e, $45, $53, $1a
000004r 1  02           		.byte $02						; program bank
000005r 1  01           		.byte $01						; charactor bank
000006r 1  01           		.byte $01						; vartical mirror
000007r 1  00           		.byte $00
000008r 1  00 00 00 00  		.byte $00, $00, $00, $00
00000Cr 1  00 00 00 00  		.byte $00, $00, $00, $00
000010r 1               
000010r 1               
000010r 1               .rodata									; ----- data -----
000000r 1               .include "./inc/defmacro.inc"
000000r 2               ;*------------------------------------------------------------------------------
000000r 2               ; Calcurate BG address
000000r 2               ; @PARAM ptx: X coordinate
000000r 2               ; @PARAM pty: Y coordinate
000000r 2               ; @PARAM scn: Screen number
000000r 2               ;*------------------------------------------------------------------------------
000000r 2               
000000r 2               .define ADDR_BG (ptx, pty, scn)			$2000 + (ptx) + ((pty) * $20) + ((scn) * $400)
000000r 2               .define ADDR_BG_BE (ptx, pty, scn)		GET_BE ADDR_BG (ptx), (pty), (scn)
000000r 2               
000000r 2               ;*------------------------------------------------------------------------------
000000r 2               ; Calcurate SPR address
000000r 2               ; @PARAM spr_num: Sprite number (0~63)
000000r 2               ; @PARAM member:
000000r 2               ; 	pty: PosiTion Y
000000r 2               ; 	num: Tile(8*8) number
000000r 2               ; 	att: Attribute (VertFlip|HorizonFlip|Prio|Unused(3)|PltNum(2))
000000r 2               ; 	ptx: PosiTion X
000000r 2               ;*------------------------------------------------------------------------------
000000r 2               
000000r 2               .define ADDR_SPR(spr_num, member)		SPR_BUFF + ((spr_num)*4) + SPR_STRUCT::member
000000r 2               
000000r 2               
000000r 2               ;*------------------------------------------------------------------------------
000000r 2               ; Get data in big endian
000000r 2               ; dbyt = Define BYTe?
000000r 2               ; Define word data with the hi & lo bytes swapped
000000r 2               ; ($1234=$12,$34)
000000r 2               ;*------------------------------------------------------------------------------
000000r 2               
000000r 2               .define GET_BE(data)					.dbyt data
000000r 2               
000000r 2               
000000r 2               ;*------------------------------------------------------------------------------
000000r 2               ; Get obj position
000000r 2               ; @PARAM	posX, posY
000000r 2               ; @RETURN	$YX
000000r 2               ;*------------------------------------------------------------------------------
000000r 2               .define GET_OBJ_POS (posX, posY)		(posY) * $10 + (posX)
000000r 2               
000000r 1               .include "./inc/const.inc"
000000r 2               BTN_A									= %10000000
000000r 2               BTN_B									= %01000000
000000r 2               BTN_S									= %00100000
000000r 2               BTN_T									= %00010000
000000r 2               BTN_U									= %00001000
000000r 2               BTN_D									= %00000100
000000r 2               BTN_L									= %00000010
000000r 2               BTN_R									= %00000001
000000r 2               
000000r 2               PPU_VERTICAL_MODE						= %11111110
000000r 2               PPU_HORIZONTAL_MODE						= %11111111
000000r 2               
000000r 2               OBJMAP_NEXT								= $fe
000000r 2               OBJMAP_END								= $ff
000000r 2               
000000r 2               PPU_CTRL1_STD							= %10010000			; |NMION|PPU=MASTER|SPR8*8|BG$1000|SPR$0000|VRAM+1|SCRN$2000(2)|
000000r 2               PPU_CTRL2_STD							= %00011110			; |R|G|B|DISP-SPR|DISP-BG|SHOW-L8SPR|SHOW-L8BG|MODE=COLOR|
000000r 2               
000000r 1               .include "./inc/const_addr.inc"
000000r 2               ZP					= $00
000000r 2               ; Unused $0200
000000r 2               BG_BUFF				= $0100
000000r 2               SPR_BUFF			= $0300
000000r 2               MAP1				= $0400
000000r 2               MAP2				= $0500
000000r 2               USER_MEM			= $0700
000000r 2               
000000r 2               PLT_TABLE_ADDR		= $3f00
000000r 2               
000000r 2               PPU_CTRL1			= $2000
000000r 2               PPU_CTRL2			= $2001
000000r 2               PPU_STATUS			= $2002
000000r 2               OAM_ADDR			= $2003
000000r 2               OAM_DATA			= $2004
000000r 2               PPU_SCROLL			= $2005
000000r 2               PPU_ADDR			= $2006
000000r 2               PPU_DATA			= $2007
000000r 2               OAM_DMA				= $4014
000000r 2               
000000r 2               
000000r 2               SOUND_SQ1_1			= $4000				; Duty(2)|time counter|音響変化|ボリューム(4)
000000r 2               SOUND_SQ1_2			= $4001				; 周波数変化|変化速度(3)|変化方向|変化範囲(3)
000000r 2               SOUND_SQ1_3			= $4002				; 周波数下位
000000r 2               SOUND_SQ1_4			= $4003				; 再生時間(5)|周波数上位(3)
000000r 2               SOUND_SQ2_1			= $4004
000000r 2               SOUND_SQ2_2			= $4005
000000r 2               SOUND_SQ2_3			= $4006
000000r 2               SOUND_SQ2_4			= $4007
000000r 2               SOUND_TR_1			= $4008				; 再生時間カウンタ|カウンタを使用した長さ(7)
000000r 2               SOUND_TR_2			= $400A				; 周波数下位
000000r 2               SOUND_TR_3			= $400B				; 再生時間(5)|周波数上位(3)
000000r 2               SOUND_NS_1			= $400C				; 未使用(2)|再生時間カウンタ|音響固定|ボリューム(3)
000000r 2               SOUND_NS_2			= $400E				; 乱数タイプ(高周波)|未使用(3)|サンプルレート(4)
000000r 2               SOUND_NS_3			= $400F				; 再生時間(5)|未使用(3)
000000r 2               SOUND_DP_1			= $4010
000000r 2               SOUND_DP_2			= $4011
000000r 2               SOUND_DP_3			= $4012
000000r 2               SOUND_DP_4			= $4013
000000r 2               SOUND_CHANNEL		= $4015				; 未使用(3)|DPCM|ノイズ|三角波|CH2|CH1
000000r 2               
000000r 2               
000000r 2               JOYPAD1				= $4016
000000r 2               JOYPAD2				= $4017
000000r 2               
000000r 1               .include "./inc/var_addr.inc"
000000r 2               ; ZeroPage
000000r 2               .segment "ZEROPAGE"
000000r 2  00           tmp1					: .byte 0		; 00
000001r 2  00           tmp2					: .byte 0		; 01
000002r 2  00           tmp3					: .byte 0		; 02
000003r 2               
000003r 2  00           joy1					: .byte 0		; 03
000004r 2  00           joy2					: .byte 0		; 04
000005r 2  00           joy1_prev				: .byte 0		; 05
000006r 2  00           joy2_prev				: .byte 0		; 06
000007r 2  00           joy1_pushstart			: .byte 0		; 07
000008r 2  00           joy2_pushstart			: .byte 0		; 08
000009r 2               
000009r 2  00           bg_buff_pointer			: .byte 0		; 09
00000Ar 2  00 00        addr_tmp1				: .addr 0		; 0A, 0B
00000Cr 2               
00000Cr 2  00           tmp_rgstA				: .byte 0		; 0C
00000Dr 2  00           tmp_rgstX				: .byte 0		; 0D
00000Er 2  00           tmp_rgstY				: .byte 0		; 0E
00000Fr 2               
00000Fr 2               ; These are not used often, but are used in NMI
00000Fr 2  00           ppu_ctrl1_cpy			: .byte 0		; 0F |NMI-ON|PPU=MASTER|SPR8*8|BG$1000|SPR$0000|VRAM+1|SCREEN$2000(2)|
000010r 2  00           ppu_ctrl2_cpy			: .byte 0		; 10 |R|G|B|DISP-SPR|DISP-BG|SHOW-L8-SPR|SHOW-L8-BG|MODE=COLOR|
000011r 2               
000011r 2  00           scroll_x				: .byte 0		; 11
000012r 2  00           scroll_y				: .byte 0		; 12
000013r 2               
000013r 2  00           nmi_cnt					: .byte 0		; 13
000014r 2  00           frm_cnt					: .byte 0		; 14
000015r 2  00           is_processing_main		: .byte 0		; 15
000016r 2               
000016r 2  00 00        addr1					: .addr 0		; 16, 17
000018r 2  00 00        addr2					: .addr 0		; 18, 19
00001Ar 2  00 00        addr3					: .addr 0		; 1a, 1b
00001Cr 2  00           stage					: .byte 0		; 1c
00001Dr 2  00           map_buff_num			: .byte 0		; 1d
00001Er 2  00           index_tmp				: .byte 0		; 1e
00001Fr 2  00 00        map_arr_addr			: .addr 0		; 1f, 20
000021r 2  00 00        map_addr				: .addr 0		; 21, 22
000023r 2  00           isend_draw_stage		: .byte 0		; 23
000024r 2  00           row_counter				: .byte 0		; 24
000025r 2  00           index					: .byte 0		; 25
000026r 2  00 00        ppu_addr				: .addr 0		; 26, 27
000028r 2  00           cnt_map_next			: .byte 0		; 28
000029r 2  00           map_arr_num				: .byte 0
00002Ar 2               
00002Ar 2               
00002Ar 2               
00002Ar 2               
00002Ar 2               .segment "USER_MEM"
000000r 2               
000000r 2               
000000r 2               .code
000000r 2               
000000r 1               .include "./inc/palette.inc"
000000r 2               DEFAULT_PLT:
000000r 2               		; BG
000000r 2  22 17 36 0F  		.byte $22,$17,$36,$0f
000004r 2  00 28 17 07  		.byte $00,$28,$17,$07
000008r 2  00 22 00 00  		.byte $00,$22,$00,$00
00000Cr 2  00 00 00 00  		.byte $00,$00,$00,$00
000010r 2               		; SPR
000010r 2  22 16 27 18  		.byte $22,$16,$27,$18
000014r 2  00 00 00 00  		.byte $00,$00,$00,$00
000018r 2  00 00 00 00  		.byte $00,$00,$00,$00
00001Cr 2  00 00 00 00  		.byte $00,$00,$00,$00
000020r 2               
000020r 1               .include "./inc/struct.inc"
000020r 2               .struct	SPR_STRUCT
000020r 2               		pty		.byte					; PosiTion Y
000020r 2               		num		.byte					; Tile(8*8) number
000020r 2               		att		.byte					; Attribute (VertFlip|HorizonFlip|Prio|Unused(3)|PltNum(2))
000020r 2               		ptx		.byte					; PosiTion X
000020r 2               .endstruct
000020r 2               
000020r 2               
000020r 2               .struct	SPR_TBL
000020r 2               		spr		.tag SPR_STRUCT 64
000020r 2               .endstruct
000020r 2               
000020r 1               .include "./inc/map_data.inc"
000020r 2               
000020r 2               
000020r 2               STAGE_ARR:
000020r 2  rr rr        	.addr MAP_ARR_11
000022r 2               
000022r 2               MAP_ARR_11:
000022r 2  rr rr        	.addr MAP_11_1
000024r 2  rr rr        	.addr MAP_11_2
000026r 2  FF FF        	.addr $ffff
000028r 2               
000028r 2               MAP_11_1:
000028r 2  00 47        	.byte (GET_OBJ_POS $0, $0), 'G'
00002Ar 2  11 47        	.byte (GET_OBJ_POS $1, $1), 'G'
00002Cr 2  22 47        	.byte (GET_OBJ_POS $2, $2), 'G'
00002Er 2  33 47        	.byte (GET_OBJ_POS $3, $3), 'G'
000030r 2  44 47        	.byte (GET_OBJ_POS $4, $4), 'G'
000032r 2  55 47        	.byte (GET_OBJ_POS $5, $5), 'G'
000034r 2  66 47        	.byte (GET_OBJ_POS $6, $6), 'G'
000036r 2  77 47        	.byte (GET_OBJ_POS $7, $7), 'G'
000038r 2  88 47        	.byte (GET_OBJ_POS $8, $8), 'G'
00003Ar 2  99 47        	.byte (GET_OBJ_POS $9, $9), 'G'
00003Cr 2  AA 47        	.byte (GET_OBJ_POS $a, $a), 'G'
00003Er 2  BB 47        	.byte (GET_OBJ_POS $b, $b), 'G'
000040r 2  CC 47        	.byte (GET_OBJ_POS $c, $c), 'G'
000042r 2  DD 47        	.byte (GET_OBJ_POS $d, $d), 'G'
000044r 2  CE 47        	.byte (GET_OBJ_POS $e, $c), 'G'
000046r 2  BF 47        	.byte (GET_OBJ_POS $f, $b), 'G'
000048r 2  FE           	.byte OBJMAP_NEXT
000049r 2  00 42        	.byte (GET_OBJ_POS $0, $0), 'B'
00004Br 2  11 42        	.byte (GET_OBJ_POS $1, $1), 'B'
00004Dr 2  22 42        	.byte (GET_OBJ_POS $2, $2), 'B'
00004Fr 2  33 42        	.byte (GET_OBJ_POS $3, $3), 'B'
000051r 2  44 42        	.byte (GET_OBJ_POS $4, $4), 'B'
000053r 2  55 42        	.byte (GET_OBJ_POS $5, $5), 'B'
000055r 2  66 42        	.byte (GET_OBJ_POS $6, $6), 'B'
000057r 2  77 42        	.byte (GET_OBJ_POS $7, $7), 'B'
000059r 2  88 42        	.byte (GET_OBJ_POS $8, $8), 'B'
00005Br 2  99 42        	.byte (GET_OBJ_POS $9, $9), 'B'
00005Dr 2  AA 42        	.byte (GET_OBJ_POS $a, $a), 'B'
00005Fr 2  BB 42        	.byte (GET_OBJ_POS $b, $b), 'B'
000061r 2  CC 42        	.byte (GET_OBJ_POS $c, $c), 'B'
000063r 2  DD 42        	.byte (GET_OBJ_POS $d, $d), 'B'
000065r 2  CE 42        	.byte (GET_OBJ_POS $e, $c), 'B'
000067r 2  BF 42        	.byte (GET_OBJ_POS $f, $b), 'B'
000069r 2  FE           	.byte OBJMAP_NEXT
00006Ar 2  FF           	.byte OBJMAP_END
00006Br 2               
00006Br 2               MAP_11_2:
00006Br 2  00 3F        	.byte (GET_OBJ_POS $0, $0), '?'
00006Dr 2  11 3F        	.byte (GET_OBJ_POS $1, $1), '?'
00006Fr 2  22 3F        	.byte (GET_OBJ_POS $2, $2), '?'
000071r 2  33 3F        	.byte (GET_OBJ_POS $3, $3), '?'
000073r 2  44 3F        	.byte (GET_OBJ_POS $4, $4), '?'
000075r 2  55 3F        	.byte (GET_OBJ_POS $5, $5), '?'
000077r 2  66 3F        	.byte (GET_OBJ_POS $6, $6), '?'
000079r 2  77 3F        	.byte (GET_OBJ_POS $7, $7), '?'
00007Br 2  88 3F        	.byte (GET_OBJ_POS $8, $8), '?'
00007Dr 2  99 3F        	.byte (GET_OBJ_POS $9, $9), '?'
00007Fr 2  AA 3F        	.byte (GET_OBJ_POS $a, $a), '?'
000081r 2  BB 3F        	.byte (GET_OBJ_POS $b, $b), '?'
000083r 2  CC 3F        	.byte (GET_OBJ_POS $c, $c), '?'
000085r 2  DD 3F        	.byte (GET_OBJ_POS $d, $d), '?'
000087r 2  CE 3F        	.byte (GET_OBJ_POS $e, $c), '?'
000089r 2  BF 3F        	.byte (GET_OBJ_POS $f, $b), '?'
00008Br 2  FE           	.byte OBJMAP_NEXT
00008Cr 2  FF           	.byte OBJMAP_END
00008Dr 2               
00008Dr 2               
00008Dr 2               BROCK_ID:
00008Dr 2  rr rr        	.addr OBJ_SKY
00008Fr 2               	; 30
00008Fr 2  00 00        	.addr $0000							; 0
000091r 2  00 00        	.addr $0000							; 1
000093r 2  00 00        	.addr $0000							; 2
000095r 2  00 00        	.addr $0000							; 3
000097r 2  00 00        	.addr $0000							; 4
000099r 2  00 00        	.addr $0000							; 5
00009Br 2  00 00        	.addr $0000							; 6
00009Dr 2  00 00        	.addr $0000							; 7
00009Fr 2  00 00        	.addr $0000							; 8
0000A1r 2  00 00        	.addr $0000							; 9
0000A3r 2  00 00        	.addr $0000							; :
0000A5r 2  00 00        	.addr $0000							; ;
0000A7r 2  00 00        	.addr $0000							; <
0000A9r 2  00 00        	.addr $0000							; =
0000ABr 2  00 00        	.addr $0000							; >
0000ADr 2  rr rr        	.addr OBJ_QBLOCK					; ?
0000AFr 2               	; 40
0000AFr 2  00 00        	.addr $0000							; @
0000B1r 2  00 00        	.addr $0000							; A
0000B3r 2  rr rr        	.addr OBJ_BROCK						; B
0000B5r 2  rr rr        	.addr OBJ_COIN						; C
0000B7r 2  00 00        	.addr $0000							; D
0000B9r 2  00 00        	.addr $0000							; E
0000BBr 2  00 00        	.addr $0000							; F
0000BDr 2  rr rr        	.addr OBJ_GROUND					; G
0000BFr 2  00 00        	.addr $0000							; H
0000C1r 2  00 00        	.addr $0000							; I
0000C3r 2  00 00        	.addr $0000							; J
0000C5r 2  00 00        	.addr $0000							; K
0000C7r 2  00 00        	.addr $0000							; L
0000C9r 2  00 00        	.addr $0000							; M
0000CBr 2  00 00        	.addr $0000							; N
0000CDr 2  00 00        	.addr $0000							; O
0000CFr 2               	; 50
0000CFr 2  00 00        	.addr $0000							; P
0000D1r 2  00 00        	.addr $0000							; Q
0000D3r 2  00 00        	.addr $0000							; R
0000D5r 2  00 00        	.addr $0000							; S
0000D7r 2  00 00        	.addr $0000							; T
0000D9r 2  00 00        	.addr $0000							; U
0000DBr 2  00 00        	.addr $0000							; V
0000DDr 2  00 00        	.addr $0000							; W
0000DFr 2  00 00        	.addr $0000							; X
0000E1r 2  00 00        	.addr $0000							; Y
0000E3r 2  00 00        	.addr $0000							; Z
0000E5r 2  00 00        	.addr $0000							; [
0000E7r 2  00 00        	.addr $0000							; \
0000E9r 2  00 00        	.addr $0000							; ]
0000EBr 2  00 00        	.addr $0000							; ^
0000EDr 2  00 00        	.addr $0000							; _
0000EFr 2               	; 60
0000EFr 2  00 00        	.addr $0000							; `
0000F1r 2  00 00        	.addr $0000							; a
0000F3r 2  00 00        	.addr $0000							; b
0000F5r 2  00 00        	.addr $0000							; c
0000F7r 2  00 00        	.addr $0000							; d
0000F9r 2  00 00        	.addr $0000							; e
0000FBr 2  00 00        	.addr $0000							; f
0000FDr 2  00 00        	.addr $0000							; g
0000FFr 2  00 00        	.addr $0000							; h
000101r 2  00 00        	.addr $0000							; i
000103r 2  00 00        	.addr $0000							; j
000105r 2  00 00        	.addr $0000							; k
000107r 2  00 00        	.addr $0000							; l
000109r 2  00 00        	.addr $0000							; m
00010Br 2  00 00        	.addr $0000							; n
00010Dr 2  00 00        	.addr $0000							; o
00010Fr 2               
00010Fr 2               
00010Fr 2               OBJ_SKY:
00010Fr 2  00 00        	.byte $00, $00
000111r 2  00 00        	.byte $00, $00
000113r 2               
000113r 2               OBJ_QBLOCK:
000113r 2  90 91        	.byte $90, $91
000115r 2  92 93        	.byte $92, $93
000117r 2               
000117r 2               OBJ_BROCK:
000117r 2  94 94        	.byte $94, $94
000119r 2  95 95        	.byte $95, $95
00011Br 2               
00011Br 2               OBJ_COIN:
00011Br 2  84 85        	.byte $84, $85
00011Dr 2  86 87        	.byte $86, $87
00011Fr 2               
00011Fr 2               OBJ_GROUND:
00011Fr 2  80 81        	.byte $80, $81
000121r 2  82 83        	.byte $82, $83
000123r 2               
000123r 2               
000123r 2               /*
000123r 2               MAP_DATA[stage][map_num][index]
000123r 2               
000123r 2               setAddr ----
000123r 2               lda stage
000123r 2               shl
000123r 2               tax
000123r 2               
000123r 2               lda MAP_DATA, x
000123r 2               sta <addr1
000123r 2               inx
000123r 2               lda MAP_DATA, x
000123r 2               sta >addr1
000123r 2               inx
000123r 2               
000123r 2               ldy map_num
000123r 2               lda (addr1), y
000123r 2               sta <addr2
000123r 2               lda (addr1), y
000123r 2               sta >addr2
000123r 2               
000123r 2               ldy index
000123r 2               lda (addr2), y
000123r 2               sta <addr3
000123r 2               lda (addr2), y
000123r 2               sta >addr3
000123r 2               
000123r 2               */
000123r 2               
000123r 2               
000123r 1               
000123r 1               .code									; ----- code -----
000123r 1               .include "./asm/macro.asm"
000123r 2               ; ------------------------------------------------------------------------------
000123r 2               ; Load array
000123r 2               ; A = Arr[X][Y]
000123r 2               ; @PARAM	ADDR: Array Address
000123r 2               ; @PARAM	X Y: index (Access Arr[x][y])
000123r 2               ; @BREAK	tmp1
000123r 2               ; ------------------------------------------------------------------------------
000123r 2               
000123r 2               .macro ldarr addr
000123r 2               		.if !(.blank(addr))
000123r 2               			sty tmp1						; save Y
000123r 2               			txa
000123r 2               			asl								; ×2（アドレスが16bitなのでARR[x][y]のxが+1 => 読み込むアドレスは+2する必要がある
000123r 2               			tay								; アドレッシングに使うためYレジスタへ
000123r 2               			lda addr, y						; Low
000123r 2               			sta <addr_tmp1
000123r 2               			lda addr+1, y					; High
000123r 2               			sta >addr_tmp1
000123r 2               			ldy tmp1						; restore Y
000123r 2               			lda (addr_tmp1), y
000123r 2               		.else
000123r 2               			.error "Arg addr in macro ldarr is wrong."
000123r 2               		.endif
000123r 2               .endmacro
000123r 2               
000123r 2               
000123r 2               ; ------------------------------------------------------------------------------
000123r 2               ; Calculate Negative Numbers
000123r 2               ; ------------------------------------------------------------------------------
000123r 2               
000123r 2               .macro cnn
000123r 2               		eor #$ff
000123r 2               		add #$01
000123r 2               .endmacro
000123r 2               
000123r 2               
000123r 2               ; ------------------------------------------------------------------------------
000123r 2               ; Addition
000123r 2               ; This Macro only supports Immediate/Zeropage/Absolute addressing.
000123r 2               ; Other addressing modes are not optimized for speed.
000123r 2               ; Other addressing usage: add a, {$00, x} / add a, {($00), y}
000123r 2               ; @PARAM	arg1: register or Address
000123r 2               ; @PARAM	arg2
000123r 2               ; ------------------------------------------------------------------------------
000123r 2               
000123r 2               .macro add arg1, arg2
000123r 2               		.if (.paramcount = 1)
000123r 2               			; arg1: val
000123r 2               			; add #3 / add $80
000123r 2               			clc
000123r 2               			adc arg1
000123r 2               		.elseif (.paramcount = 2)
000123r 2               			; arg1: target
000123r 2               			; arg2: val
000123r 2               			.if (.match({arg1}, a))
000123r 2               				; add a, #3 / add a, $80
000123r 2               				clc
000123r 2               				adc arg2
000123r 2               			.elseif (.match({arg1}, x))
000123r 2               				; add x, ??
000123r 2               				.if (\
000123r 2               					.match(.left(1, {arg2}), #) &&\
000123r 2               					.right(.tcount({arg2})-1, {arg2}) <= 7\
000123r 2               				)
000123r 2               					; add x, #0~7
000123r 2               					.repeat (.right(.tcount({arg2})-1, {arg2}))
000123r 2               						inx
000123r 2               					.endrepeat
000123r 2               				.else
000123r 2               					pha
000123r 2               					txa
000123r 2               					clc
000123r 2               					adc arg2
000123r 2               					tax
000123r 2               					pla
000123r 2               				.endif
000123r 2               			.elseif (.match({arg1}, y))
000123r 2               				; add y, ??
000123r 2               				.if (\
000123r 2               					.match(.left(1, {arg2}), #) &&\
000123r 2               					.right(.tcount({arg2})-1, {arg2}) <= 7\
000123r 2               				)
000123r 2               					; add y, #0~7
000123r 2               					.repeat (.right(.tcount ({arg2})-1, {arg2}))
000123r 2               						iny
000123r 2               					.endrepeat
000123r 2               				.else
000123r 2               					pha
000123r 2               					tya
000123r 2               					clc
000123r 2               					adc arg2
000123r 2               					tay
000123r 2               					pla
000123r 2               				.endif
000123r 2               			.endif
000123r 2               		.else
000123r 2               			.error "Args in macro add are wrong."
000123r 2               		.endif
000123r 2               .endmacro
000123r 2               
000123r 2               
000123r 2               ; ------------------------------------------------------------------------------
000123r 2               ; Subtraction
000123r 2               ; See macro add for comments
000123r 2               ; @PARAM	arg1: register or Address
000123r 2               ; @PARAM	arg2
000123r 2               ; ------------------------------------------------------------------------------
000123r 2               
000123r 2               .macro sub arg1, arg2
000123r 2               		.if (.paramcount = 1)
000123r 2               			sec
000123r 2               			sbc arg1
000123r 2               		.elseif (.paramcount = 2 && .match({arg1}, a))
000123r 2               			sec
000123r 2               			sbc arg2
000123r 2               		.elseif (.paramcount = 2 && .match({arg1}, x))
000123r 2               			.if (\
000123r 2               				.match(.left(1, {arg2}), #) &&\
000123r 2               				.right(.tcount({arg2})-1, {arg2}) <= 7\
000123r 2               			)
000123r 2               				.repeat (.right(.tcount({arg2})-1, {arg2}))
000123r 2               					dex
000123r 2               				.endrepeat
000123r 2               			.else
000123r 2               				pha
000123r 2               				txa
000123r 2               				sec
000123r 2               				sbc arg2
000123r 2               				tax
000123r 2               				pla
000123r 2               			.endif
000123r 2               		.elseif (.paramcount = 2 && .match({arg1}, y))
000123r 2               			.if (\
000123r 2               				.match(.left(1, {arg2}), #) &&\
000123r 2               				.right(.tcount({arg2})-1, {arg2}) <= 7\
000123r 2               			)
000123r 2               				.repeat (.right(.tcount ({arg2})-1, {arg2}))
000123r 2               					dey
000123r 2               				.endrepeat
000123r 2               			.else
000123r 2               				pha
000123r 2               				tya
000123r 2               				sec
000123r 2               				sbc arg2
000123r 2               				tay
000123r 2               				pla
000123r 2               			.endif
000123r 2               		.else
000123r 2               			.error "Args in macro sub are wrong."
000123r 2               		.endif
000123r 2               .endmacro
000123r 2               
000123r 2               
000123r 2               ;*------------------------------------------------------------------------------
000123r 2               ; Light shift
000123r 2               ; arg1 <<= c
000123r 2               ; @PARAM	c: default=#1
000123r 2               ;*------------------------------------------------------------------------------
000123r 2               
000123r 2               .macro shl c
000123r 2               		.if (.blank(c))
000123r 2               			asl
000123r 2               		.elseif (.match(.left(1, {c}), #))
000123r 2               			.repeat	(.right(.tcount ({c})-1, {c}))
000123r 2               				asl
000123r 2               			.endrepeat
000123r 2               		.else
000123r 2               			.error "Arg \"c\" in macro shl is wrong."
000123r 2               		.endif
000123r 2               .endmacro
000123r 2               
000123r 2               
000123r 2               ;*------------------------------------------------------------------------------
000123r 2               ; Right shift
000123r 2               ; arg1 >>= c
000123r 2               ; @PARAM	c: default=#1
000123r 2               ;*------------------------------------------------------------------------------
000123r 2               
000123r 2               .macro shr c
000123r 2               		.if (.blank(c))
000123r 2               			lsr
000123r 2               		.elseif (.match(.left(1, {c}), #))
000123r 2               			.repeat	(.right(.tcount ({c})-1, {c}))
000123r 2               				lsr
000123r 2               			.endrepeat
000123r 2               		.else
000123r 2               			.error "Arg \"c\" in macro shr is wrong."
000123r 2               		.endif
000123r 2               .endmacro
000123r 2               
000123r 2               
000123r 2               ;*------------------------------------------------------------------------------
000123r 2               ; Arithmetic left shift
000123r 2               ;! Deprecated (Not shortened)
000123r 2               ; A >>= c
000123r 2               ; @PARAM	c: default=1
000123r 2               ;*------------------------------------------------------------------------------
000123r 2               
000123r 2               .macro ashl c
000123r 2               		cmp #%1000_0000
000123r 2               		php								; Save carry
000123r 2               		.if (.blank(c))
000123r 2               			; ashl
000123r 2               			shl #2
000123r 2               		.elseif (.match(.left(1, {c}), #))
000123r 2               			; ashl #4
000123r 2               			shl #((.right(.tcount ({c})-1, {c})) + 1)
000123r 2               		.else
000123r 2               			.error "Arg \"c\" in macro ashl is wrong."
000123r 2               		.endif
000123r 2               		plp
000123r 2               		ror								; a /= 2, carry into bit7
000123r 2               .endmacro
000123r 2               
000123r 2               
000123r 2               ;*------------------------------------------------------------------------------
000123r 2               ; Arithmetic right shift
000123r 2               ; A >>= c
000123r 2               ; @PARAM	c: default=1
000123r 2               ;
000123r 2               ; To ASR a memory location
000123r 2               ; (From http://wiki.nesdev.com/w/index.php/Synthetic_instructions#Arithmetic_shift_right)
000123r 2               ; 	lda addr		; Copy memory into A
000123r 2               ; 	asl				; Copy sign bit of A into carry (shorter than CMP)
000123r 2               ; 	ror addr
000123r 2               ;*------------------------------------------------------------------------------
000123r 2               
000123r 2               .macro ashr c
000123r 2               		.if (.blank(c))
000123r 2               			; ashr
000123r 2               			cmp #%1000_0000				; Bit7 into carry
000123r 2               			ror							; Shift carry into Bit7
000123r 2               		.elseif (.match(.left(1, {c}), #))
000123r 2               			; ashr #4
000123r 2               			.repeat (.right(.tcount ({c})-1, {c}))
000123r 2               				cmp #%1000_0000
000123r 2               				ror
000123r 2               			.endrepeat
000123r 2               		.else
000123r 2               			.error "Arg \"c\" in macro ashr is wrong."
000123r 2               		.endif
000123r 2               .endmacro
000123r 2               
000123r 2               
000123r 1               .include "./asm/nmi.asm"
000123r 2               ;*------------------------------------------------------------------------------
000123r 2               ; BG_BUFFを読み取り，指定アドレスに書き込んでカウンタをインクリメント
000123r 2               ; Read PPU update data & store to PPU
000123r 2               ; @PARAM	ADDR: Forwarding address
000123r 2               ; @BREAK	A X
000123r 2               ; @RETURN	None
000123r 2               ;*------------------------------------------------------------------------------
000123r 2               
000123r 2               .macro tfrDataToPPU ADDR
000123r 2               	lda BG_BUFF, x
000123r 2               	sta ADDR
000123r 2               	inx
000123r 2               .endmacro
000123r 2               
000123r 2               ; memo
000123r 2               ; ----- PPU buff data structure -----
000123r 2               ; r: Direction
000123r 2               ; 	Bit0 is a flag, others are 1.
000123r 2               ; 	-> 0b1111_111[0/1]
000123r 2               ; 	-> 0xFE（Horizontal）/0xFF（Vertical）
000123r 2               ; a: Addr
000123r 2               ; d: Data
000123r 2               ; r [a a] [d d d ... d] r [a a] [d d ... d]
000123r 2               
000123r 2               
000123r 2               ;*------------------------------------------------------------------------------
000123r 2               ; NMI (Interrupt)
000123r 2               ; @BREAK X Y (When end main process.)
000123r 2               ; To shorten the clock, put the buffer data on the stack
000123r 2               ; 	(Shorten clock by buff data length)
000123r 2               ; 	pla -> 3 clc
000123r 2               ; 	lda ZP/ABSORUTE, x -> 4 clc
000123r 2               ;*------------------------------------------------------------------------------
000123r 2               
000123r 2               .proc NMI
000123r 2  48           		pha								; If main processing has not finished, tmp_rgstA may be in use
000124r 2  E6 rr        		inc nmi_cnt
000126r 2  A5 rr        		lda is_processing_main
000128r 2  F0 02        		beq @NMI_MAIN
00012Ar 2  68           		pla
00012Br 2  40           		rti	; --------------------------
00012Cr 2               
00012Cr 2               @NMI_MAIN:
00012Cr 2  C5 rr        		cmp bg_buff_pointer				; A = 0
00012Er 2  F0 35        		beq @STORE_CHR
000130r 2  AA           		tax
000131r 2  BD 00 01     		lda BG_BUFF, x
000134r 2               @SET_MODE:
000134r 2  29 01        		and #%00000001					; Get flag
000136r 2  0A 0A        		shl #2							; Move flag to Bit2
000138r 2  85 rr        		sta tmp1						; Start using tmp1
00013Ar 2  A5 rr        		lda ppu_ctrl1_cpy
00013Cr 2  29 FB        		and #%11111011					; Mask direction flag
00013Er 2  05 rr        		ora tmp1						; End using tmp1
000140r 2  85 rr        		sta ppu_ctrl1_cpy
000142r 2  8D 00 20     		sta PPU_CTRL1					; Not use restorePPUSet()
000145r 2               @SET_ADDR:
000145r 2  E8           		inx								; Not do inx when go to @EXIT
000146r 2  BD 00 01     		lda BG_BUFF, x
000149r 2  8D 06 20     		sta PPU_ADDR
00014Cr 2  E8           		inx
00014Dr 2  BD 00 01     		lda BG_BUFF, x
000150r 2  8D 06 20     		sta PPU_ADDR
000153r 2  E8           		inx
000154r 2               @STORE_DATA:
000154r 2  BD 00 01     		lda BG_BUFF, x
000157r 2  A8           		tay
000158r 2  C9 FE        		cmp #$fe
00015Ar 2  B0 D8        		bcs @SET_MODE					; no inx
00015Cr 2  98           		tya
00015Dr 2  8D 07 20     		sta PPU_DATA
000160r 2  E8           		inx
000161r 2  E4 rr        		cpx bg_buff_pointer
000163r 2  D0 EF        		bne @STORE_DATA
000165r 2               
000165r 2               		; @SET_MODE + @SET_ADDR = 51 cycle
000165r 2               		; @STORE_DATA (return @STORE_DATA) = 24 cycle
000165r 2               		; @STORE_DATA (return @SET_MODE) = 13 cycle
000165r 2               
000165r 2               		; str1 = "A  B"
000165r 2               		; 	=> 51 + space_len * 24 cycle
000165r 2               		; 	=> mode(1) + addr(2) + data(2 + space_len) = (5 + space_len) bytes
000165r 2               		; 	|  len  || 1  | 2  |  3  |  4  |
000165r 2               		; 	| cycle || 75 | 99 | 123 | 147 |
000165r 2               		;	| bytes || 6  | 7  |  8  |  9  |
000165r 2               		; str2 = 'A', str3 = 'B'
000165r 2               		; 	=> (51 + 13) * 2 = 64 * 2 = 128 cycle
000165r 2               		; 	=> (mode(1) + addr(2) + data(1)) * 2 = 8 bytes
000165r 2               		; space length:
000165r 2               		; 	1: 75 cycle,	6 bytes (str1)
000165r 2               		; 	2: 99 cycle,	7 bytes
000165r 2               		; 	3: 123 cycle,	8 bytes
000165r 2               		; 	4~: 128 cycle,	8 bytes (str2)
000165r 2               @STORE_CHR:
000165r 2  A9 00        		lda #0
000167r 2  8D 03 20     		sta OAM_ADDR
00016Ar 2  A9 03        		lda #$03
00016Cr 2  8D 14 40     		sta OAM_DMA
00016Fr 2               
00016Fr 2               @EXIT:
00016Fr 2  A9 01        		lda #1
000171r 2  85 rr        		sta is_processing_main
000173r 2  4A           		shr								; A = 0
000174r 2  85 rr        		sta bg_buff_pointer
000176r 2  E6 rr        		inc frm_cnt
000178r 2  20 rr rr     		jsr _setScroll
00017Br 2  68           		pla
00017Cr 2  40           		rti	; --------------------------
00017Dr 2               .endproc
00017Dr 2               
00017Dr 2               
00017Dr 1               .include "./asm/sub.asm"
00017Dr 2               ;*------------------------------------------------------------------------------
00017Dr 2               ; Restore PPU setting
00017Dr 2               ; @PARAM	None
00017Dr 2               ; @BREAK	A
00017Dr 2               ; @RETURN	None
00017Dr 2               ;*------------------------------------------------------------------------------
00017Dr 2               
00017Dr 2               _restorePPUSet:
00017Dr 2  A5 rr        		lda ppu_ctrl1_cpy
00017Fr 2  8D 00 20     		sta PPU_CTRL1
000182r 2  A5 rr        		lda ppu_ctrl2_cpy
000184r 2  8D 01 20     		sta PPU_CTRL2
000187r 2  60           		rts	; --------------------------
000188r 2               
000188r 2               
000188r 2               ;*------------------------------------------------------------------------------
000188r 2               ; Get Joypad data (including prev and newly pushed btn)
000188r 2               ; @PARAM	None
000188r 2               ; @BREAK	A
000188r 2               ; @RETURN	None
000188r 2               ;*------------------------------------------------------------------------------
000188r 2               
000188r 2               _getJoyData:
000188r 2               		; set prev
000188r 2  A5 rr        		lda joy1
00018Ar 2  85 rr        		sta joy1_prev
00018Cr 2  A5 rr        		lda joy2
00018Er 2  85 rr        		sta joy2_prev
000190r 2               
000190r 2  20 rr rr     		jsr _readJoy
000193r 2               
000193r 2  A5 rr        		lda joy1
000195r 2  29 0A        		and #BTN_U|BTN_L				; Compare Up and Left...
000197r 2  4A           		lsr
000198r 2  25 rr        		and joy1						; to Down and Right
00019Ar 2  F0 0A        		beq @GET_PUSHSTART_BTN
00019Cr 2               		; Use previous frame's directions
00019Cr 2  A5 rr        		lda joy1
00019Er 2  45 rr        		eor joy1_prev
0001A0r 2  29 F0        		and #%11110000
0001A2r 2  45 rr        		eor joy1_prev
0001A4r 2  85 rr        		sta joy1
0001A6r 2               
0001A6r 2               @GET_PUSHSTART_BTN:
0001A6r 2               		; set pushstart
0001A6r 2  A5 rr        		lda joy1_prev
0001A8r 2  49 FF        		eor #%11111111
0001AAr 2  25 rr        		and joy1
0001ACr 2  85 rr        		sta joy1_pushstart
0001AEr 2  A5 rr        		lda joy2_prev
0001B0r 2  49 FF        		eor #%11111111
0001B2r 2  25 rr        		and joy2
0001B4r 2  85 rr        		sta joy2_pushstart
0001B6r 2               
0001B6r 2  60           		rts	; --------------------------
0001B7r 2               
0001B7r 2               
0001B7r 2               ;*------------------------------------------------------------------------------
0001B7r 2               ; Read controller
0001B7r 2               ; @PARAM	None
0001B7r 2               ; @BREAK	A
0001B7r 2               ; @RETURN	None
0001B7r 2               ;*------------------------------------------------------------------------------
0001B7r 2               
0001B7r 2               _readJoy:
0001B7r 2               		; Init controller & Set a ring counter
0001B7r 2  A9 01        		lda #1
0001B9r 2  8D 16 40     		sta JOYPAD1
0001BCr 2  85 rr        		sta joy2						; ring counter
0001BEr 2  4A           		lsr								; A = 0
0001BFr 2  8D 16 40     		sta JOYPAD1
0001C2r 2               
0001C2r 2               @READ_JOY_LOOP:
0001C2r 2  AD 16 40     		lda JOYPAD1
0001C5r 2  29 03        		and #%00000011
0001C7r 2  C9 01        		cmp #$01						; A - 1 = A + 0xff; if A > 0 then Carry=1
0001C9r 2  26 rr        		rol joy1						; Carry -> Bit0; Bit7 -> Carry
0001CBr 2  AD 17 40     		lda JOYPAD2
0001CEr 2  29 03        		and #%00000011
0001D0r 2  C9 01        		cmp #$01
0001D2r 2  26 rr        		rol joy2
0001D4r 2  90 EC        		bcc @READ_JOY_LOOP				; CarryON -> end
0001D6r 2  60           		rts	; --------------------------
0001D7r 2               
0001D7r 2               
0001D7r 2               ;*------------------------------------------------------------------------------
0001D7r 2               ; Set scroll position
0001D7r 2               ; Use during NMI or executing raster scroll.
0001D7r 2               ; @PARAM	None
0001D7r 2               ; @BREAK	A
0001D7r 2               ; @RETURN	None
0001D7r 2               ;*------------------------------------------------------------------------------
0001D7r 2               
0001D7r 2               _setScroll:
0001D7r 2  A5 rr        		lda scroll_x
0001D9r 2  8D 05 20     		sta PPU_SCROLL
0001DCr 2  A5 rr        		lda scroll_y
0001DEr 2  8D 05 20     		sta PPU_SCROLL
0001E1r 2  60           		rts	; --------------------------
0001E2r 2               
0001E2r 2               
0001E2r 2               ;*------------------------------------------------------------------------------
0001E2r 2               ; Wait starting vblank
0001E2r 2               ; @PARAM	None
0001E2r 2               ; @BREAK	None
0001E2r 2               ; @RETURN	Non
0001E2r 2               ;*------------------------------------------------------------------------------
0001E2r 2               
0001E2r 2               _wait_vblank:
0001E2r 2  2C 02 20     		bit $2002
0001E5r 2  10 FB        		bpl _wait_vblank
0001E7r 2  60           		rts	; --------------------------
0001E8r 2               
0001E8r 2               
0001E8r 2               ;*------------------------------------------------------------------------------
0001E8r 2               ; Disp status text
0001E8r 2               ; @PARAM	None
0001E8r 2               ; @BREAK	A X Y
0001E8r 2               ; @RETURN	None
0001E8r 2               ;*------------------------------------------------------------------------------
0001E8r 2               
0001E8r 2               _disp_status:
0001E8r 2  A6 rr        		ldx bg_buff_pointer
0001EAr 2  A0 1F        		ldy #(@TEXT_END - @TEXT)
0001ECr 2               @STORE_PPU_DATA_LOOP:
0001ECr 2  BD rr rr     		lda @TEXT, x
0001EFr 2  F0 07        		beq @END_STORE
0001F1r 2  9D 00 01     		sta BG_BUFF, x
0001F4r 2  E8           		inx
0001F5r 2  88           		dey
0001F6r 2  D0 F4        		bne @STORE_PPU_DATA_LOOP
0001F8r 2               @END_STORE:
0001F8r 2  86 rr        		stx bg_buff_pointer
0001FAr 2  86 80        		stx $80
0001FCr 2  60           		rts	; --------------------------
0001FDr 2               
0001FDr 2               .rodata									; ----- data -----
000000r 2               @TEXT:
000000r 2  FE 20 22     		.byte PPU_VERTICAL_MODE
000003r 2               		ADDR_BG_BE 2, 1, 0
000003r 2  53 43 4F 52  		.byte "SCORE XXXXXX  C:YY  TIME ZZZ"
000007r 2  45 20 58 58  
00000Br 2  58 58 58 58  
00001Fr 2               @TEXT_END:
00001Fr 2               
00001Fr 1               .include "main.asm"
00001Fr 2               ;*------------------------------------------------------------------------------
00001Fr 2               ; MAIN routine
00001Fr 2               ;*------------------------------------------------------------------------------
00001Fr 2               
00001Fr 2               .proc MAIN
00001Fr 2  A5 rr        		lda is_processing_main
000021r 2  F0 FC        		beq MAIN
000023r 2               
000023r 2  20 rr rr     		jsr _getJoyData
000026r 2               
000026r 2  A5 rr        		lda joy1_pushstart
000028r 2  29 80        		and #BTN_A
00002Ar 2  F0 03        		beq @SKIP1
00002Cr 2               
00002Cr 2  20 rr rr     		jsr _drawMap
00002Fr 2               @SKIP1:
00002Fr 2               
00002Fr 2               		; ----- End main -----
00002Fr 2               
00002Fr 2  A9 00        		lda #0
000031r 2  85 rr        		sta is_processing_main
000033r 2  4C rr rr     		jmp MAIN
000036r 2               .endproc
000036r 2               
000036r 1               .include "./asm/init.asm"
000036r 2               .macro init
000036r 2               		sei								; Ban IRQ
000036r 2               		cld								; Ban BCD
000036r 2               		ldx #$ff
000036r 2               		txs
000036r 2               		inx
000036r 2               		stx PPU_CTRL1
000036r 2               		stx PPU_CTRL2
000036r 2               		stx SOUND_DP_1					; Ban IRQ of APU DMC (bit7)
000036r 2               
000036r 2               		/*
000036r 2               		A & $2002 -> set Z(zero flag)
000036r 2               		$2002 bit7(vblank) -> N(negative), bit6(sprite 0 hit) -> V(overflow)
000036r 2               		Reset vblank & sprite 0 hit flag
000036r 2               		(The state of this flag after reset is undefined.)
000036r 2               		*/
000036r 2               		bit $2002
000036r 2               
000036r 2               		jsr _wait_vblank				; 1st time
000036r 2               
000036r 2               		; It takes about 30,000 cycles for the PPU to stabilize.
000036r 2               
000036r 2               		lda #$20
000036r 2               		sta PPU_ADDR
000036r 2               		txa								; X = A = 0
000036r 2               		sta PPU_ADDR
000036r 2               @CLR_MEM:
000036r 2               		sta $00, x
000036r 2               		sta $0100, x
000036r 2               		sta $0200, x
000036r 2               		sta $0400, x
000036r 2               		sta $0500, x
000036r 2               		sta $0600, x
000036r 2               		sta $0700, x
000036r 2               		inx
000036r 2               		bne @CLR_MEM
000036r 2               
000036r 2               		; CLEAR $2000~27ff
000036r 2               		ldy #8
000036r 2               @CLR_VRAM:
000036r 2               		sta PPU_DATA
000036r 2               		inx
000036r 2               		bne @CLR_VRAM
000036r 2               		dey
000036r 2               		bne @CLR_VRAM
000036r 2               
000036r 2               		lda #$ff
000036r 2               @CLR_CHR_MEM:
000036r 2               		sta $0300, x
000036r 2               		inx
000036r 2               		bne @CLR_CHR_MEM
000036r 2               
000036r 2               		; ここで必要なメモリの初期化
000036r 2               		lda #%10010000					; |NMI-ON|PPU=MASTER|SPR8*8|BG$1000|SPR$0000|VRAM+1|SCREEN$2000|
000036r 2               		sta ppu_ctrl1_cpy
000036r 2               		lda #%00011110					; |R|G|B|DISP-SPR|DISP-BG|SHOW-L8-SPR|SHOW-L8-BG|MODE=COLOR|
000036r 2               		sta ppu_ctrl2_cpy
000036r 2               
000036r 2               		jsr _wait_vblank				; 2nd time
000036r 2               
000036r 2               		; Transfar pallete
000036r 2               		lda #>PLT_TABLE_ADDR
000036r 2               		sta PPU_ADDR
000036r 2               		lda #<PLT_TABLE_ADDR			; Addr lo = 00
000036r 2               		sta PPU_ADDR
000036r 2               		tax
000036r 2               @TFR_PAL:
000036r 2               		lda DEFAULT_PLT, x
000036r 2               		sta PPU_DATA
000036r 2               		inx
000036r 2               		cpx #$20
000036r 2               		bne @TFR_PAL
000036r 2               
000036r 2               		lda #0
000036r 2               		sta OAM_ADDR
000036r 2               		lda #$03
000036r 2               		sta OAM_DMA
000036r 2               
000036r 2               		lda #$ff
000036r 2               		sta row_counter
000036r 2               		ldy #0
000036r 2               		jsr _setStageAddr
000036r 2               		ldy #0
000036r 2               		jsr _setMapAddr
000036r 2               
000036r 2               		; スクリーンON
000036r 2               		jsr _restorePPUSet
000036r 2               		jsr _setScroll
000036r 2               
000036r 2               		jsr _wait_vblank
000036r 2               		jsr _disp_status
000036r 2               .endmacro
000036r 2               
000036r 1               .include "./asm/draw_map.asm"
000036r 2               ;*------------------------------------------------------------------------------
000036r 2               ; Update one row
000036r 2               ; @PARAM	None
000036r 2               ; @BREAK	A X Y tmp1 tmp2
000036r 2               ; @RETURN	None
000036r 2               ;*------------------------------------------------------------------------------
000036r 2               
000036r 2               _drawMap:
000036r 2  A5 rr        	lda isend_draw_stage
000038r 2  D0 50        	bne @EXIT
00003Ar 2  A4 rr        	ldy row_counter
00003Cr 2  C8           	iny
00003Dr 2  C0 10        	cpy #$10
00003Fr 2  D0 04        	bne @SKIP
000041r 2  A0 00        	ldy #0
000043r 2  E6 rr        	inc map_buff_num
000045r 2               @SKIP:
000045r 2  84 rr        	sty row_counter
000047r 2               
000047r 2  A4 rr        	ldy index
000049r 2               
000049r 2               @LOOP1:
000049r 2               	; get pos
000049r 2  B1 rr        	lda (map_addr), y
00004Br 2  C9 FE        	cmp #OBJMAP_NEXT
00004Dr 2  F0 26        	beq @LOAD_NEXT_MAP
00004Fr 2               
00004Fr 2  C9 FF        	cmp #OBJMAP_END
000051r 2  F0 27        	beq @END_MAP_DATA
000053r 2               
000053r 2  85 rr        	sta addr1+0
000055r 2  29 0F        	and #%0000_1111
000057r 2  C5 rr        	cmp row_counter
000059r 2  D0 17        	bne @LOOP_EXIT
00005Br 2               
00005Br 2  A5 rr        	lda map_buff_num
00005Dr 2  C5 rr        	cmp cnt_map_next					; Count OBJMAP_NEXT (is not reset until the stage changes)
00005Fr 2  D0 11        	bne @LOOP_EXIT
000061r 2               
000061r 2  29 01        	and #%0000_0001
000063r 2  18 69 04     	add #4
000066r 2  85 rr        	sta addr1+1
000068r 2               
000068r 2               	; get chr
000068r 2  C8           	iny
000069r 2  B1 rr        	lda (map_addr), y
00006Br 2               
00006Br 2  A2 00        	ldx #0
00006Dr 2  81 rr        	sta (addr1, x)						; End using addr1
00006Fr 2  C8           	iny
000070r 2  D0 D7        	bne @LOOP1							; Jmp
000072r 2               
000072r 2               @LOOP_EXIT:
000072r 2  84 rr        	sty index
000074r 2               
000074r 2  60           	rts	; ------------------------------
000075r 2               
000075r 2               @LOAD_NEXT_MAP:
000075r 2  E6 rr        	inc cnt_map_next
000077r 2  C8           	iny
000078r 2  D0 CF        	bne @LOOP1							; Jmp
00007Ar 2               
00007Ar 2               @END_MAP_DATA:
00007Ar 2               	; 次のマップ読み込み
00007Ar 2  A4 rr        	ldy map_arr_num
00007Cr 2  C8           	iny
00007Dr 2  84 rr        	sty map_arr_num
00007Fr 2  20 rr rr     	jsr _setMapAddr						; Use Y as arg
000082r 2  C9 FF        	cmp #$ff							; A = Addr Hi
000084r 2  D0 04        	bne @EXIT
000086r 2               
000086r 2  A9 01        	lda #1
000088r 2  85 rr        	sta isend_draw_stage
00008Ar 2               
00008Ar 2               @EXIT:
00008Ar 2  A9 00        	lda #0
00008Cr 2  85 rr        	sta index
00008Er 2               
00008Er 2  60           	rts	;-------------------------------
00008Fr 2               
00008Fr 2               
00008Fr 2               ;*------------------------------------------------------------------------------
00008Fr 2               ; Set addr of stage data
00008Fr 2               ; @PARAM	Y: stage number
00008Fr 2               ; @BREAK	A Y
00008Fr 2               ; @RETURN	None (A = addr Hi)
00008Fr 2               ;*------------------------------------------------------------------------------
00008Fr 2               
00008Fr 2               _setStageAddr:
00008Fr 2  98           	tya
000090r 2  0A           	shl
000091r 2  A8           	tay
000092r 2               
000092r 2  B9 rr rr     	lda STAGE_ARR, y
000095r 2  85 rr        	sta map_arr_addr
000097r 2               
000097r 2  B9 rr rr     	lda STAGE_ARR+1, y
00009Ar 2  85 rr        	sta map_arr_addr+1
00009Cr 2  60           	rts	; ------------------------------
00009Dr 2               
00009Dr 2               _setMapAddr:
00009Dr 2  98           	tya
00009Er 2  0A           	shl
00009Fr 2  A8           	tay
0000A0r 2               
0000A0r 2  B1 rr        	lda (map_arr_addr), y
0000A2r 2  85 rr        	sta map_addr
0000A4r 2               
0000A4r 2  C8           	iny
0000A5r 2  B1 rr        	lda (map_arr_addr), y
0000A7r 2  85 rr        	sta map_addr+1
0000A9r 2               
0000A9r 2  60           	rts	; ------------------------------
0000AAr 2               
0000AAr 1               
0000AAr 1               ; Use .org
0000AAr 1               .org SPR_BUFF
000300  1  xx xx xx xx  		.tag SPR_TBL
000304  1  xx xx xx xx  
000308  1  xx xx xx xx  
000400  1               
000400  1               .code
000400  1               .org $8000
008000  1               .segment "STARTUP"
008000  1               .proc RESET
008000  1  78 D8 A2 FF  		init
008004  1  9A E8 8E 00  
008008  1  20 8E 01 20  
00808D  1               
00808D  1  A9 01        		lda #1
00808F  1  85 rr        		sta is_processing_main
008091  1               
008091  1  4C rr rr     		jmp MAIN
008094  1               .endproc
008094  1               
008094  1               .proc IRQ
008094  1  40           		rti
008095  1               .endproc
008095  1               
008095  1               .segment "CHARS"
008095  1  03 0F 1F 1F  		.incbin "spr_bg.chr"
008099  1  1C 24 26 66  
00809D  1  00 00 00 00  
00A095  1               
00A095  1               .segment "VECINFO"
00A095  1  rr rr        		.word NMI
00A097  1  00 80        		.word RESET
00A099  1  94 80        		.word IRQ
00A099  1               
