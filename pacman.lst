ca65 V2.19 - Git de30a57
Main file   : pacman.asm
Current file: pacman.asm

000000r 1               .setcpu "6502"
000000r 1               .feature c_comments						; Allow C language type comments (/* comments */)
000000r 1               .feature underline_in_numbers			; Allow notation %1010_0010
000000r 1               .feature string_escapes					; Allow \t, \n, \" and so on
000000r 1               .linecont +								; Allow line breaks in the middle of lines if you put a backslash at the end of the line
000000r 1               
000000r 1               
000000r 1               .segment "HEADER"
000000r 1  4E 45 53 1A  		.byte "NES", $1a
000004r 1  02           		.byte $02						; Program bank
000005r 1  01           		.byte $01						; Charactor bank
000006r 1  01           		.byte $01						; Vartical mirror
000007r 1  00           		.byte $00
000008r 1  00 00 00 00  		.byte $00, $00, $00, $00
00000Cr 1  00 00 00 00  		.byte $00, $00, $00, $00
000010r 1               
000010r 1               
000010r 1               .rodata									; ----- data -----
000000r 1               
000000r 1               .include "./inc/const.inc"
000000r 2               PPU_VERTICAL_MODE						= %11111110
000000r 2               PPU_HORIZONTAL_MODE						= %11111111
000000r 2               
000000r 2               ENDCODE									= $ff
000000r 2               
000000r 2               OBJMAP_NEXT								= $fe
000000r 2               OBJMAP_END								= $ff
000000r 2               
000000r 2               PPU_CTRL1_STD							= %10010000			; |NMION|PPU=MASTER|SPR8*8|BG$1000|SPR$0000|VRAM+1|SCRN$2000(2)|
000000r 2               PPU_CTRL2_STD							= %00011110			; |R|G|B|DISP-SPR|DISP-BG|SHOW-L8SPR|SHOW-L8BG|MODE=COLOR|
000000r 2               
000000r 2               BIT0									= %00000001
000000r 2               BIT1									= %00000010
000000r 2               BIT2									= %00000100
000000r 2               BIT3									= %00001000
000000r 2               BIT4									= %00010000
000000r 2               BIT5									= %00100000
000000r 2               BIT6									= %01000000
000000r 2               BIT7									= %10000000
000000r 2               
000000r 2               BYT_HI									= %11110000
000000r 2               BYT_LO									= %00001111
000000r 2               
000000r 2               LO										= 0
000000r 2               HI										= 1
000000r 2               
000000r 2               INIT									= 0
000000r 2               
000000r 2               PLAYER_WIDTH							= $c
000000r 2               PLAYER_PADDING							= $2
000000r 2               
000000r 2               PLAYER_MAX_POSX							= $70				; マリオの行ける最大X座標（スクロールロックが無いとき）
000000r 2               
000000r 1               .include "./inc/const_addr.inc"
000000r 2               ZP					= $00
000000r 2               ; Unused $0200
000000r 2               bg_map_buff			= $0100				; size = $d ($10 - $3) * $4 = $40 - $c = $34
000000r 2               bg_plt_buff			= $0134				; size = 8
000000r 2               fill_block_arr		= $013c				; size = 13 ($d)
000000r 2               bg_buff				= $0149
000000r 2               CHR_BUFF			= $0300
000000r 2               MAP1				= $0400
000000r 2               MAP2				= $0500
000000r 2               USER_MEM			= $0700
000000r 2               
000000r 2               PLT_TABLE_ADDR		= $3f00
000000r 2               
000000r 2               PPU_CTRL1			= $2000
000000r 2               PPU_CTRL2			= $2001
000000r 2               PPU_STATUS			= $2002
000000r 2               OAM_ADDR			= $2003
000000r 2               OAM_DATA			= $2004
000000r 2               PPU_SCROLL			= $2005
000000r 2               PPU_ADDR			= $2006
000000r 2               PPU_DATA			= $2007
000000r 2               OAM_DMA				= $4014
000000r 2               
000000r 2               
000000r 2               SOUND_SQ1_1			= $4000				; Duty(2)|time counter|音響変化|ボリューム(4)
000000r 2               SOUND_SQ1_2			= $4001				; 周波数変化|変化速度(3)|変化方向|変化範囲(3)
000000r 2               SOUND_SQ1_3			= $4002				; 周波数下位
000000r 2               SOUND_SQ1_4			= $4003				; 再生時間(5)|周波数上位(3)
000000r 2               SOUND_SQ2_1			= $4004
000000r 2               SOUND_SQ2_2			= $4005
000000r 2               SOUND_SQ2_3			= $4006
000000r 2               SOUND_SQ2_4			= $4007
000000r 2               SOUND_TR_1			= $4008				; 再生時間カウンタ|カウンタを使用した長さ(7)
000000r 2               SOUND_TR_2			= $400A				; 周波数下位
000000r 2               SOUND_TR_3			= $400B				; 再生時間(5)|周波数上位(3)
000000r 2               SOUND_NS_1			= $400C				; 未使用(2)|再生時間カウンタ|音響固定|ボリューム(3)
000000r 2               SOUND_NS_2			= $400E				; 乱数タイプ(高周波)|未使用(3)|サンプルレート(4)
000000r 2               SOUND_NS_3			= $400F				; 再生時間(5)|未使用(3)
000000r 2               SOUND_DP_1			= $4010
000000r 2               SOUND_DP_2			= $4011
000000r 2               SOUND_DP_3			= $4012
000000r 2               SOUND_DP_4			= $4013
000000r 2               SOUND_CHANNEL		= $4015				; 未使用(3)|DPCM|ノイズ|三角波|CH2|CH1
000000r 2               
000000r 2               
000000r 2               JOYPAD1				= $4016
000000r 2               JOYPAD2				= $4017
000000r 2               
000000r 1               .include "./inc/var_addr.inc"
000000r 2               ; ZeroPage
000000r 2               .segment "ZEROPAGE"
000000r 2  00           tmp1					: .byte 0
000001r 2  00           tmp2					: .byte 0
000002r 2  00           tmp3					: .byte 0
000003r 2  00           tmp4					: .byte 0
000004r 2  00           tmp5					: .byte 0
000005r 2  00           tmp6					: .byte 0
000006r 2               
000006r 2  00           bg_buff_pointer			: .byte 0
000007r 2  00 00        addr_tmp1				: .addr 0
000009r 2  00 00        addr_tmp2				: .addr 0
00000Br 2               
00000Br 2  00           bg_map_buff_index		: .byte 0		; BG（マップ）専用バッファ
00000Cr 2               
00000Cr 2  00 00        ppu_bg_addr				: .addr 0
00000Er 2               
00000Er 2  00           tmp_rgstA				: .byte 0
00000Fr 2  00           tmp_rgstX				: .byte 0
000010r 2  00           tmp_rgstY				: .byte 0
000011r 2               
000011r 2               ; These are not used often, but are used in NMI
000011r 2  00           ppu_ctrl1_cpy			: .byte 0		; |NMI-ON|PPU=MASTER|SPR8*8|BG$1000|SPR$0000|VRAM+1|SCREEN$2000(2)|
000012r 2  00           ppu_ctrl2_cpy			: .byte 0		; |R|G|B|DISP-SPR|DISP-BG|SHOW-L8-SPR|SHOW-L8-BG|MODE=COLOR|
000013r 2               
000013r 2  00           scroll_x				: .byte 0
000014r 2  00           scroll_amount			: .byte 0
000015r 2               
000015r 2  00           main_disp				: .byte 0
000016r 2               
000016r 2  00           nmi_cnt					: .byte 0
000017r 2  00           frm_cnt					: .byte 0
000018r 2  00           is_processing_main		: .byte 0
000019r 2               
000019r 2  00 00        plt_addr				: .addr 0
00001Br 2               
00001Br 2  00           is_updated_map			: .byte 0
00001Cr 2               
00001Cr 2  00           is_scroll_locked		: .byte 0
00001Dr 2               
00001Dr 2               
00001Dr 2               .segment "BUFF_MEM"
000000r 2               
000000r 2               
000000r 2  xx xx xx xx  spr_posX_arr			: .res 11
000004r 2  xx xx xx xx  
000008r 2  xx xx xx     
00000Br 2  xx xx xx xx  spr_posY_arr			: .res 11
00000Fr 2  xx xx xx xx  
000013r 2  xx xx xx     
000016r 2  xx xx xx xx  spr_id_arr				: .res 11		; id = 0: no spr
00001Ar 2  xx xx xx xx  
00001Er 2  xx xx xx     
000021r 2  xx xx xx xx  spr_velocity_arr		: .res 11
000025r 2  xx xx xx xx  
000029r 2  xx xx xx     
00002Cr 2               
00002Cr 2               
00002Cr 2               .code
000000r 2               
000000r 1               .include "./inc/defmacro.inc"
000000r 2               ;*------------------------------------------------------------------------------
000000r 2               ; Calcurate BG address
000000r 2               ; @PARAMS	 ptx: X coordinate
000000r 2               ; @PARAMS	 pty: Y coordinate
000000r 2               ; @PARAMS	 scn: Screen number
000000r 2               ;*------------------------------------------------------------------------------
000000r 2               
000000r 2               .define ADDR_BG (ptx, pty, scn)			$2000 + (ptx) + ((pty) * $20) + ((scn) * $400)
000000r 2               .define ADDR_BG_BE (ptx, pty, scn)		GET_BE ADDR_BG (ptx), (pty), (scn)
000000r 2               
000000r 2               ;*------------------------------------------------------------------------------
000000r 2               ; Calcurate SPR address
000000r 2               ; @PARAMS	 spr_num: Sprite number (0~63)
000000r 2               ; @PARAMS	 member:
000000r 2               ; 	pty: PosiTion Y
000000r 2               ; 	num: Tile(8*8) number
000000r 2               ; 	att: Attribute (VertFlip|HorizonFlip|Prio|Unused(3)|PltNum(2))
000000r 2               ; 	ptx: PosiTion X
000000r 2               ;*------------------------------------------------------------------------------
000000r 2               
000000r 2               .define ADDR_SPR(spr_num, member)		CHR_BUFF + ((spr_num)*4) + SPR_STRUCT::member
000000r 2               
000000r 2               
000000r 2               ;*------------------------------------------------------------------------------
000000r 2               ; Get data in big endian
000000r 2               ; dbyt = Define BYTe?
000000r 2               ; Define word data with the hi & lo bytes swapped
000000r 2               ; ($1234=$12,$34)
000000r 2               ;*------------------------------------------------------------------------------
000000r 2               
000000r 2               .define GET_BE(data)					.dbyt data
000000r 2               
000000r 2               
000000r 2               ;*------------------------------------------------------------------------------
000000r 2               ; Get obj position
000000r 2               ; @PARAMS		posX, posY
000000r 2               ; @RETURNS		$YX
000000r 2               ;*------------------------------------------------------------------------------
000000r 2               
000000r 2               .define GET_OBJ_POS(posX, posY)		($c - (posY)) * $10 + (posX)
000000r 2               
000000r 2               
000000r 2               ;*------------------------------------------------------------------------------
000000r 2               ; Return negative number
000000r 2               ;*------------------------------------------------------------------------------
000000r 2               
000000r 2               .define NEGATIVE(val)	256 - (val)
000000r 2               
000000r 1               .include "./inc/palette.inc"
000000r 2               DEFAULT_PLT:
000000r 2               		; BG
000000r 2  36 17 0F     		.byte $36, $17, $0f
000003r 2  27 17 0F     		.byte $27, $17, $0f				; 27 -> 07/17/27
000006r 2  29 1A 0F     		.byte $29, $1a, $0f
000009r 2  30 21 0F     		.byte $30, $21, $0f
00000Cr 2               		; SPR
00000Cr 2  16 27 18     		.byte $16, $27, $18
00000Fr 2  1A 30 27     		.byte $1a, $30, $27
000012r 2  16 30 27     		.byte $16, $30, $27
000015r 2  0F 36 17     		.byte $0f, $36, $17
000018r 2               
000018r 2               
000018r 2               UNDER_GROUND_PLT:
000018r 2               		; BG
000018r 2  3C 1C 0F     		.byte $3c, $1c, $0f
00001Br 2  27 17 1C     		.byte $27, $17, $1c
00001Er 2  29 1A 09     		.byte $29, $1a, $09
000021r 2  30 21 1C     		.byte $30, $21, $1c
000024r 2               		; SPR
000024r 2  16 27 18     		.byte $16, $27, $18
000027r 2  1C 30 17     		.byte $1c, $30, $17				; black disp: $30 -> $36
00002Ar 2  16 30 27     		.byte $16, $30, $27
00002Dr 2  0C 3C 1C     		.byte $0c, $3c, $1c
000030r 2               
000030r 2               
000030r 1               .include "./inc/struct.inc"
000030r 2               .struct	SPR_STRUCT
000030r 2               		pty		.byte					; PosiTion Y
000030r 2               		num		.byte					; Tile(8*8) number
000030r 2               		att		.byte					; Attribute (VertFlip|HorizonFlip|Prio|Unused(3)|PltNum(2))
000030r 2               		ptx		.byte					; PosiTion X
000030r 2               .endstruct
000030r 2               
000030r 2               
000030r 2               .struct	SPR_TBL
000030r 2               		spr		.tag SPR_STRUCT 64
000030r 2               .endstruct
000030r 2               
000030r 1               .include "./inc/map_data.inc"
000030r 2               ; MAP_DATA[stage][map_num][index]
000030r 2               
000030r 2               STAGE_ARR:
000030r 2  rr rr        	.addr MAP_ARR_11
000032r 2  rr rr        	.addr MAP_ARR_12
000034r 2               
000034r 2               MAP_ARR_11:
000034r 2  rr rr        	.addr MAP_11_1
000036r 2  rr rr        	.addr MAP_11_2
000038r 2  FF FF        	.addr $ffff
00003Ar 2               
00003Ar 2               MAP_ARR_12:
00003Ar 2  rr rr        	.addr MAP_12_1
00003Cr 2  FF FF        	.addr $ffff
00003Er 2               
00003Er 2               MAP_11_1:
00003Er 2  BD           	.byte $bd
00003Fr 2  42           	.byte 'B'
000040r 2  00 00        	.byte %00000000, %00000000
000042r 2  90 42        	.byte (GET_OBJ_POS $0, $3), 'B'
000044r 2  78 42        	.byte (GET_OBJ_POS $8, $5), 'B'
000046r 2  49 42        	.byte (GET_OBJ_POS $9, $8), 'B'
000048r 2  79 51        	.byte (GET_OBJ_POS $9, $5), 'Q'
00004Ar 2  4A 51        	.byte (GET_OBJ_POS $a, $8), 'Q'
00004Cr 2  7A 42        	.byte (GET_OBJ_POS $a, $5), 'B'
00004Er 2  4B 42        	.byte (GET_OBJ_POS $b, $8), 'B'
000050r 2  7B 51        	.byte (GET_OBJ_POS $b, $5), 'Q'
000052r 2  7C 42        	.byte (GET_OBJ_POS $c, $5), 'B'
000054r 2  FE           	.byte OBJMAP_NEXT
000055r 2  C0 00        	.byte (GET_OBJ_POS $0, $0), 0
000057r 2  B0 00        	.byte (GET_OBJ_POS $0, $1), 0
000059r 2  C1 00        	.byte (GET_OBJ_POS $1, $0), 0
00005Br 2  B1 00        	.byte (GET_OBJ_POS $1, $1), 0
00005Dr 2  72 42        	.byte (GET_OBJ_POS $2, $5), 'B'
00005Fr 2  FF           	.byte OBJMAP_END
000060r 2               
000060r 2               MAP_11_2:
000060r 2  BD           	.byte $bd
000061r 2  42           	.byte 'B'
000062r 2  00 00        	.byte %00000000, %00000000
000064r 2  70 51        	.byte (GET_OBJ_POS $0, $5), 'Q'
000066r 2  60 51        	.byte (GET_OBJ_POS $0, $6), 'Q'
000068r 2  50 42        	.byte (GET_OBJ_POS $0, $7), 'B'
00006Ar 2  71 51        	.byte (GET_OBJ_POS $1, $5), 'Q'
00006Cr 2  61 51        	.byte (GET_OBJ_POS $1, $6), 'Q'
00006Er 2  51 51        	.byte (GET_OBJ_POS $1, $7), 'Q'
000070r 2  72 51        	.byte (GET_OBJ_POS $2, $5), 'Q'
000072r 2  73 51        	.byte (GET_OBJ_POS $3, $5), 'Q'
000074r 2  FF           	.byte OBJMAP_END
000075r 2               
000075r 2               MAP_12_1:
000075r 2  BD           	.byte $bd
000076r 2  42           	.byte 'B'
000077r 2  10 00        	.byte %00010000, %00000000
000079r 2  A0 42        	.byte (GET_OBJ_POS $0, $2), 'B'
00007Br 2  90 42        	.byte (GET_OBJ_POS $0, $3), 'B'
00007Dr 2  80 42        	.byte (GET_OBJ_POS $0, $4), 'B'
00007Fr 2  70 42        	.byte (GET_OBJ_POS $0, $5), 'B'
000081r 2  60 42        	.byte (GET_OBJ_POS $0, $6), 'B'
000083r 2  50 42        	.byte (GET_OBJ_POS $0, $7), 'B'
000085r 2  40 42        	.byte (GET_OBJ_POS $0, $8), 'B'
000087r 2  30 42        	.byte (GET_OBJ_POS $0, $9), 'B'
000089r 2  20 42        	.byte (GET_OBJ_POS $0, $a), 'B'
00008Br 2  10 42        	.byte (GET_OBJ_POS $0, $b), 'B'
00008Dr 2  00 42        	.byte (GET_OBJ_POS $0, $c), 'B'
00008Fr 2  01 00        	.byte (GET_OBJ_POS $1, $c), 0
000091r 2  02 00        	.byte (GET_OBJ_POS $2, $c), 0
000093r 2  03 00        	.byte (GET_OBJ_POS $3, $c), 0
000095r 2  04 00        	.byte (GET_OBJ_POS $4, $c), 0
000097r 2  05 00        	.byte (GET_OBJ_POS $5, $c), 0
000099r 2  8B 51        	.byte (GET_OBJ_POS $b, $4), 'Q'
00009Br 2  8C 51        	.byte (GET_OBJ_POS $c, $4), 'Q'
00009Dr 2  8D 51        	.byte (GET_OBJ_POS $d, $4), 'Q'
00009Fr 2  8E 51        	.byte (GET_OBJ_POS $e, $4), 'Q'
0000A1r 2  8F 51        	.byte (GET_OBJ_POS $f, $4), 'Q'
0000A3r 2  FE           	.byte OBJMAP_NEXT
0000A4r 2  A2 42        	.byte (GET_OBJ_POS $2, $2), 'B'
0000A6r 2  A4 42        	.byte (GET_OBJ_POS $4, $2), 'B'
0000A8r 2  94 42        	.byte (GET_OBJ_POS $4, $3), 'B'
0000AAr 2  A6 42        	.byte (GET_OBJ_POS $6, $2), 'B'
0000ACr 2  96 42        	.byte (GET_OBJ_POS $6, $3), 'B'
0000AEr 2  86 42        	.byte (GET_OBJ_POS $6, $4), 'B'
0000B0r 2  A8 42        	.byte (GET_OBJ_POS $8, $2), 'B'
0000B2r 2  98 42        	.byte (GET_OBJ_POS $8, $3), 'B'
0000B4r 2  88 42        	.byte (GET_OBJ_POS $8, $4), 'B'
0000B6r 2  78 42        	.byte (GET_OBJ_POS $8, $5), 'B'
0000B8r 2  7A 42        	.byte (GET_OBJ_POS $a, $5), 'B'
0000BAr 2  AC 42        	.byte (GET_OBJ_POS $c, $2), 'B'
0000BCr 2  9C 42        	.byte (GET_OBJ_POS $c, $3), 'B'
0000BEr 2  8C 42        	.byte (GET_OBJ_POS $c, $4), 'B'
0000C0r 2  7C 42        	.byte (GET_OBJ_POS $c, $5), 'B'
0000C2r 2  AE 42        	.byte (GET_OBJ_POS $e, $2), 'B'
0000C4r 2  9E 42        	.byte (GET_OBJ_POS $e, $3), 'B'
0000C6r 2  8E 42        	.byte (GET_OBJ_POS $e, $4), 'B'
0000C8r 2  FE           	.byte OBJMAP_NEXT
0000C9r 2  A0 42        	.byte (GET_OBJ_POS $0, $2), 'B'
0000CBr 2  90 42        	.byte (GET_OBJ_POS $0, $3), 'B'
0000CDr 2  A2 42        	.byte (GET_OBJ_POS $2, $2), 'B'
0000CFr 2  FF           	.byte OBJMAP_END
0000D0r 2               
0000D0r 2               
0000D0r 2               BROCK_ID_ARR:
0000D0r 2               	; 40 = %0100
0000D0r 2  rr rr        	.addr OBJ_SKY						; @ (or 0)
0000D2r 2  00 00        	.addr $0000							; A
0000D4r 2  rr rr        	.addr OBJ_BROCK						; B
0000D6r 2  00 00        	.addr $0000							; C
0000D8r 2  00 00        	.addr $0000							; D
0000DAr 2  00 00        	.addr $0000							; E
0000DCr 2  00 00        	.addr $0000							; F
0000DEr 2  rr rr        	.addr OBJ_GROUND					; G
0000E0r 2  00 00        	.addr $0000							; H
0000E2r 2  00 00        	.addr $0000							; I
0000E4r 2  00 00        	.addr $0000							; J
0000E6r 2  00 00        	.addr $0000							; K
0000E8r 2  00 00        	.addr $0000							; L
0000EAr 2  00 00        	.addr $0000							; M
0000ECr 2  00 00        	.addr $0000							; N
0000EEr 2  00 00        	.addr $0000							; O
0000F0r 2               	; 50 = %0101
0000F0r 2  00 00        	.addr $0000							; P
0000F2r 2  rr rr        	.addr OBJ_QBROCK					; Q
0000F4r 2  00 00        	.addr $0000							; R
0000F6r 2  00 00        	.addr $0000							; S
0000F8r 2  00 00        	.addr $0000							; T
0000FAr 2  00 00        	.addr $0000							; U
0000FCr 2  00 00        	.addr $0000							; V
0000FEr 2  00 00        	.addr $0000							; W
000100r 2  00 00        	.addr $0000							; X
000102r 2  00 00        	.addr $0000							; Y
000104r 2  00 00        	.addr $0000							; Z
000106r 2  00 00        	.addr $0000							; [
000108r 2  00 00        	.addr $0000							; \
00010Ar 2  00 00        	.addr $0000							; ]
00010Cr 2  rr rr        	.addr OBJ_COIN						; ^
00010Er 2  00 00        	.addr $0000							; _
000110r 2               	; 60 = %0110
000110r 2  00 00        	.addr $0000							; `
000112r 2  00 00        	.addr $0000							; a
000114r 2  00 00        	.addr $0000							; b
000116r 2  00 00        	.addr $0000							; c
000118r 2  00 00        	.addr $0000							; d
00011Ar 2  00 00        	.addr $0000							; e
00011Cr 2  00 00        	.addr $0000							; f
00011Er 2  00 00        	.addr $0000							; g
000120r 2  00 00        	.addr $0000							; h
000122r 2  00 00        	.addr $0000							; i
000124r 2  00 00        	.addr $0000							; j
000126r 2  00 00        	.addr $0000							; k
000128r 2  00 00        	.addr $0000							; l
00012Ar 2  00 00        	.addr $0000							; m
00012Cr 2  00 00        	.addr $0000							; n
00012Er 2  00 00        	.addr $0000							; o
000130r 2               	; 70 = %0111
000130r 2  00 00        	.addr $0000							; p
000132r 2  00 00        	.addr $0000							; q
000134r 2  00 00        	.addr $0000							; r
000136r 2  00 00        	.addr $0000							; s
000138r 2  00 00        	.addr $0000							; t
00013Ar 2  00 00        	.addr $0000							; u
00013Cr 2  00 00        	.addr $0000							; v
00013Er 2  00 00        	.addr $0000							; w
000140r 2  00 00        	.addr $0000							; x
000142r 2  00 00        	.addr $0000							; y
000144r 2  00 00        	.addr $0000							; z
000146r 2  00 00        	.addr $0000							; {
000148r 2  00 00        	.addr $0000							; |
00014Ar 2  00 00        	.addr $0000							; }
00014Cr 2  00 00        	.addr $0000							; ~
00014Er 2               
00014Er 2               
00014Er 2               OBJ_SKY:
00014Er 2  00 00        	.byte $00, $00
000150r 2  00 00        	.byte $00, $00
000152r 2               
000152r 2               OBJ_QBROCK:
000152r 2  90 91        	.byte $90, $91
000154r 2  92 93        	.byte $92, $93
000156r 2               
000156r 2               OBJ_BROCK:
000156r 2  94 94        	.byte $94, $94
000158r 2  95 95        	.byte $95, $95
00015Ar 2               
00015Ar 2               OBJ_COIN:
00015Ar 2  84 85        	.byte $84, $85
00015Cr 2  86 87        	.byte $86, $87
00015Er 2               
00015Er 2               OBJ_GROUND:
00015Er 2  80 81        	.byte $80, $81
000160r 2  82 83        	.byte $82, $83
000162r 2               
000162r 2               
000162r 1               
000162r 1               .code									; ----- code -----
000162r 1               
000162r 1               .include "./asm/joypad.asm"
000162r 2               .scope Joypad
000162r 2               
000162r 2               BTN_A									= %10000000
000162r 2               BTN_B									= %01000000
000162r 2               BTN_S									= %00100000
000162r 2               BTN_T									= %00010000
000162r 2               BTN_U									= %00001000
000162r 2               BTN_D									= %00000100
000162r 2               BTN_L									= %00000010
000162r 2               BTN_R									= %00000001
000162r 2               
000162r 2               .ZeroPage
00001Dr 2  00           joy1					: .byte 0
00001Er 2  00           joy2					: .byte 0
00001Fr 2  00           joy1_prev				: .byte 0
000020r 2  00           joy2_prev				: .byte 0
000021r 2  00           joy1_pushstart			: .byte 0
000022r 2  00           joy2_pushstart			: .byte 0
000023r 2               
000023r 2               
000023r 2               ;*------------------------------------------------------------------------------
000023r 2               ; Get Joypad data (including prev and newly pushed btn)
000023r 2               ; @PARAMS		None
000023r 2               ; @CLOBBERS		A
000023r 2               ; @RETURNS		None
000023r 2               ;*------------------------------------------------------------------------------
000023r 2               
000023r 2               .code									; ----- code -----
000162r 2               
000162r 2               .proc _getJoyData
000162r 2               		; set prev
000162r 2  A5 rr        		lda Joypad::joy1
000164r 2  85 rr        		sta Joypad::joy1_prev
000166r 2  A5 rr        		lda Joypad::joy2
000168r 2  85 rr        		sta Joypad::joy2_prev
00016Ar 2               
00016Ar 2  20 rr rr     		jsr Joypad::_readJoy
00016Dr 2               
00016Dr 2  A5 rr        		lda Joypad::joy1
00016Fr 2  29 0A        		and #Joypad::BTN_U|Joypad::BTN_L				; Compare Up and Left...
000171r 2  4A           		lsr
000172r 2  25 rr        		and Joypad::joy1						; to Down and Right
000174r 2  F0 0A        		beq @GET_PUSHSTART_BTN
000176r 2               		; Use previous frame's directions
000176r 2  A5 rr        		lda Joypad::joy1
000178r 2  45 rr        		eor Joypad::joy1_prev
00017Ar 2  29 F0        		and #%11110000
00017Cr 2  45 rr        		eor Joypad::joy1_prev
00017Er 2  85 rr        		sta Joypad::joy1
000180r 2               
000180r 2               @GET_PUSHSTART_BTN:
000180r 2               		; set pushstart
000180r 2  A5 rr        		lda Joypad::joy1_prev
000182r 2  49 FF        		eor #%11111111
000184r 2  25 rr        		and Joypad::joy1
000186r 2  85 rr        		sta Joypad::joy1_pushstart
000188r 2  A5 rr        		lda Joypad::joy2_prev
00018Ar 2  49 FF        		eor #%11111111
00018Cr 2  25 rr        		and Joypad::joy2
00018Er 2  85 rr        		sta Joypad::joy2_pushstart
000190r 2               
000190r 2  60           		rts
000191r 2               		; ------------------------------
000191r 2               .endproc
000191r 2               
000191r 2               
000191r 2               ;*------------------------------------------------------------------------------
000191r 2               ; Read controller
000191r 2               ; @PARAMS		None
000191r 2               ; @CLOBBERS		A
000191r 2               ; @RETURNS		None
000191r 2               ;*------------------------------------------------------------------------------
000191r 2               
000191r 2               .code									; ----- code -----
000191r 2               
000191r 2               .proc _readJoy
000191r 2               		; Init controller & Set a ring counter
000191r 2  A9 01        		lda #1
000193r 2  8D 16 40     		sta JOYPAD1
000196r 2  85 rr        		sta Joypad::joy2						; ring counter
000198r 2  4A           		lsr								; A = 0
000199r 2  8D 16 40     		sta JOYPAD1
00019Cr 2               
00019Cr 2               @READ_JOY_LOOP:
00019Cr 2  AD 16 40     		lda JOYPAD1
00019Fr 2  29 03        		and #%00000011
0001A1r 2  C9 01        		cmp #$01						; A - 1 = A + 0xff; if A > 0 then Carry=1
0001A3r 2  26 rr        		rol Joypad::joy1						; Carry -> Bit0; Bit7 -> Carry
0001A5r 2  AD 17 40     		lda JOYPAD2
0001A8r 2  29 03        		and #%00000011
0001AAr 2  C9 01        		cmp #$01
0001ACr 2  26 rr        		rol Joypad::joy2
0001AEr 2  90 EC        		bcc @READ_JOY_LOOP				; CarryON -> end
0001B0r 2  60           		rts
0001B1r 2               		; ------------------------------
0001B1r 2               .endproc
0001B1r 2               
0001B1r 2               
0001B1r 2               .endscope
0001B1r 2               
0001B1r 1               .include "./asm/macro.asm"
0001B1r 2               ; ------------------------------------------------------------------------------
0001B1r 2               ; Load array
0001B1r 2               ; A = Arr[X][Y]
0001B1r 2               ; @PARAMS		ADDR: Array Address
0001B1r 2               ; @PARAMS		X Y: index (Access Arr[x][y])
0001B1r 2               ; @CLOBBERS		tmp1
0001B1r 2               ; ------------------------------------------------------------------------------
0001B1r 2               
0001B1r 2               .code									; ----- code -----
0001B1r 2               
0001B1r 2               .macro ldarr addr
0001B1r 2               		.if !(.blank(addr))
0001B1r 2               			sty tmp1						; save Y
0001B1r 2               			txa
0001B1r 2               			asl								; ×2（アドレスが16bitなのでARR[x][y]のxが+1 => 読み込むアドレスは+2する必要がある
0001B1r 2               			tay								; アドレッシングに使うためYレジスタへ
0001B1r 2               			lda addr, y						; Low
0001B1r 2               			sta <addr_tmp1
0001B1r 2               			lda addr+1, y					; High
0001B1r 2               			sta >addr_tmp1
0001B1r 2               			ldy tmp1						; restore Y
0001B1r 2               			lda (addr_tmp1), y
0001B1r 2               		.else
0001B1r 2               			.error "Arg addr in macro ldarr is wrong."
0001B1r 2               		.endif
0001B1r 2               .endmacro
0001B1r 2               
0001B1r 2               
0001B1r 2               ; ------------------------------------------------------------------------------
0001B1r 2               ; Calculate Negative Numbers
0001B1r 2               ; ------------------------------------------------------------------------------
0001B1r 2               
0001B1r 2               .code									; ----- code -----
0001B1r 2               
0001B1r 2               .macro cnn
0001B1r 2               		eor #$ff
0001B1r 2               		add #$01
0001B1r 2               .endmacro
0001B1r 2               
0001B1r 2               
0001B1r 2               ; ------------------------------------------------------------------------------
0001B1r 2               ; Addition
0001B1r 2               ; This Macro only supports Immediate/Zeropage/Absolute addressing.
0001B1r 2               ; Other addressing modes are not optimized for speed.
0001B1r 2               ; Other addressing usage: add a, {$00, x} / add a, {($00), y}
0001B1r 2               ; @PARAMS		arg1: register or Address
0001B1r 2               ; @PARAMS		arg2
0001B1r 2               ; ------------------------------------------------------------------------------
0001B1r 2               
0001B1r 2               .code									; ----- code -----
0001B1r 2               
0001B1r 2               .macro add arg1, arg2
0001B1r 2               		.if (.paramcount = 1)
0001B1r 2               			; arg1: val
0001B1r 2               			; add #3 / add $80
0001B1r 2               			clc
0001B1r 2               			adc arg1
0001B1r 2               		.elseif (.paramcount = 2)
0001B1r 2               			; arg1: target
0001B1r 2               			; arg2: val
0001B1r 2               			.if (.match({arg1}, a))
0001B1r 2               				; add a, #3 / add a, $80
0001B1r 2               				clc
0001B1r 2               				adc arg2
0001B1r 2               			.elseif (.match({arg1}, x))
0001B1r 2               				; add x, ??
0001B1r 2               				.if (\
0001B1r 2               					.match(.left(1, {arg2}), #) &&\
0001B1r 2               					.right(.tcount({arg2})-1, {arg2}) <= 7\
0001B1r 2               				)
0001B1r 2               					; add x, #0~7
0001B1r 2               					.repeat (.right(.tcount({arg2})-1, {arg2}))
0001B1r 2               						inx
0001B1r 2               					.endrepeat
0001B1r 2               				.else
0001B1r 2               					pha
0001B1r 2               					txa
0001B1r 2               					clc
0001B1r 2               					adc arg2
0001B1r 2               					tax
0001B1r 2               					pla
0001B1r 2               				.endif
0001B1r 2               			.elseif (.match({arg1}, y))
0001B1r 2               				; add y, ??
0001B1r 2               				.if (\
0001B1r 2               					.match(.left(1, {arg2}), #) &&\
0001B1r 2               					.right(.tcount({arg2})-1, {arg2}) <= 7\
0001B1r 2               				)
0001B1r 2               					; add y, #0~7
0001B1r 2               					.repeat (.right(.tcount ({arg2})-1, {arg2}))
0001B1r 2               						iny
0001B1r 2               					.endrepeat
0001B1r 2               				.else
0001B1r 2               					pha
0001B1r 2               					tya
0001B1r 2               					clc
0001B1r 2               					adc arg2
0001B1r 2               					tay
0001B1r 2               					pla
0001B1r 2               				.endif
0001B1r 2               			.endif
0001B1r 2               		.else
0001B1r 2               			.error "Args in macro add are wrong."
0001B1r 2               		.endif
0001B1r 2               .endmacro
0001B1r 2               
0001B1r 2               
0001B1r 2               ; ------------------------------------------------------------------------------
0001B1r 2               ; Subtraction
0001B1r 2               ; See macro add for comments
0001B1r 2               ; @PARAMS		arg1: register or Address
0001B1r 2               ; @PARAMS		arg2
0001B1r 2               ; ------------------------------------------------------------------------------
0001B1r 2               
0001B1r 2               .code									; ----- code -----
0001B1r 2               
0001B1r 2               .macro sub arg1, arg2
0001B1r 2               		.if (.paramcount = 1)
0001B1r 2               			sec
0001B1r 2               			sbc arg1
0001B1r 2               		.elseif (.paramcount = 2 && .match({arg1}, a))
0001B1r 2               			sec
0001B1r 2               			sbc arg2
0001B1r 2               		.elseif (.paramcount = 2 && .match({arg1}, x))
0001B1r 2               			.if (\
0001B1r 2               				.match(.left(1, {arg2}), #) &&\
0001B1r 2               				.right(.tcount({arg2})-1, {arg2}) <= 7\
0001B1r 2               			)
0001B1r 2               				.repeat (.right(.tcount({arg2})-1, {arg2}))
0001B1r 2               					dex
0001B1r 2               				.endrepeat
0001B1r 2               			.else
0001B1r 2               				pha
0001B1r 2               				txa
0001B1r 2               				sec
0001B1r 2               				sbc arg2
0001B1r 2               				tax
0001B1r 2               				pla
0001B1r 2               			.endif
0001B1r 2               		.elseif (.paramcount = 2 && .match({arg1}, y))
0001B1r 2               			.if (\
0001B1r 2               				.match(.left(1, {arg2}), #) &&\
0001B1r 2               				.right(.tcount({arg2})-1, {arg2}) <= 7\
0001B1r 2               			)
0001B1r 2               				.repeat (.right(.tcount ({arg2})-1, {arg2}))
0001B1r 2               					dey
0001B1r 2               				.endrepeat
0001B1r 2               			.else
0001B1r 2               				pha
0001B1r 2               				tya
0001B1r 2               				sec
0001B1r 2               				sbc arg2
0001B1r 2               				tay
0001B1r 2               				pla
0001B1r 2               			.endif
0001B1r 2               		.else
0001B1r 2               			.error "Args in macro sub are wrong."
0001B1r 2               		.endif
0001B1r 2               .endmacro
0001B1r 2               
0001B1r 2               
0001B1r 2               ;*------------------------------------------------------------------------------
0001B1r 2               ; Light shift
0001B1r 2               ; arg1 <<= c
0001B1r 2               ; @PARAMS		c: default=#1
0001B1r 2               ;*------------------------------------------------------------------------------
0001B1r 2               
0001B1r 2               .code									; ----- code -----
0001B1r 2               
0001B1r 2               .macro shl c
0001B1r 2               		.if (.blank(c))
0001B1r 2               			asl
0001B1r 2               		.elseif (.match(.left(1, {c}), #))
0001B1r 2               			.repeat	(.right(.tcount ({c})-1, {c}))
0001B1r 2               				asl
0001B1r 2               			.endrepeat
0001B1r 2               		.else
0001B1r 2               			.error "Arg \"c\" in macro shl is wrong."
0001B1r 2               		.endif
0001B1r 2               .endmacro
0001B1r 2               
0001B1r 2               
0001B1r 2               ;*------------------------------------------------------------------------------
0001B1r 2               ; Right shift
0001B1r 2               ; arg1 >>= c
0001B1r 2               ; @PARAMS		c: default=#1
0001B1r 2               ;*------------------------------------------------------------------------------
0001B1r 2               
0001B1r 2               .code									; ----- code -----
0001B1r 2               
0001B1r 2               .macro shr c
0001B1r 2               		.if (.blank(c))
0001B1r 2               			lsr
0001B1r 2               		.elseif (.match(.left(1, {c}), #))
0001B1r 2               			.repeat	(.right(.tcount ({c})-1, {c}))
0001B1r 2               				lsr
0001B1r 2               			.endrepeat
0001B1r 2               		.else
0001B1r 2               			.error "Arg \"c\" in macro shr is wrong."
0001B1r 2               		.endif
0001B1r 2               .endmacro
0001B1r 2               
0001B1r 2               
0001B1r 2               ;*------------------------------------------------------------------------------
0001B1r 2               ; Arithmetic left shift
0001B1r 2               ;! Deprecated (Not shortened)
0001B1r 2               ; A >>= c
0001B1r 2               ; @PARAMS		c: default=1
0001B1r 2               ;*------------------------------------------------------------------------------
0001B1r 2               
0001B1r 2               .code									; ----- code -----
0001B1r 2               
0001B1r 2               .macro ashl c
0001B1r 2               		cmp #%1000_0000
0001B1r 2               		php								; Save carry
0001B1r 2               		.if (.blank(c))
0001B1r 2               			; ashl
0001B1r 2               			shl #2
0001B1r 2               		.elseif (.match(.left(1, {c}), #))
0001B1r 2               			; ashl #4
0001B1r 2               			shl #((.right(.tcount ({c})-1, {c})) + 1)
0001B1r 2               		.else
0001B1r 2               			.error "Arg \"c\" in macro ashl is wrong."
0001B1r 2               		.endif
0001B1r 2               		plp
0001B1r 2               		ror								; a /= 2, carry into bit7
0001B1r 2               .endmacro
0001B1r 2               
0001B1r 2               
0001B1r 2               ;*------------------------------------------------------------------------------
0001B1r 2               ; Arithmetic right shift
0001B1r 2               ; A >>= c
0001B1r 2               ; @PARAMS		c: default=1
0001B1r 2               ;
0001B1r 2               ; To ASR a memory location
0001B1r 2               ; (From http://wiki.nesdev.com/w/index.php/Synthetic_instructions#Arithmetic_shift_right)
0001B1r 2               ; 	lda addr		; Copy memory into A
0001B1r 2               ; 	asl				; Copy sign bit of A into carry (shorter than CMP)
0001B1r 2               ; 	ror addr
0001B1r 2               ;*------------------------------------------------------------------------------
0001B1r 2               
0001B1r 2               .code									; ----- code -----
0001B1r 2               
0001B1r 2               .macro ashr c
0001B1r 2               		.if (.blank(c))
0001B1r 2               			; ashr
0001B1r 2               			cmp #%1000_0000				; Bit7 into carry
0001B1r 2               			ror							; Shift carry into Bit7
0001B1r 2               		.elseif (.match(.left(1, {c}), #))
0001B1r 2               			; ashr #4
0001B1r 2               			.repeat (.right(.tcount ({c})-1, {c}))
0001B1r 2               				cmp #%1000_0000
0001B1r 2               				ror
0001B1r 2               			.endrepeat
0001B1r 2               		.else
0001B1r 2               			.error "Arg \"c\" in macro ashr is wrong."
0001B1r 2               		.endif
0001B1r 2               .endmacro
0001B1r 2               
0001B1r 2               
0001B1r 2               
0001B1r 2               .macro tfrPlt
0001B1r 2               		; Transfar pallete
0001B1r 2               		lda #>PLT_TABLE_ADDR
0001B1r 2               		sta PPU_ADDR
0001B1r 2               		lda #<PLT_TABLE_ADDR			; Addr lo = 0
0001B1r 2               		sta PPU_ADDR
0001B1r 2               		tax								; X = 0
0001B1r 2               :
0001B1r 2               		ldy #3
0001B1r 2               		lda #$22						; under ground -> #$0f
0001B1r 2               		sta PPU_DATA
0001B1r 2               :
0001B1r 2               		lda DEFAULT_PLT, x				; under ground -> UNDER_GROUND_PLT
0001B1r 2               		sta PPU_DATA
0001B1r 2               		inx
0001B1r 2               		dey
0001B1r 2               		bne :-
0001B1r 2               		cpx #$3*8
0001B1r 2               		bcc :--
0001B1r 2               
0001B1r 2               		lda #$23
0001B1r 2               		sta PPU_ADDR
0001B1r 2               		lda #$c0
0001B1r 2               		sta PPU_ADDR
0001B1r 2               		lda #$ff
0001B1r 2               		sta PPU_DATA
0001B1r 2               		sta PPU_DATA
0001B1r 2               		sta PPU_DATA
0001B1r 2               		sta PPU_DATA
0001B1r 2               		sta PPU_DATA
0001B1r 2               		sta PPU_DATA
0001B1r 2               		sta PPU_DATA
0001B1r 2               		sta PPU_DATA
0001B1r 2               .endmacro
0001B1r 2               
0001B1r 1               .include "./asm/subfunc.asm"			; インクルードが必要ないような，深い階層で使われる関数群
0001B1r 2               .scope Subfunc
0001B1r 2               
0001B1r 2               ;*------------------------------------------------------------------------------
0001B1r 2               ; Restore PPU setting
0001B1r 2               ; @PARAMS		None
0001B1r 2               ; @CLOBBERS		A
0001B1r 2               ; @RETURNS		None
0001B1r 2               ;*------------------------------------------------------------------------------
0001B1r 2               
0001B1r 2               .code									; ----- code -----
0001B1r 2               
0001B1r 2               .proc _restorePPUSet
0001B1r 2  A5 rr        		lda ppu_ctrl1_cpy
0001B3r 2  8D 00 20     		sta PPU_CTRL1
0001B6r 2  A5 rr        		lda ppu_ctrl2_cpy
0001B8r 2  8D 01 20     		sta PPU_CTRL2
0001BBr 2  60           		rts
0001BCr 2               		; ------------------------------
0001BCr 2               .endproc
0001BCr 2               
0001BCr 2               
0001BCr 2               
0001BCr 2               ;*------------------------------------------------------------------------------
0001BCr 2               ; Set scroll position & change disp
0001BCr 2               ; Use during NMI or executing raster scroll.
0001BCr 2               ; @PARAMS		None
0001BCr 2               ; @CLOBBERS		A
0001BCr 2               ; @RETURNS		None
0001BCr 2               ;*------------------------------------------------------------------------------
0001BCr 2               
0001BCr 2               .code									; ----- code -----
0001BCr 2               
0001BCr 2               .proc _setScroll
0001BCr 2               		; lda is_scroll_locked
0001BCr 2               		; bne @EXIT
0001BCr 2               
0001BCr 2  A5 rr        		lda scroll_x
0001BEr 2  8D 05 20     		sta PPU_SCROLL
0001C1r 2  A9 00        		lda #0
0001C3r 2  8D 05 20     		sta PPU_SCROLL
0001C6r 2               
0001C6r 2  A5 rr        		lda ppu_ctrl1_cpy
0001C8r 2  29 FE        		and #%1111_1110
0001CAr 2  05 rr        		ora main_disp
0001CCr 2  85 rr        		sta ppu_ctrl1_cpy
0001CEr 2  8D 00 20     		sta PPU_CTRL1
0001D1r 2               
0001D1r 2               @EXIT:
0001D1r 2  60           		rts
0001D2r 2               		; ------------------------------
0001D2r 2               .endproc
0001D2r 2               
0001D2r 2               
0001D2r 2               ;*------------------------------------------------------------------------------
0001D2r 2               ; Wait starting vblank
0001D2r 2               ; @PARAMS		None
0001D2r 2               ; @CLOBBERS		None
0001D2r 2               ; @RETURNS		None
0001D2r 2               ;*------------------------------------------------------------------------------
0001D2r 2               
0001D2r 2               .code									; ----- code -----
0001D2r 2               
0001D2r 2               .proc _waitVblank
0001D2r 2  2C 02 20     		bit $2002
0001D5r 2  10 FB        		bpl _waitVblank
0001D7r 2  60           		rts
0001D8r 2               		; ------------------------------
0001D8r 2               .endproc
0001D8r 2               
0001D8r 2               
0001D8r 2               ;*------------------------------------------------------------------------------
0001D8r 2               ; Disp status text
0001D8r 2               ; @PARAMS		None
0001D8r 2               ; @CLOBBERS		A X Y
0001D8r 2               ; @RETURNS		None
0001D8r 2               ;*------------------------------------------------------------------------------
0001D8r 2               
0001D8r 2               .code									; ----- code -----
0001D8r 2               
0001D8r 2               .proc _dispStatus
0001D8r 2  A6 rr        		ldx bg_buff_pointer
0001DAr 2  A0 1F        		ldy #(@TEXT_END - @TEXT)
0001DCr 2               @STORE_PPU_DATA_LOOP:
0001DCr 2  BD rr rr     		lda @TEXT, x
0001DFr 2  F0 07        		beq @END_STORE
0001E1r 2  9D 49 01     		sta bg_buff, x
0001E4r 2  E8           		inx
0001E5r 2  88           		dey
0001E6r 2  D0 F4        		bne @STORE_PPU_DATA_LOOP
0001E8r 2               @END_STORE:
0001E8r 2  86 rr        		stx bg_buff_pointer
0001EAr 2  60           		rts
0001EBr 2               		; ------------------------------
0001EBr 2               
0001EBr 2               .rodata									; ----- data -----
000000r 2               @TEXT:
000000r 2  FE 20 22     		.byte PPU_VERTICAL_MODE
000003r 2               		ADDR_BG_BE 2, 1, 0
000003r 2  53 43 4F 52  		.byte "SCORE XXXXXX  C:YY  TIME ZZZ"
000007r 2  45 20 58 58  
00000Br 2  58 58 58 58  
00001Fr 2               @TEXT_END:
00001Fr 2               
00001Fr 2               .endproc
00001Fr 2               
00001Fr 2               
00001Fr 2               ;*------------------------------------------------------------------------------
00001Fr 2               ; Sleep for one frame
00001Fr 2               ; @PARAMS		None
00001Fr 2               ; @CLOBBERS		A
00001Fr 2               ; @RETURNS		None (A = 1)
00001Fr 2               ;*------------------------------------------------------------------------------
00001Fr 2               
00001Fr 2               .proc _sleepOneFrame
00001Fr 2  A9 00        		lda #0
000021r 2  85 rr        		sta is_processing_main
000023r 2               :
000023r 2  A5 rr        		lda is_processing_main
000025r 2  F0 FC        		beq :-
000027r 2               
000027r 2  60           		rts
000028r 2               		; ------------------------------
000028r 2               .endproc
000028r 2               
000028r 2               
000028r 2               .endscope
000028r 2               
000028r 1               .include "./asm/draw_map.asm"
000028r 2               .include "draw_map_macro.asm"
000028r 3               .code									; ----- code -----
0001EBr 3               
0001EBr 3               ;*------------------------------------------------------------------------------
0001EBr 3               ; Transfar obj data (8*8) to BG map buff($04XX/$05XX)
0001EBr 3               ; @PARAMS		X: Block ID
0001EBr 3               ; @CLOBBERS		A X Y
0001EBr 3               ; @RETURNS		None (Y: 3)
0001EBr 3               ;*------------------------------------------------------------------------------
0001EBr 3               
0001EBr 3               .macro trfToBgMapBuf
0001EBr 3               		lda BROCK_ID_ARR+LO, x
0001EBr 3               		sta addr_tmp2+LO
0001EBr 3               		lda BROCK_ID_ARR+HI, x
0001EBr 3               		sta addr_tmp2+HI
0001EBr 3               
0001EBr 3               		ldx bg_map_buff_index
0001EBr 3               
0001EBr 3               		ldy #0
0001EBr 3               		lda (addr_tmp2), y
0001EBr 3               		sta bg_map_buff+0, x
0001EBr 3               
0001EBr 3               		iny
0001EBr 3               		lda (addr_tmp2), y
0001EBr 3               		sta bg_map_buff+($0d*2), x
0001EBr 3               
0001EBr 3               		inx
0001EBr 3               
0001EBr 3               		iny
0001EBr 3               		lda (addr_tmp2), y
0001EBr 3               		sta bg_map_buff+0, x
0001EBr 3               
0001EBr 3               		iny
0001EBr 3               		lda (addr_tmp2), y
0001EBr 3               		sta bg_map_buff+($0d*2), x
0001EBr 3               
0001EBr 3               		inx
0001EBr 3               
0001EBr 3               		stx bg_map_buff_index
0001EBr 3               .endmacro
0001EBr 3               
0001EBr 3               
0001EBr 3               ;*------------------------------------------------------------------------------
0001EBr 3               ; Increment row_counter
0001EBr 3               ; @PARAMS		None
0001EBr 3               ; @CLOBBERS		Y
0001EBr 3               ; @RETURNS		None (Y: row_counter)
0001EBr 3               ;*------------------------------------------------------------------------------
0001EBr 3               
0001EBr 3               .macro incRowCounter
0001EBr 3               		.local @NO_OVF_ROW_CNT
0001EBr 3               
0001EBr 3               		ldy DrawMap::row_counter
0001EBr 3               		iny
0001EBr 3               		cpy #$10
0001EBr 3               		bne @NO_OVF_ROW_CNT
0001EBr 3               
0001EBr 3               		ldy #0
0001EBr 3               		inc DrawMap::map_buff_num
0001EBr 3               @NO_OVF_ROW_CNT:
0001EBr 3               		sty DrawMap::row_counter
0001EBr 3               .endmacro
0001EBr 3               
0001EBr 3               
0001EBr 3               ;*------------------------------------------------------------------------------
0001EBr 3               ; index = 0xff
0001EBr 3               ; @PARAMS		None
0001EBr 3               ; @CLOBBERS		Y
0001EBr 3               ; @RETURNS		None (Y: 0xff)
0001EBr 3               ;*------------------------------------------------------------------------------
0001EBr 3               
0001EBr 3               .macro initIndex
0001EBr 3               		ldy #NEGATIVE 1
0001EBr 3               		sty DrawMap::index
0001EBr 3               .endmacro
0001EBr 3               
0001EBr 3               
0001EBr 3               ;*------------------------------------------------------------------------------
0001EBr 3               ; Fill blocks (store to bg buff)
0001EBr 3               ; @PARAMS		None
0001EBr 3               ; @CLOBBERS		A X Y
0001EBr 3               ; @RETURNS		None (A = X)
0001EBr 3               ;*------------------------------------------------------------------------------
0001EBr 3               
0001EBr 3               .macro fillBlocks
0001EBr 3               		.local @LOOP
0001EBr 3               
0001EBr 3               		lda addr_tmp2+LO
0001EBr 3               		and #BYT_LO
0001EBr 3               		sta addr_tmp2+LO
0001EBr 3               
0001EBr 3               		ldx #0
0001EBr 3               		ldy #0
0001EBr 3               @LOOP:
0001EBr 3               		lda fill_block_arr, y
0001EBr 3               		sta (addr_tmp2, x)
0001EBr 3               
0001EBr 3               		lda addr_tmp2+LO
0001EBr 3               		add #$10
0001EBr 3               		sta addr_tmp2+LO
0001EBr 3               
0001EBr 3               		iny
0001EBr 3               		cpy #$d
0001EBr 3               		bne @LOOP
0001EBr 3               .endmacro
0001EBr 3               
0001EBr 3               
0001EBr 3               ;*------------------------------------------------------------------------------
0001EBr 3               ; fill ground (store to fill buff)
0001EBr 3               ; @PARAMS		None
0001EBr 3               ; @CLOBBERS		A X Y
0001EBr 3               ; @RETURNS		None
0001EBr 3               ;*------------------------------------------------------------------------------
0001EBr 3               
0001EBr 3               .macro ramFillGround
0001EBr 3               		.local @FILL_SKY_LOOP1
0001EBr 3               		.local @FILL_SKY_LOOP1_END
0001EBr 3               		.local @FILL_GROUND_LOOP
0001EBr 3               		.local @FILL_GROUND_LOOP_END
0001EBr 3               		.local @FILL_SKY_LOOP2
0001EBr 3               		.local @END_FILL_GROUND
0001EBr 3               
0001EBr 3               		ldy #0
0001EBr 3               
0001EBr 3               		lda (DrawMap::map_addr), y
0001EBr 3               		and #BYT_LO
0001EBr 3               		sta DrawMap::fill_ground_end
0001EBr 3               
0001EBr 3               		lda (DrawMap::map_addr), y
0001EBr 3               		shr #4
0001EBr 3               		sta DrawMap::fill_ground_start
0001EBr 3               
0001EBr 3               
0001EBr 3               		lda #0
0001EBr 3               		tax
0001EBr 3               @FILL_SKY_LOOP1:
0001EBr 3               		cpx DrawMap::fill_ground_start
0001EBr 3               		bcs @FILL_SKY_LOOP1_END
0001EBr 3               		sta fill_block_arr, x
0001EBr 3               		inx
0001EBr 3               		cpx #$d
0001EBr 3               		bcc @FILL_SKY_LOOP1
0001EBr 3               		bcs @END_FILL_GROUND
0001EBr 3               @FILL_SKY_LOOP1_END:
0001EBr 3               
0001EBr 3               		lda DrawMap::fill_ground_block
0001EBr 3               @FILL_GROUND_LOOP:
0001EBr 3               		cpx DrawMap::fill_ground_end
0001EBr 3               		bcs @FILL_GROUND_LOOP_END
0001EBr 3               		sta fill_block_arr, x
0001EBr 3               		inx
0001EBr 3               		cpx #$d
0001EBr 3               		bcc @FILL_GROUND_LOOP
0001EBr 3               		bcs @END_FILL_GROUND
0001EBr 3               @FILL_GROUND_LOOP_END:
0001EBr 3               
0001EBr 3               		lda #0
0001EBr 3               @FILL_SKY_LOOP2:
0001EBr 3               		sta fill_block_arr, x
0001EBr 3               		inx
0001EBr 3               		cpx #$d
0001EBr 3               		bcc @FILL_SKY_LOOP2
0001EBr 3               
0001EBr 3               @END_FILL_GROUND:
0001EBr 3               .endmacro
0001EBr 3               
0001EBr 3               
0001EBr 3               ;*------------------------------------------------------------------------------
0001EBr 3               ; fill blocks (store to fill buff)
0001EBr 3               ; @PARAMS		None
0001EBr 3               ; @CLOBBERS		A X Y
0001EBr 3               ; @RETURNS		None
0001EBr 3               ;*------------------------------------------------------------------------------
0001EBr 3               
0001EBr 3               .macro ramFillBlocks
0001EBr 3               		.local @FILL_BLOCK_LOOP_UPPER
0001EBr 3               		.local @NO_BLOCK1
0001EBr 3               		.local @FILL_BLOCK_LOOP_LOWER
0001EBr 3               		.local @NO_BLOCK2
0001EBr 3               
0001EBr 3               		ldy #1
0001EBr 3               		lda (DrawMap::map_addr), y		; ブロック種類
0001EBr 3               		sta DrawMap::fill_block
0001EBr 3               
0001EBr 3               
0001EBr 3               		iny
0001EBr 3               		lda (DrawMap::map_addr), y		; 上位
0001EBr 3               		shl #3							; 上位3ビット削除
0001EBr 3               
0001EBr 3               		ldx #0
0001EBr 3               @FILL_BLOCK_LOOP_UPPER:
0001EBr 3               		shl #1
0001EBr 3               		bcc @NO_BLOCK1
0001EBr 3               
0001EBr 3               		pha
0001EBr 3               		lda DrawMap::fill_block
0001EBr 3               		sta fill_block_arr, x
0001EBr 3               		pla
0001EBr 3               
0001EBr 3               @NO_BLOCK1:
0001EBr 3               		inx
0001EBr 3               		cpx #$5
0001EBr 3               		bcc @FILL_BLOCK_LOOP_UPPER
0001EBr 3               
0001EBr 3               
0001EBr 3               		iny
0001EBr 3               		lda (DrawMap::map_addr), y		; 下位
0001EBr 3               @FILL_BLOCK_LOOP_LOWER:
0001EBr 3               		shl #1
0001EBr 3               		bcc @NO_BLOCK2
0001EBr 3               
0001EBr 3               		pha
0001EBr 3               		lda DrawMap::fill_block
0001EBr 3               		sta fill_block_arr, x
0001EBr 3               		pla
0001EBr 3               
0001EBr 3               @NO_BLOCK2:
0001EBr 3               		inx
0001EBr 3               		cpx #$d
0001EBr 3               		bcc @FILL_BLOCK_LOOP_LOWER
0001EBr 3               .endmacro
0001EBr 3               
0001EBr 3               
0001EBr 3               ;*------------------------------------------------------------------------------
0001EBr 3               ; Load next map
0001EBr 3               ; @PARAMS		None
0001EBr 3               ; @CLOBBERS		Y
0001EBr 3               ; @RETURNS		None
0001EBr 3               ;*------------------------------------------------------------------------------
0001EBr 3               
0001EBr 3               .macro loadNextMap
0001EBr 3               		inc DrawMap::map_arr_num
0001EBr 3               		ldy DrawMap::map_arr_num		; Y = ++map_arr_num
0001EBr 3               		jsr _setMapAddr
0001EBr 3               .endmacro
0001EBr 3               
0001EBr 3               
0001EBr 3               ;*------------------------------------------------------------------------------
0001EBr 3               ; set BG addr (PPU)
0001EBr 3               ; @PARAMS		None
0001EBr 3               ; @CLOBBERS		A
0001EBr 3               ; @RETURNS		None
0001EBr 3               ;*------------------------------------------------------------------------------
0001EBr 3               
0001EBr 3               .macro setPpuBgAddr
0001EBr 3               		lda #0
0001EBr 3               		sta tmp1						; Start using tmp1
0001EBr 3               
0001EBr 3               		lda addr_tmp1+LO
0001EBr 3               		add #$40
0001EBr 3               		shl #1
0001EBr 3               		rol tmp1
0001EBr 3               		sta ppu_bg_addr+LO
0001EBr 3               
0001EBr 3               		lda addr_tmp1+HI				; 4 or 5
0001EBr 3               		and #BIT0
0001EBr 3               		shl #2							; 0 or 4
0001EBr 3               		ora #$20						; $20 or $24
0001EBr 3               		ora tmp1						; End using tmp1
0001EBr 3               		sta ppu_bg_addr+HI
0001EBr 3               .endmacro
0001EBr 3               
0001EBr 2               
0001EBr 2               .scope DrawMap
0001EBr 2               
0001EBr 2               .ZeroPage
000023r 2  00           map_buff_num			: .byte 0
000024r 2  00 00        map_arr_addr			: .addr 0
000026r 2  00 00        map_addr				: .addr 0		; Map obj/position data (-> data addr: ROM)
000028r 2  00           isend_draw_stage		: .byte 0
000029r 2  00           row_counter				: .byte 0		; Every time this prg executed -> increment
00002Ar 2  00           index					: .byte 0		; index of map_addr
00002Br 2  00           cnt_map_next			: .byte 0		; data (read from map_addr) = SP code(go next map) -> increment this counter
00002Cr 2  00           map_arr_num				: .byte 0
00002Dr 2  00           fill_upper				: .byte 0
00002Er 2  00           fill_lower				: .byte 0
00002Fr 2  00           fill_ground_block		: .byte 0
000030r 2  00           fill_block				: .byte 0
000031r 2  00           fill_ground_end			: .byte 0
000032r 2  00           fill_ground_start		: .byte 0
000033r 2               
000033r 2               
000033r 2               ;*------------------------------------------------------------------------------
000033r 2               ; Update one row
000033r 2               ; @PARAMS		None
000033r 2               ; @CLOBBERS		A X Y tmp1 tmp2 addr_tmp1 addr_tmp2
000033r 2               ; @RETURNS		None
000033r 2               /* main label
000033r 2               	@START:
000033r 2               	@GET_POS_AND_OBJ_LOOP:
000033r 2               	@END_OF_MAP:						-> goto nextlabel (@LOAD_NEXT_MAP)
000033r 2               	@LOAD_NEXT_MAP:						-> goto @GET_POS_AND_OBJ_LOOP
000033r 2               	@END_OF_STAGE:						-> goto nextlabel (@PREPARE_BG_MAP_BUF)
000033r 2               	@PREPARE_BG_MAP_BUF:
000033r 2               	@STORE_BG_MAP_BUF_LOOP:
000033r 2               */
000033r 2               ;*------------------------------------------------------------------------------
000033r 2               
000033r 2               .code									; ----- code -----
0001EBr 2               
0001EBr 2               .proc _updateOneLine
0001EBr 2  A5 rr        		lda DrawMap::isend_draw_stage
0001EDr 2  F0 01        		beq @START
0001EFr 2  60           		rts
0001F0r 2               		; ------------------------------
0001F0r 2               
0001F0r 2               @START:
0001F0r 2  A9 01        		lda #1
0001F2r 2  85 rr        		sta is_updated_map
0001F4r 2               
0001F4r 2  A4 rr C8 C0  		incRowCounter
0001F8r 2  10 D0 04 A0  
0001FCr 2  00 E6 rr 84  
000201r 2               
000201r 2  A5 rr        		lda DrawMap::map_buff_num
000203r 2  29 01        		and #BIT0
000205r 2  09 04        		ora #4
000207r 2  85 rr        		sta addr_tmp2+HI
000209r 2               
000209r 2  A5 rr        		lda DrawMap::row_counter
00020Br 2  85 rr        		sta addr_tmp2+LO
00020Dr 2               
00020Dr 2  A5 rr 29 0F  		fillBlocks
000211r 2  85 rr A2 00  
000215r 2  A0 00 B9 3C  
000228r 2               
000228r 2  A4 rr        		ldy DrawMap::index
00022Ar 2               @GET_POS_AND_OBJ_LOOP:
00022Ar 2               		; ----------- get pos ----------
00022Ar 2  B1 rr        		lda (DrawMap::map_addr), y
00022Cr 2  85 rr        		sta tmp1
00022Er 2               
00022Er 2               		; Check Special Code
00022Er 2  C9 FE        		cmp #OBJMAP_NEXT
000230r 2  F0 38        		beq @LOAD_NEXT_MAP
000232r 2               
000232r 2  C9 FF        		cmp #OBJMAP_END
000234r 2  F0 25        		beq @END_OF_MAP
000236r 2               
000236r 2               		; Check if it can be updated
000236r 2  29 0F        		and #BYT_LO
000238r 2  C5 rr        		cmp DrawMap::row_counter
00023Ar 2  D0 1A        		bne @GET_POS_AND_OBJ_LOOP_EXIT
00023Cr 2               
00023Cr 2  A5 rr        		lda DrawMap::map_buff_num
00023Er 2  C5 rr        		cmp DrawMap::cnt_map_next		; Count OBJMAP_NEXT (is not reset until the stage changes)
000240r 2  D0 14        		bne @GET_POS_AND_OBJ_LOOP_EXIT
000242r 2               
000242r 2               		; -- Set addr of bg map buff ---
000242r 2  29 01        		and #BIT0
000244r 2  09 04        		ora #4
000246r 2  85 rr        		sta addr_tmp1+HI
000248r 2               
000248r 2               
000248r 2  A5 rr        		lda tmp1						; End using tmp1
00024Ar 2  85 rr        		sta addr_tmp1+LO
00024Cr 2               
00024Cr 2               		; ----------- get chr ----------
00024Cr 2  C8           		iny
00024Dr 2  A2 00        		ldx #0
00024Fr 2  B1 rr        		lda (DrawMap::map_addr), y
000251r 2  81 rr        		sta (addr_tmp1, x)
000253r 2               
000253r 2  C8           		iny
000254r 2  D0 D4        		bne @GET_POS_AND_OBJ_LOOP		; Jmp
000256r 2               		; ------------------------------
000256r 2               
000256r 2               @GET_POS_AND_OBJ_LOOP_EXIT:
000256r 2  84 rr        		sty DrawMap::index
000258r 2  4C rr rr     		jmp @PREPARE_BG_MAP_BUF
00025Br 2               		; ------------------------------
00025Br 2               
00025Br 2               
00025Br 2               		; End of map data (Not end of stage)
00025Br 2               @END_OF_MAP:
00025Br 2  E6 rr A4 rr  		loadNextMap
00025Fr 2  20 rr rr     
000262r 2               
000262r 2  A5 rr        		lda DrawMap::map_addr+HI
000264r 2  C9 FF        		cmp #ENDCODE					; A = Addr Hi
000266r 2  F0 08        		beq @END_OF_STAGE
000268r 2               
000268r 2  A0 03        		ldy #3							; この後inyされてy(index) = 4に
00026Ar 2               
00026Ar 2               @LOAD_NEXT_MAP:
00026Ar 2  E6 rr        		inc DrawMap::cnt_map_next
00026Cr 2  C8           		iny
00026Dr 2  4C rr rr     		jmp @GET_POS_AND_OBJ_LOOP
000270r 2               		; ------------------------------
000270r 2               
000270r 2               @END_OF_STAGE:
000270r 2  A0 00        		ldy #0
000272r 2  84 rr        		sty DrawMap::index
000274r 2  C8           		iny								; Y = 1
000275r 2  84 rr        		sty DrawMap::isend_draw_stage
000277r 2               
000277r 2               @PREPARE_BG_MAP_BUF:
000277r 2  A5 rr        		lda DrawMap::row_counter
000279r 2  85 rr        		sta addr_tmp1+LO				; PosY = 0
00027Br 2               
00027Br 2  A5 rr        		lda DrawMap::map_buff_num
00027Dr 2  29 01        		and #BIT0
00027Fr 2  09 04        		ora #4
000281r 2  85 rr        		sta addr_tmp1+HI
000283r 2               
000283r 2  A9 00 85 rr  		setPpuBgAddr
000287r 2  A5 rr 18 69  
00028Br 2  40 0A 26 rr  
00029Dr 2               
00029Dr 2               		; Store plt addr(ppu)
00029Dr 2  A5 rr        		lda addr_tmp1+LO				; posX
00029Fr 2  4A           		shr #1
0002A0r 2  18 69 C0     		add #$c0
0002A3r 2  85 rr        		sta plt_addr+LO
0002A5r 2               
0002A5r 2  A5 rr        		lda addr_tmp1+HI
0002A7r 2  29 01        		and #1
0002A9r 2  0A 0A        		shl #2
0002ABr 2  18 69 23     		add #$23
0002AEr 2  85 rr        		sta plt_addr+HI
0002B0r 2               
0002B0r 2  A0 00        		ldy #0
0002B2r 2  84 rr        		sty bg_map_buff_index
0002B4r 2               
0002B4r 2               @STORE_BG_MAP_BUF_LOOP:					; for (y = 0; y < $0d; y++)
0002B4r 2  98           		tya
0002B5r 2  0A 0A 0A 0A  		shl #4
0002B9r 2  A8           		tay
0002BAr 2  B1 rr        		lda (addr_tmp1), y
0002BCr 2               
0002BCr 2               		; prepare plt data -------------
0002BCr 2  84 rr        		sty tmp2						; (save counter) += $10
0002BEr 2  A4 rr        		ldy tmp1						; (save counter) += 1
0002C0r 2  48           		pha								; push
0002C1r 2  29 30        		and #BIT5|BIT4
0002C3r 2  AA           		tax								; X: plt num(bit4-5) : tmp (Start using)
0002C4r 2  A5 rr        		lda DrawMap::row_counter
0002C6r 2  29 01        		and #BIT0
0002C8r 2  85 rr        		sta tmp3
0002CAr 2  98           		tya
0002CBr 2  29 01        		and #BIT0
0002CDr 2  0A           		shl #1
0002CEr 2  05 rr        		ora tmp3
0002D0r 2  85 rr        		sta tmp3
0002D2r 2               
0002D2r 2               		; y /= 2 (Use @PLT0) -> MEMO: 短縮可能
0002D2r 2  98           		tya
0002D3r 2  4A           		shr #1
0002D4r 2  A8           		tay
0002D5r 2               
0002D5r 2  8A           		txa								; End using X (plt num)
0002D6r 2  A6 rr        		ldx tmp3
0002D8r 2               		/*
0002D8r 2               		PLT_DATA = BLOCK3|BLOCK2|BLOCK1|BLOCK0
0002D8r 2               		-------------------------------
0002D8r 2               		| BLOCK0(>>4) | BLOCK1(>>2) |
0002D8r 2               		| BLOCK2(0)   | BLOCK3(<<2) |
0002D8r 2               		-------------------------------
0002D8r 2               		*/
0002D8r 2  F0 09        		beq @BLOCK0
0002DAr 2  CA           		dex
0002DBr 2  F0 0D        		beq @BLOCK1
0002DDr 2  CA           		dex
0002DEr 2  F0 11        		beq @BLOCK2
0002E0r 2  CA           		dex
0002E1r 2  F0 0C        		beq @BLOCK3
0002E3r 2               @BLOCK0:
0002E3r 2  4A 4A 4A 4A  		shr #4
0002E7r 2  4C rr rr     		jmp @STORE_TO_PLT_BUFF
0002EAr 2               		; ------------------------------
0002EAr 2               @BLOCK1:
0002EAr 2  4A 4A        		shr #2
0002ECr 2  4C rr rr     		jmp @ADD_LEFT_BLOCK_PLT
0002EFr 2               		; ------------------------------
0002EFr 2               @BLOCK3:
0002EFr 2  0A 0A        		shl #2
0002F1r 2               @BLOCK2:
0002F1r 2               @ADD_LEFT_BLOCK_PLT:
0002F1r 2  19 34 01     		ora bg_plt_buff, y
0002F4r 2               @STORE_TO_PLT_BUFF:
0002F4r 2  99 34 01     		sta bg_plt_buff, y
0002F7r 2               
0002F7r 2  68           		pla								; pull
0002F8r 2  A4 rr        		ldy tmp2
0002FAr 2               
0002FAr 2  29 3F        		and #BIT5|BIT4|BIT3|BIT2|BIT1|BIT0
0002FCr 2  0A           		shl #1
0002FDr 2               
0002FDr 2  AA           		tax
0002FEr 2  BD rr rr 85  		trfToBgMapBuf
000302r 2  rr BD rr rr  
000306r 2  85 rr A6 rr  
000327r 2               
000327r 2  A4 rr        		ldy tmp1
000329r 2  C8           		iny
00032Ar 2  84 rr        		sty tmp1
00032Cr 2  C0 0D        		cpy #$0d
00032Er 2  90 84        		bcc @STORE_BG_MAP_BUF_LOOP
000330r 2               
000330r 2  60           		rts
000331r 2               		;-------------------------------
000331r 2               .endproc
000331r 2               
000331r 2               ;*------------------------------------------------------------------------------
000331r 2               ; Set addr of stages
000331r 2               ; @PARAMS		Y: stage number
000331r 2               ; @CLOBBERS		A Y
000331r 2               ; @RETURNS		None (A = addr Hi)
000331r 2               ;*------------------------------------------------------------------------------
000331r 2               
000331r 2               .code									; ----- code -----
000331r 2               
000331r 2               .proc _setStageAddr
000331r 2  98           		tya
000332r 2  0A           		shl #1
000333r 2  A8           		tay
000334r 2               
000334r 2  B9 rr rr     		lda STAGE_ARR+LO, y
000337r 2  85 rr        		sta DrawMap::map_arr_addr+LO
000339r 2  B9 rr rr     		lda STAGE_ARR+HI, y
00033Cr 2  85 rr        		sta DrawMap::map_arr_addr+HI
00033Er 2               
00033Er 2  60           		rts
00033Fr 2               		; ------------------------------
00033Fr 2               .endproc
00033Fr 2               
00033Fr 2               
00033Fr 2               ;*------------------------------------------------------------------------------
00033Fr 2               ; Set addr of maps
00033Fr 2               ; @PARAMS		Y: map index
00033Fr 2               ; @CLOBBERS		A Y
00033Fr 2               ; @RETURNS		None
00033Fr 2               ;*------------------------------------------------------------------------------
00033Fr 2               
00033Fr 2               .code									; ----- code -----
00033Fr 2               
00033Fr 2               .proc _setMapAddr
00033Fr 2  98           		tya
000340r 2  0A           		shl #1
000341r 2  A8           		tay
000342r 2  48           		pha								; push y
000343r 2               
000343r 2  B1 rr        		lda (DrawMap::map_arr_addr), y
000345r 2  85 rr        		sta DrawMap::map_addr+LO
000347r 2  C8           		iny
000348r 2  B1 rr        		lda (DrawMap::map_arr_addr), y
00034Ar 2  85 rr        		sta DrawMap::map_addr+HI
00034Cr 2               
00034Cr 2               		; ffコードをこの関数の返値にして，この関数の外でマップ終了を判定しているが
00034Cr 2               		; その前に@NO_EXIT以下の処理を行ってしまい，バグるため，ここで抜ける
00034Cr 2               		; 直接@END_OF_STAGEにジャンプしてもOKなはずだが（マップ終了判定でジャンプするラベル）
00034Cr 2               		; procを使っているため今は無理
00034Cr 2  C9 FF        		cmp #ENDCODE
00034Er 2  D0 05        		bne @NO_EXIT
000350r 2  68           		pla
000351r 2  A8           		tay
000352r 2  A9 FF        		lda #ENDCODE
000354r 2  60           		rts
000355r 2               		; ------------------------------
000355r 2               
000355r 2               @NO_EXIT:
000355r 2  A0 00 B1 rr  		ramFillGround
000359r 2  29 0F 85 rr  
00035Dr 2  B1 rr 4A 4A  
000390r 2  A0 01 B1 rr  		ramFillBlocks
000394r 2  85 rr C8 B1  
000398r 2  rr 0A 0A 0A  
0003BFr 2               
0003BFr 2  A0 04        		ldy #4								; マクロ後inyでもy = 4
0003C1r 2  84 rr        		sty DrawMap::index
0003C3r 2               
0003C3r 2  68           		pla
0003C4r 2  A8           		tay
0003C5r 2               
0003C5r 2  60           		rts
0003C6r 2               		; ------------------------------
0003C6r 2               .endproc
0003C6r 2               
0003C6r 2               
0003C6r 2               ;*------------------------------------------------------------------------------
0003C6r 2               ; Change stage
0003C6r 2               ; @PARAMS		Y: Stage number
0003C6r 2               ; @CLOBBERS		A Y
0003C6r 2               ; @RETURNS		None
0003C6r 2               ;*------------------------------------------------------------------------------
0003C6r 2               
0003C6r 2               .proc _changeStage
0003C6r 2  A9 00        		lda #0
0003C8r 2  85 rr        		sta is_updated_map
0003CAr 2  20 rr rr     		jsr Subfunc::_sleepOneFrame
0003CDr 2               
0003CDr 2               		; Change bg color (black)
0003CDr 2  A9 3F        		lda #$3f
0003CFr 2  8D 06 20     		sta PPU_ADDR
0003D2r 2  A9 00        		lda #$00
0003D4r 2  8D 06 20     		sta PPU_ADDR
0003D7r 2  A9 0F        		lda #$0f
0003D9r 2  8D 07 20     		sta PPU_DATA
0003DCr 2  A9 3F        		lda #$3f
0003DEr 2  8D 06 20     		sta PPU_ADDR
0003E1r 2  A9 00        		lda #$00
0003E3r 2  8D 06 20     		sta PPU_ADDR
0003E6r 2               
0003E6r 2  A9 FF        		lda #$ff
0003E8r 2  85 rr        		sta DrawMap::row_counter
0003EAr 2               
0003EAr 2  A9 00        		lda #0
0003ECr 2  85 rr        		sta DrawMap::index
0003EEr 2  85 rr        		sta main_disp
0003F0r 2  85 rr        		sta DrawMap::cnt_map_next		; count ff
0003F2r 2  85 rr        		sta DrawMap::map_buff_num
0003F4r 2  85 rr        		sta DrawMap::isend_draw_stage
0003F6r 2  85 rr        		sta DrawMap::map_arr_num
0003F8r 2  85 rr        		sta scroll_x
0003FAr 2  85 rr        		sta ppu_ctrl2_cpy
0003FCr 2  8D 01 20     		sta PPU_CTRL2
0003FFr 2               
0003FFr 2  A9 47        		lda #'G'
000401r 2  85 rr        		sta DrawMap::fill_ground_block
000403r 2               
000403r 2  20 rr rr     		jsr DrawMap::_setStageAddr
000406r 2  A0 00        		ldy #0
000408r 2  20 rr rr     		jsr DrawMap::_setMapAddr
00040Br 2               
00040Br 2  A9 18        		lda #$18
00040Dr 2               @DISP_LOOP:
00040Dr 2  48           		pha
00040Er 2  A9 01        		lda #1
000410r 2  85 rr        		sta is_updated_map
000412r 2  20 rr rr     		jsr DrawMap::_updateOneLine
000415r 2  20 rr rr     		jsr Subfunc::_sleepOneFrame
000418r 2  68           		pla
000419r 2  38 E9 01     		sub #1
00041Cr 2  D0 EF        		bne @DISP_LOOP
00041Er 2               
00041Er 2               		; Restore bg color
00041Er 2  A9 3F        		lda #$3f
000420r 2  8D 06 20     		sta PPU_ADDR
000423r 2  A9 00        		lda #$00
000425r 2  8D 06 20     		sta PPU_ADDR
000428r 2  A9 22        		lda #$22
00042Ar 2  8D 07 20     		sta PPU_DATA
00042Dr 2  A9 3F        		lda #$3f
00042Fr 2  8D 06 20     		sta PPU_ADDR
000432r 2  A9 00        		lda #$00
000434r 2  8D 06 20     		sta PPU_ADDR
000437r 2               
000437r 2  20 rr rr     		jsr Subfunc::_setScroll
00043Ar 2               
00043Ar 2  A9 00        		lda #0
00043Cr 2  85 rr        		sta is_updated_map
00043Er 2  20 rr rr     		jsr Subfunc::_sleepOneFrame
000441r 2               
000441r 2  A9 1E        		lda #%00011110
000443r 2  85 rr        		sta ppu_ctrl2_cpy
000445r 2  20 rr rr     		jsr Subfunc::_restorePPUSet		; Display ON
000448r 2               
000448r 2  60           		rts
000449r 2               		; ------------------------------
000449r 2               
000449r 2               .endproc
000449r 2               
000449r 2               
000449r 2               .endscope
000449r 2               
000449r 1               .include "./asm/sprite.asm"
000449r 2               /***************** メモ *****************
000449r 2               
000449r 2               キャラクター情報を，キャラクターごとにまとめる
000449r 2               
000449r 2               例：）クリボー
000449r 2               アニメーションの数：２
000449r 2               タイルインデックス
000449r 2               タイル属性
000449r 2               初期速度
000449r 2               スプライト：
000449r 2               	アニメーション
000449r 2               	ジャンプ（空中）
000449r 2               	やられた時
000449r 2               	→ ファイヤー，スターでやられた時には
000449r 2               	やられた時のスプライト＋向きを反転
000449r 2               
000449r 2               
000449r 2               
000449r 2               今後：
000449r 2               あたり判定大きさ
000449r 2               速度変化（ハンマーブロスなどのアニメーション）: この時地形判定不要？
000449r 2               踏めるか，ファイヤー耐性は？
000449r 2               
000449r 2               
000449r 2               
000449r 2               ***************************************/
000449r 2               
000449r 2               
000449r 2               
000449r 2               CHR_ATTR:
000449r 2  00           		.byte %0000_0000
00044Ar 2  00           		.byte %0000_0000
00044Br 2  00           		.byte %0000_0000
00044Cr 2  40           		.byte %0100_0000
00044Dr 2               
00044Dr 2               CHR_ID:
00044Dr 2  3A 37 4F 4F  		.byte $3a, $37, $4f, $4f
000451r 2               
000451r 2               
000451r 2               
000451r 2               .scope Sprite
000451r 2               
000451r 2               .ZeroPage
000033r 2               
000033r 2  00           move_dx		: .byte 0
000034r 2  00           move_dy		: .byte 0
000035r 2               
000035r 2               
000035r 2               .code									; ----- code -----
000451r 2               
000451r 2               ;*------------------------------------------------------------------------------
000451r 2               ; Move sprite
000451r 2               ; @PARAMS		X: sprite id
000451r 2               ; @CLOBBERS		A Y
000451r 2               ; @RETURNS		None
000451r 2               ;*------------------------------------------------------------------------------
000451r 2               
000451r 2               .proc _moveSprite
000451r 2  BD rr rr     	lda spr_posX_arr, x
000454r 2  18 65 rr     	add move_dx
000457r 2  C9 F0        	cmp #$f0
000459r 2  90 08        	bcc :+
00045Br 2  A4 rr        	ldy move_dx
00045Dr 2  C0 80        	cpy #$80
00045Fr 2  90 02        	bcc :+
000461r 2               	; posX < 0 && move_dx < 0
000461r 2  A9 00        	lda #0
000463r 2               :
000463r 2               
000463r 2               	; スクロールロック時の処理
000463r 2  A4 rr        	ldy is_scroll_locked
000465r 2  D0 04        	bne @STORE_POSX
000467r 2               
000467r 2  C9 70        	cmp #PLAYER_MAX_POSX
000469r 2  B0 0E        	bcs @MOVE_SCROLL
00046Br 2               
00046Br 2               @STORE_POSX:
00046Br 2  C9 F2        	cmp #($100-(PLAYER_WIDTH+PLAYER_PADDING))
00046Dr 2  90 04        	bcc @STOP_MOVE
00046Fr 2  F0 02        	beq @STOP_MOVE
000471r 2               
000471r 2  A9 F2        	lda #($100-(PLAYER_WIDTH+PLAYER_PADDING))
000473r 2               @STOP_MOVE:
000473r 2  9D rr rr     	sta spr_posX_arr, x
000476r 2  4C rr rr     	jmp @MOVE_Y
000479r 2               	; ------------------------------
000479r 2               
000479r 2               @MOVE_SCROLL:
000479r 2  38 E9 70     	sub #PLAYER_MAX_POSX
00047Cr 2  85 rr        	sta scroll_amount
00047Er 2               
00047Er 2  A9 70        	lda #PLAYER_MAX_POSX
000480r 2  9D rr rr     	sta spr_posX_arr, x
000483r 2               
000483r 2               @MOVE_Y:
000483r 2  BD rr rr     	lda spr_posY_arr, x
000486r 2  18 65 rr     	add move_dy
000489r 2  9D rr rr     	sta spr_posY_arr, x
00048Cr 2               
00048Cr 2  60           	rts
00048Dr 2               	; ------------------------------
00048Dr 2               .endproc
00048Dr 2               
00048Dr 2               
00048Dr 2               .proc _tfrToChrBuff
00048Dr 2               	; posy, sprid, attr, posx
00048Dr 2               	; ARG: X = sprite id (MAX 11)
00048Dr 2               	; ARG: Y = BUFF index
00048Dr 2               	/*
00048Dr 2               	MEMO:
00048Dr 2               	sprite
00048Dr 2               		posX, Y
00048Dr 2               		sprID
00048Dr 2               		velocity (HI: X, LO: Y)
00048Dr 2               		(player: acceleration)
00048Dr 2               	*/
00048Dr 2               
00048Dr 2  98           	tya
00048Er 2  0A 0A        	shl #2
000490r 2  A8           	tay
000491r 2               
000491r 2  BD rr rr     	lda spr_posY_arr, x
000494r 2  85 rr        	sta tmp1							; posY
000496r 2  BD rr rr     	lda spr_posX_arr, x
000499r 2  85 rr        	sta tmp2							; posX
00049Br 2               
00049Br 2               	; Upper left
00049Br 2  A5 rr        	lda tmp1
00049Dr 2  99 00 03     	sta CHR_BUFF+$0, y
0004A0r 2               
0004A0r 2  BD rr rr     	lda CHR_ID, x
0004A3r 2  99 01 03     	sta CHR_BUFF+$1, y
0004A6r 2               
0004A6r 2  BD rr rr     	lda CHR_ATTR, x
0004A9r 2  99 02 03     	sta CHR_BUFF+$2, y
0004ACr 2               
0004ACr 2  A5 rr        	lda tmp2
0004AEr 2  99 03 03     	sta CHR_BUFF+$3, y
0004B1r 2               
0004B1r 2               	; Upper right
0004B1r 2  E8           	inx
0004B2r 2  A5 rr        	lda tmp1
0004B4r 2  99 04 03     	sta CHR_BUFF+$4, y
0004B7r 2               
0004B7r 2  BD rr rr     	lda CHR_ID, x
0004BAr 2  99 05 03     	sta CHR_BUFF+$5, y
0004BDr 2               
0004BDr 2  BD rr rr     	lda CHR_ATTR, x
0004C0r 2  99 06 03     	sta CHR_BUFF+$6, y
0004C3r 2               
0004C3r 2  A5 rr        	lda tmp2
0004C5r 2  18 69 08     	add #8
0004C8r 2  99 07 03     	sta CHR_BUFF+$7, y
0004CBr 2               
0004CBr 2               	; Lower left
0004CBr 2  E8           	inx
0004CCr 2  A5 rr        	lda tmp1
0004CEr 2  18 69 08     	add #8
0004D1r 2  99 08 03     	sta CHR_BUFF+$8, y
0004D4r 2               
0004D4r 2  BD rr rr     	lda CHR_ID, x
0004D7r 2  99 09 03     	sta CHR_BUFF+$9, y
0004DAr 2               
0004DAr 2  BD rr rr     	lda CHR_ATTR, x
0004DDr 2  99 0A 03     	sta CHR_BUFF+$a, y
0004E0r 2               
0004E0r 2  A5 rr        	lda tmp2
0004E2r 2  99 0B 03     	sta CHR_BUFF+$b, y
0004E5r 2               
0004E5r 2               
0004E5r 2               	; Lower right
0004E5r 2  E8           	inx
0004E6r 2  A5 rr        	lda tmp1
0004E8r 2  18 69 08     	add #8
0004EBr 2  99 0C 03     	sta CHR_BUFF+$c, y
0004EEr 2               
0004EEr 2  BD rr rr     	lda CHR_ID, x
0004F1r 2  99 0D 03     	sta CHR_BUFF+$d, y
0004F4r 2               
0004F4r 2  BD rr rr     	lda CHR_ATTR, x
0004F7r 2  99 0E 03     	sta CHR_BUFF+$e, y
0004FAr 2               
0004FAr 2  A5 rr        	lda tmp2
0004FCr 2  18 69 08     	add #8
0004FFr 2  99 0F 03     	sta CHR_BUFF+$f, y
000502r 2               
000502r 2  60           	rts
000503r 2               	; ------------------------------
000503r 2               .endproc
000503r 2               
000503r 2               .endscope
000503r 2               
000503r 1               .include "./asm/nmi.asm"
000503r 2               ;*------------------------------------------------------------------------------
000503r 2               ; bg_buffを読み取り，指定アドレスに書き込んでカウンタをインクリメント
000503r 2               ; Read PPU update data & store to PPU
000503r 2               ; @PARAMS		ADDR: Forwarding address
000503r 2               ; @CLOBBERS		A X
000503r 2               ; @RETURNS		None
000503r 2               ;*------------------------------------------------------------------------------
000503r 2               
000503r 2               .code									; ----- code -----
000503r 2               
000503r 2               .macro tfrDataToPPU ADDR
000503r 2               	lda bg_buff, x
000503r 2               	sta ADDR
000503r 2               	inx
000503r 2               .endmacro
000503r 2               
000503r 2               ; memo
000503r 2               ; ----- PPU buff data structure -----
000503r 2               ; r: Direction
000503r 2               ; 	Bit0 is a flag, others are 1.
000503r 2               ; 	-> 0b1111_111[0/1]
000503r 2               ; 	-> 0xFE（Horizontal）/0xFF（Vertical）
000503r 2               ; a: Addr
000503r 2               ; d: Data
000503r 2               ; r [a a] [d d d ... d] r [a a] [d d ... d]
000503r 2               
000503r 2               
000503r 2               ;*------------------------------------------------------------------------------
000503r 2               ; NMI (Interrupt)
000503r 2               ; @CLOBBERS	 X Y (When end main process.)
000503r 2               ; To shorten the clock, put the buffer data on the stack
000503r 2               ; 	(Shorten clock by buff data length)
000503r 2               ; 	pla -> 3 clc
000503r 2               ; 	lda ZP/ABSORUTE, x -> 4 clc
000503r 2               ;*------------------------------------------------------------------------------
000503r 2               
000503r 2               .code									; ----- code -----
000503r 2               
000503r 2               .proc _nmi
000503r 2  48           		pha
000504r 2  E6 rr        		inc nmi_cnt
000506r 2  A5 rr        		lda is_processing_main
000508r 2  F0 05        		beq @NMI_MAIN
00050Ar 2  68           		pla
00050Br 2  20 rr rr     		jsr Subfunc::_setScroll
00050Er 2  40           		rti	; --------------------------
00050Fr 2               
00050Fr 2               @NMI_MAIN:
00050Fr 2  A5 rr        		lda is_updated_map
000511r 2  F0 5E        		beq @PRINT
000513r 2  A2 00        		ldx #0
000515r 2  86 rr        		stx tmp1
000517r 2               @PLT_STORE_LOOP:
000517r 2  A5 rr        		lda plt_addr+1
000519r 2  8D 06 20     		sta PPU_ADDR
00051Cr 2               
00051Cr 2  A5 rr        		lda plt_addr+0
00051Er 2  18 69 08     		add #8
000521r 2  18 65 rr     		add tmp1
000524r 2  8D 06 20     		sta PPU_ADDR
000527r 2               
000527r 2  BD 34 01     		lda bg_plt_buff, x
00052Ar 2  8D 07 20     		sta PPU_DATA
00052Dr 2               
00052Dr 2  A5 rr        		lda tmp1
00052Fr 2  18 69 08     		add #8
000532r 2  85 rr        		sta tmp1
000534r 2               
000534r 2  E8           		inx
000535r 2  E0 07        		cpx #7
000537r 2  90 DE        		bcc @PLT_STORE_LOOP
000539r 2               
000539r 2  A5 rr        		lda ppu_ctrl1_cpy
00053Br 2  09 04        		ora #%0000_0100					; Vertical mode
00053Dr 2  85 rr        		sta ppu_ctrl1_cpy
00053Fr 2  8D 00 20     		sta PPU_CTRL1					; Not use restorePPUSet()
000542r 2               
000542r 2               		; line 1
000542r 2  A5 rr        		lda ppu_bg_addr+HI
000544r 2  8D 06 20     		sta PPU_ADDR
000547r 2  A5 rr        		lda ppu_bg_addr+LO
000549r 2  8D 06 20     		sta PPU_ADDR
00054Cr 2               
00054Cr 2  A2 00        		ldx #0
00054Er 2               @STORE_MAP_LOOP:
00054Er 2  BD 00 01     		lda bg_map_buff, x
000551r 2  8D 07 20     		sta PPU_DATA
000554r 2  E8           		inx
000555r 2  E0 1A        		cpx #$1a
000557r 2  D0 F5        		bne @STORE_MAP_LOOP
000559r 2               
000559r 2               		; line 2
000559r 2  A5 rr        		lda ppu_bg_addr+HI
00055Br 2  8D 06 20     		sta PPU_ADDR
00055Er 2  A6 rr        		ldx ppu_bg_addr+LO
000560r 2  E8           		inx
000561r 2  8E 06 20     		stx PPU_ADDR
000564r 2               
000564r 2  A2 00        		ldx #0
000566r 2               @STORE_MAP_LOOP2:
000566r 2  BD 1A 01     		lda bg_map_buff+$1a, x
000569r 2  8D 07 20     		sta PPU_DATA
00056Cr 2  E8           		inx
00056Dr 2  E0 1A        		cpx #$1a
00056Fr 2  D0 F5        		bne @STORE_MAP_LOOP2
000571r 2               
000571r 2               @PRINT:
000571r 2  A9 00        		lda #0
000573r 2  C5 rr        		cmp bg_buff_pointer
000575r 2  F0 35        		beq @STORE_CHR
000577r 2  AA           		tax
000578r 2  BD 49 01     		lda bg_buff, x
00057Br 2               @SET_MODE:
00057Br 2  29 01        		and #%00000001					; Get flag
00057Dr 2  0A 0A        		shl #2							; Move flag to Bit2
00057Fr 2  85 rr        		sta tmp1						; Start using tmp1
000581r 2  A5 rr        		lda ppu_ctrl1_cpy
000583r 2  29 FB        		and #%11111011					; Mask direction flag
000585r 2  05 rr        		ora tmp1						; End using tmp1
000587r 2  85 rr        		sta ppu_ctrl1_cpy
000589r 2  8D 00 20     		sta PPU_CTRL1					; Not use restorePPUSet()
00058Cr 2               @SET_ADDR:
00058Cr 2  E8           		inx								; Not do inx when go to @EXIT
00058Dr 2  BD 49 01     		lda bg_buff, x
000590r 2  8D 06 20     		sta PPU_ADDR
000593r 2  E8           		inx
000594r 2  BD 49 01     		lda bg_buff, x
000597r 2  8D 06 20     		sta PPU_ADDR
00059Ar 2  E8           		inx
00059Br 2               @STORE_DATA:
00059Br 2  BD 49 01     		lda bg_buff, x
00059Er 2  A8           		tay
00059Fr 2  C9 FE        		cmp #$fe
0005A1r 2  B0 D8        		bcs @SET_MODE					; no inx
0005A3r 2  98           		tya
0005A4r 2  8D 07 20     		sta PPU_DATA
0005A7r 2  E8           		inx
0005A8r 2  E4 rr        		cpx bg_buff_pointer
0005AAr 2  D0 EF        		bne @STORE_DATA
0005ACr 2               
0005ACr 2               		; @SET_MODE + @SET_ADDR = 51 cycle
0005ACr 2               		; @STORE_DATA (return @STORE_DATA) = 24 cycle
0005ACr 2               		; @STORE_DATA (return @SET_MODE) = 13 cycle
0005ACr 2               
0005ACr 2               		; str1 = "A  B"
0005ACr 2               		; 	=> 51 + space_len * 24 cycle
0005ACr 2               		; 	=> mode(1) + addr(2) + data(2 + space_len) = (5 + space_len) bytes
0005ACr 2               		; 	|  len  || 1  | 2  |  3  |  4  |
0005ACr 2               		; 	| cycle || 75 | 99 | 123 | 147 |
0005ACr 2               		;	| bytes || 6  | 7  |  8  |  9  |
0005ACr 2               		; str2 = 'A', str3 = 'B'
0005ACr 2               		; 	=> (51 + 13) * 2 = 64 * 2 = 128 cycle
0005ACr 2               		; 	=> (mode(1) + addr(2) + data(1)) * 2 = 8 bytes
0005ACr 2               		; space length:
0005ACr 2               		; 	1: 75 cycle,	6 bytes (str1)
0005ACr 2               		; 	2: 99 cycle,	7 bytes
0005ACr 2               		; 	3: 123 cycle,	8 bytes
0005ACr 2               		; 	4~: 128 cycle,	8 bytes (str2)
0005ACr 2               @STORE_CHR:
0005ACr 2  A9 00        		lda #0
0005AEr 2  8D 03 20     		sta OAM_ADDR
0005B1r 2  A9 03        		lda #>CHR_BUFF
0005B3r 2  8D 14 40     		sta OAM_DMA
0005B6r 2               
0005B6r 2               @EXIT:
0005B6r 2  A9 01        		lda #1
0005B8r 2  85 rr        		sta is_processing_main
0005BAr 2  4A           		shr #1							; A = 0
0005BBr 2  85 rr        		sta bg_buff_pointer
0005BDr 2  85 rr        		sta is_updated_map
0005BFr 2  E6 rr        		inc frm_cnt
0005C1r 2  68           		pla
0005C2r 2  40           		rti	; --------------------------
0005C3r 2               .endproc
0005C3r 2               
0005C3r 1               .include "./asm/init.asm"
0005C3r 2               .code									; ----- code -----
0005C3r 2               
0005C3r 2               .macro init
0005C3r 2               		sei								; Ban IRQ
0005C3r 2               		cld								; Ban BCD
0005C3r 2               		ldx #$40
0005C3r 2               		stx JOYPAD2
0005C3r 2               		ldx #$ff
0005C3r 2               		txs
0005C3r 2               		inx								; X = 0
0005C3r 2               		stx PPU_CTRL1
0005C3r 2               		stx PPU_CTRL2
0005C3r 2               		stx SOUND_DP_1					; Ban IRQ of APU DMC (bit7)
0005C3r 2               		stx SOUND_CHANNEL
0005C3r 2               
0005C3r 2               		/*
0005C3r 2               		A & $2002 -> set Z(zero flag)
0005C3r 2               		$2002 bit7(vblank) -> N(negative), bit6(sprite 0 hit) -> V(overflow)
0005C3r 2               		Reset vblank & sprite 0 hit flag
0005C3r 2               		(The state of this flag after reset is undefined.)
0005C3r 2               		*/
0005C3r 2               		bit $2002
0005C3r 2               		jsr Subfunc::_waitVblank		; 1st time
0005C3r 2               
0005C3r 2               		txa								; A = 0
0005C3r 2               @CLR_MEM:
0005C3r 2               		sta $00, x
0005C3r 2               		sta $0100, x
0005C3r 2               		sta $0200, x
0005C3r 2               		sta $0400, x
0005C3r 2               		sta $0500, x
0005C3r 2               		sta $0600, x
0005C3r 2               		sta $0700, x
0005C3r 2               		inx
0005C3r 2               		bne @CLR_MEM
0005C3r 2               
0005C3r 2               		lda #$ff
0005C3r 2               @CLR_CHR_MEM:
0005C3r 2               		sta $0300, x
0005C3r 2               		inx
0005C3r 2               		bne @CLR_CHR_MEM
0005C3r 2               
0005C3r 2               		; Zero sprite
0005C3r 2               		lda #$10-2-1
0005C3r 2               		sta CHR_BUFF+0
0005C3r 2               		lda #$ff
0005C3r 2               		sta CHR_BUFF+1
0005C3r 2               		lda #%0000_0010
0005C3r 2               		sta CHR_BUFF+2
0005C3r 2               		lda #$0f
0005C3r 2               		sta CHR_BUFF+3
0005C3r 2               
0005C3r 2               		jsr Subfunc::_waitVblank		; 2nd time
0005C3r 2               
0005C3r 2               		; ------- PPU stabilizes -------
0005C3r 2               
0005C3r 2               		lda #%00010000					; SPR = $0000, BG = $1000
0005C3r 2               		sta ppu_ctrl1_cpy
0005C3r 2               		jsr Subfunc::_restorePPUSet
0005C3r 2               
0005C3r 2               		; Clear VRAM
0005C3r 2               		lda #$20
0005C3r 2               		sta PPU_ADDR
0005C3r 2               		lda #$00
0005C3r 2               		sta PPU_ADDR
0005C3r 2               
0005C3r 2               		ldy #8
0005C3r 2               		tax
0005C3r 2               @CLR_VRAM:
0005C3r 2               		sta PPU_DATA
0005C3r 2               		inx
0005C3r 2               		bne @CLR_VRAM
0005C3r 2               		dey
0005C3r 2               		bne @CLR_VRAM
0005C3r 2               
0005C3r 2               
0005C3r 2               		jsr Subfunc::_waitVblank
0005C3r 2               
0005C3r 2               
0005C3r 2               		tfrPlt
0005C3r 2               
0005C3r 2               		; Change bg color (black)
0005C3r 2               		lda #$3f
0005C3r 2               		sta PPU_ADDR
0005C3r 2               		lda #$00
0005C3r 2               		sta PPU_ADDR
0005C3r 2               		lda #$0f
0005C3r 2               		sta PPU_DATA
0005C3r 2               		; 画面OFF中は最後に指定したアドレスの色が背景になる（指定なし→3f01の色が使用される）
0005C3r 2               		lda #$3f
0005C3r 2               		sta PPU_ADDR
0005C3r 2               		lda #$00
0005C3r 2               		sta PPU_ADDR
0005C3r 2               
0005C3r 2               	lda #'G'
0005C3r 2               	sta DrawMap::fill_ground_block
0005C3r 2               
0005C3r 2               	lda #0
0005C3r 2               	sta is_scroll_locked
0005C3r 2               
0005C3r 2               		jsr Subfunc::_dispStatus
0005C3r 2               
0005C3r 2               	; sprite
0005C3r 2               	lda #$20
0005C3r 2               	sta spr_posX_arr+0
0005C3r 2               	lda #$c0
0005C3r 2               	sta spr_posY_arr+0
0005C3r 2               	ldx #0
0005C3r 2               	ldy #1
0005C3r 2               	jsr Sprite::_tfrToChrBuff
0005C3r 2               
0005C3r 2               		lda #0
0005C3r 2               		sta is_updated_map
0005C3r 2               
0005C3r 2               		lda ppu_ctrl1_cpy
0005C3r 2               		ora #%10000000
0005C3r 2               		sta ppu_ctrl1_cpy
0005C3r 2               		jsr Subfunc::_restorePPUSet		; NMI ON
0005C3r 2               
0005C3r 2               		jsr Subfunc::_sleepOneFrame		; draw disp status
0005C3r 2               
0005C3r 2               		ldy #0
0005C3r 2               		jsr DrawMap::_changeStage
0005C3r 2               
0005C3r 2               .endmacro
0005C3r 2               
0005C3r 1               .include "./asm/func.asm"				; いくつかのファイルのインクルードが必要な関数群
0005C3r 2               .scope Func
0005C3r 2               
0005C3r 2               ;*------------------------------------------------------------------------------
0005C3r 2               ; Scroll
0005C3r 2               ; @PARAMS		A: amount of scroll
0005C3r 2               ; @CLOBBERS		A, tmp1, tmp2
0005C3r 2               ; @RETURNS		None
0005C3r 2               ;*------------------------------------------------------------------------------
0005C3r 2               
0005C3r 2               .proc _scroll
0005C3r 2  A5 rr        		lda is_scroll_locked
0005C5r 2  D0 28        		bne @SKIP_UPDATE_LINE
0005C7r 2               
0005C7r 2  A5 rr        		lda scroll_x
0005C9r 2  29 F0        		and #BYT_HI
0005CBr 2  85 rr        		sta tmp1
0005CDr 2               
0005CDr 2  A5 rr        		lda scroll_x
0005CFr 2  18 65 rr     		add scroll_amount
0005D2r 2  85 rr        		sta scroll_x
0005D4r 2  29 F0        		and #BYT_HI						; Not clobber carry
0005D6r 2  85 rr        		sta tmp2
0005D8r 2               
0005D8r 2  90 0C        		bcc @SKIP_CHANGE_DISP
0005DAr 2  A5 rr        		lda main_disp
0005DCr 2  49 01        		eor #%0000_0001
0005DEr 2  85 rr        		sta main_disp
0005E0r 2               
0005E0r 2  A5 rr        		lda ppu_ctrl1_cpy
0005E2r 2  49 01        		eor #%0000_0001
0005E4r 2  85 rr        		sta ppu_ctrl1_cpy
0005E6r 2               
0005E6r 2               @SKIP_CHANGE_DISP:
0005E6r 2  A5 rr        		lda tmp1
0005E8r 2  C5 rr        		cmp tmp2
0005EAr 2  F0 03        		beq @SKIP_UPDATE_LINE
0005ECr 2  20 rr rr     		jsr DrawMap::_updateOneLine
0005EFr 2               @SKIP_UPDATE_LINE:
0005EFr 2               
0005EFr 2  60           		rts
0005F0r 2               		; ------------------------------
0005F0r 2               .endproc
0005F0r 2               
0005F0r 2               
0005F0r 2               .endscope
0005F0r 2               
0005F0r 1               .include "main.asm"
0005F0r 2               ;*------------------------------------------------------------------------------
0005F0r 2               ; MAIN routine
0005F0r 2               ;*------------------------------------------------------------------------------
0005F0r 2               
0005F0r 2               .code									; ----- code -----
0005F0r 2               
0005F0r 2               .proc _main
0005F0r 2               		; --- Wait Finishing Vblank ----
0005F0r 2  A5 rr        		lda is_processing_main
0005F2r 2  F0 FC        		beq _main
0005F4r 2               
0005F4r 2  A5 rr        		lda ppu_ctrl1_cpy
0005F6r 2  29 FE        		and #%1111_1110
0005F8r 2  8D 00 20     		sta PPU_CTRL1					; 後でrestoreできるようにRAMにはコピーを取らない
0005FBr 2               
0005FBr 2  A9 00        		lda #0
0005FDr 2  8D 05 20     		sta PPU_SCROLL
000600r 2  8D 05 20     		sta PPU_SCROLL
000603r 2               
000603r 2               @WAIT_FINISH_VBLANK:
000603r 2  2C 02 20     		bit PPU_STATUS
000606r 2  70 FB        		bvs @WAIT_FINISH_VBLANK
000608r 2               
000608r 2               		; ------ Before Zero Bomb ------
000608r 2               
000608r 2  20 rr rr     		jsr Joypad::_getJoyData
00060Br 2               
00060Br 2               		; --------- Zero Bomb ----------
00060Br 2               
00060Br 2               @WAIT_ZERO_BOMB:
00060Br 2  2C 02 20     		bit PPU_STATUS
00060Er 2  50 FB        		bvc @WAIT_ZERO_BOMB
000610r 2               
000610r 2  A0 14        		ldy #20							; 10ぐらいまで乱れる，余裕もって20に
000612r 2               :
000612r 2  88           		dey
000613r 2  D0 FD        		bne :-
000615r 2               
000615r 2  20 rr rr     		jsr Subfunc::_setScroll
000618r 2               
000618r 2               		; ------ After Zero Bomb -------
000618r 2               
000618r 2               	; chr move
000618r 2  A2 00        	ldx #0								; spr id
00061Ar 2  20 rr rr     	jsr Sprite::_moveSprite
00061Dr 2  A2 00        	ldx #0								; spr id
00061Fr 2  A0 01        	ldy #1
000621r 2  20 rr rr     	jsr Sprite::_tfrToChrBuff
000624r 2               
000624r 2  20 rr rr     	jsr Func::_scroll
000627r 2               
000627r 2               		; A
000627r 2  A5 rr        		lda Joypad::joy1_pushstart
000629r 2  29 80        		and #Joypad::BTN_A
00062Br 2  F0 03        		beq @NO_PUSHED_BTN_A
00062Dr 2               
00062Dr 2  20 rr rr     		jsr DrawMap::_updateOneLine
000630r 2               @NO_PUSHED_BTN_A:
000630r 2               		; B
000630r 2  A5 rr        		lda Joypad::joy1
000632r 2  29 40        		and #Joypad::BTN_B
000634r 2  F0 05        		beq @NO_PUSHED_BTN_B
000636r 2               
000636r 2  A0 01        		ldy #1
000638r 2  20 rr rr     		jsr DrawMap::_changeStage
00063Br 2               @NO_PUSHED_BTN_B:
00063Br 2               		; U
00063Br 2  A5 rr        		lda Joypad::joy1_pushstart
00063Dr 2  29 08        		and #Joypad::BTN_U
00063Fr 2  F0 02        		beq @NO_PUSHED_BTN_U
000641r 2               
000641r 2  E6 rr        		inc Sprite::move_dx
000643r 2               @NO_PUSHED_BTN_U:
000643r 2               		; D
000643r 2  A5 rr        		lda Joypad::joy1_pushstart
000645r 2  29 04        		and #Joypad::BTN_D
000647r 2  F0 02        		beq @NO_PUSHED_BTN_D
000649r 2               
000649r 2  C6 rr        		dec Sprite::move_dx
00064Br 2               @NO_PUSHED_BTN_D:
00064Br 2               		; L
00064Br 2  A5 rr        		lda Joypad::joy1_pushstart
00064Dr 2  29 02        		and #Joypad::BTN_L
00064Fr 2  F0 06        		beq @NO_PUSHED_BTN_L
000651r 2               
000651r 2  A5 rr        		lda is_scroll_locked
000653r 2  49 01        		eor #1
000655r 2  85 rr        		sta is_scroll_locked
000657r 2               @NO_PUSHED_BTN_L:
000657r 2               
000657r 2               
000657r 2               		; ----- End main -----
000657r 2  A9 00        		lda #0
000659r 2  85 rr        		sta is_processing_main
00065Br 2  4C rr rr     		jmp _main
00065Er 2               		; ------------------------------
00065Er 2               .endproc
00065Er 2               
00065Er 1               
00065Er 1               
00065Er 1               .segment "DMA_MEM"
000000r 1  xx xx xx xx  		.tag SPR_TBL
000004r 1  xx xx xx xx  
000008r 1  xx xx xx xx  
000100r 1               
000100r 1               
000100r 1               .code									; ----- code -----
00065Er 1               .segment "STARTUP"
000000r 1               
000000r 1               .proc _reset
000000r 1  78 D8 A2 40  		init
000004r 1  8E 17 40 A2  
000008r 1  FF 9A E8 8E  
000102r 1               
000102r 1  A9 01        		lda #1
000104r 1  85 rr        		sta is_processing_main
000106r 1               
000106r 1  4C rr rr     		jmp _main
000109r 1               		; ------------------------------
000109r 1               .endproc
000109r 1               
000109r 1               
000109r 1               .proc _irq
000109r 1  40           		rti
00010Ar 1               .endproc
00010Ar 1               
00010Ar 1               
00010Ar 1               .segment "CHARS"
000000r 1  03 0F 1F 1F  		.incbin "spr_bg.chr"
000004r 1  1C 24 26 66  
000008r 1  00 00 00 00  
002000r 1               
002000r 1               
002000r 1               .segment "VECINFO"
000000r 1  rr rr        		.addr _nmi
000002r 1  rr rr        		.addr _reset
000004r 1  rr rr        		.addr _irq
000004r 1               
