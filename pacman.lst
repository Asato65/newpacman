ca65 V2.19 - Git de30a57
Main file   : pacman.asm
Current file: pacman.asm

000000r 1               .setcpu "6502"
000000r 1               .feature c_comments						; Allow C language type comments (/* comments */)
000000r 1               .feature underline_in_numbers			; Allow notation %1010_0010
000000r 1               .feature string_escapes					; Allow \t, \n, \" and so on
000000r 1               .linecont +								; Allow line breaks in the middle of lines if you put a backslash at the end of the line
000000r 1               
000000r 1               
000000r 1               .segment "HEADER"
000000r 1  4E 45 53 1A  		.byte "NES", $1a
000004r 1  02           		.byte $02						; Program bank
000005r 1  01           		.byte $01						; Charactor bank
000006r 1  01           		.byte $01						; Vartical mirror
000007r 1  00           		.byte $00
000008r 1  00 00 00 00  		.byte $00, $00, $00, $00
00000Cr 1  00 00 00 00  		.byte $00, $00, $00, $00
000010r 1               
000010r 1               
000010r 1               .rodata									; ----- data -----
000000r 1               
000000r 1               .include "./inc/const.inc"
000000r 2               PPU_VERTICAL_MODE						= %11111110
000000r 2               PPU_HORIZONTAL_MODE						= %11111111
000000r 2               
000000r 2               ENDCODE									= $ff
000000r 2               
000000r 2               OBJMAP_NEXT								= $fe
000000r 2               OBJMAP_END								= $ff
000000r 2               
000000r 2               PPU_CTRL1_STD							= %10010000			; |NMION|PPU=MASTER|SPR8*8|BG$1000|SPR$0000|VRAM+1|SCRN$2000(2)|
000000r 2               PPU_CTRL2_STD							= %00011110			; |R|G|B|DISP-SPR|DISP-BG|SHOW-L8SPR|SHOW-L8BG|MODE=COLOR|
000000r 2               
000000r 2               BIT0									= %00000001
000000r 2               BIT1									= %00000010
000000r 2               BIT2									= %00000100
000000r 2               BIT3									= %00001000
000000r 2               BIT4									= %00010000
000000r 2               BIT5									= %00100000
000000r 2               BIT6									= %01000000
000000r 2               BIT7									= %10000000
000000r 2               
000000r 2               BYT_HI									= %11110000
000000r 2               BYT_LO									= %00001111
000000r 2               
000000r 2               LO										= 0
000000r 2               HI										= 1
000000r 2               
000000r 2               INIT									= 0
000000r 2               
000000r 2               
000000r 1               .include "./inc/const_addr.inc"
000000r 2               ZP					= $00
000000r 2               ; Unused $0200
000000r 2               BG_MAP_BUFF			= $0100				; size = $d ($10 - $3) * $4 = $40 - $c = $34
000000r 2               BG_PLT_BUFF			= $0134				; size = 8
000000r 2               FILL_BLOCKS			= $013c				; size = 13 ($d)
000000r 2               BG_BUFF				= $0149
000000r 2               SPR_BUFF			= $0300
000000r 2               MAP1				= $0400
000000r 2               MAP2				= $0500
000000r 2               USER_MEM			= $0700
000000r 2               
000000r 2               PLT_TABLE_ADDR		= $3f00
000000r 2               
000000r 2               PPU_CTRL1			= $2000
000000r 2               PPU_CTRL2			= $2001
000000r 2               PPU_STATUS			= $2002
000000r 2               OAM_ADDR			= $2003
000000r 2               OAM_DATA			= $2004
000000r 2               PPU_SCROLL			= $2005
000000r 2               PPU_ADDR			= $2006
000000r 2               PPU_DATA			= $2007
000000r 2               OAM_DMA				= $4014
000000r 2               
000000r 2               
000000r 2               SOUND_SQ1_1			= $4000				; Duty(2)|time counter|音響変化|ボリューム(4)
000000r 2               SOUND_SQ1_2			= $4001				; 周波数変化|変化速度(3)|変化方向|変化範囲(3)
000000r 2               SOUND_SQ1_3			= $4002				; 周波数下位
000000r 2               SOUND_SQ1_4			= $4003				; 再生時間(5)|周波数上位(3)
000000r 2               SOUND_SQ2_1			= $4004
000000r 2               SOUND_SQ2_2			= $4005
000000r 2               SOUND_SQ2_3			= $4006
000000r 2               SOUND_SQ2_4			= $4007
000000r 2               SOUND_TR_1			= $4008				; 再生時間カウンタ|カウンタを使用した長さ(7)
000000r 2               SOUND_TR_2			= $400A				; 周波数下位
000000r 2               SOUND_TR_3			= $400B				; 再生時間(5)|周波数上位(3)
000000r 2               SOUND_NS_1			= $400C				; 未使用(2)|再生時間カウンタ|音響固定|ボリューム(3)
000000r 2               SOUND_NS_2			= $400E				; 乱数タイプ(高周波)|未使用(3)|サンプルレート(4)
000000r 2               SOUND_NS_3			= $400F				; 再生時間(5)|未使用(3)
000000r 2               SOUND_DP_1			= $4010
000000r 2               SOUND_DP_2			= $4011
000000r 2               SOUND_DP_3			= $4012
000000r 2               SOUND_DP_4			= $4013
000000r 2               SOUND_CHANNEL		= $4015				; 未使用(3)|DPCM|ノイズ|三角波|CH2|CH1
000000r 2               
000000r 2               
000000r 2               JOYPAD1				= $4016
000000r 2               JOYPAD2				= $4017
000000r 2               
000000r 1               .include "./inc/var_addr.inc"
000000r 2               ; ZeroPage
000000r 2               .segment "ZEROPAGE"
000000r 2  00           tmp1					: .byte 0
000001r 2  00           tmp2					: .byte 0
000002r 2  00           tmp3					: .byte 0
000003r 2  00           tmp4					: .byte 0
000004r 2  00           tmp5					: .byte 0
000005r 2  00           tmp6					: .byte 0
000006r 2               
000006r 2  00           bg_buff_pointer			: .byte 0
000007r 2  00 00        addr_tmp1				: .addr 0
000009r 2  00 00        addr_tmp2				: .addr 0
00000Br 2               
00000Br 2  00           bg_map_buff_index		: .byte 0		; BG（マップ）専用バッファ
00000Cr 2               
00000Cr 2  00 00        ppu_bg_addr				: .addr 0
00000Er 2               
00000Er 2  00           tmp_rgstA				: .byte 0
00000Fr 2  00           tmp_rgstX				: .byte 0
000010r 2  00           tmp_rgstY				: .byte 0
000011r 2               
000011r 2               ; These are not used often, but are used in NMI
000011r 2  00           ppu_ctrl1_cpy			: .byte 0		; |NMI-ON|PPU=MASTER|SPR8*8|BG$1000|SPR$0000|VRAM+1|SCREEN$2000(2)|
000012r 2  00           ppu_ctrl2_cpy			: .byte 0		; |R|G|B|DISP-SPR|DISP-BG|SHOW-L8-SPR|SHOW-L8-BG|MODE=COLOR|
000013r 2               
000013r 2  00           scroll_x				: .byte 0
000014r 2  00           scroll_y				: .byte 0
000015r 2               
000015r 2  00           nmi_cnt					: .byte 0
000016r 2  00           frm_cnt					: .byte 0
000017r 2  00           is_processing_main		: .byte 0
000018r 2               
000018r 2  00 00        plt_addr				: .addr 0
00001Ar 2               
00001Ar 2               
00001Ar 2               .segment "USER_MEM"
000000r 2               
000000r 2               
000000r 2               .code
000000r 2               
000000r 1               .include "./inc/defmacro.inc"
000000r 2               ;*------------------------------------------------------------------------------
000000r 2               ; Calcurate BG address
000000r 2               ; @PARAM ptx: X coordinate
000000r 2               ; @PARAM pty: Y coordinate
000000r 2               ; @PARAM scn: Screen number
000000r 2               ;*------------------------------------------------------------------------------
000000r 2               
000000r 2               .define ADDR_BG (ptx, pty, scn)			$2000 + (ptx) + ((pty) * $20) + ((scn) * $400)
000000r 2               .define ADDR_BG_BE (ptx, pty, scn)		GET_BE ADDR_BG (ptx), (pty), (scn)
000000r 2               
000000r 2               ;*------------------------------------------------------------------------------
000000r 2               ; Calcurate SPR address
000000r 2               ; @PARAM spr_num: Sprite number (0~63)
000000r 2               ; @PARAM member:
000000r 2               ; 	pty: PosiTion Y
000000r 2               ; 	num: Tile(8*8) number
000000r 2               ; 	att: Attribute (VertFlip|HorizonFlip|Prio|Unused(3)|PltNum(2))
000000r 2               ; 	ptx: PosiTion X
000000r 2               ;*------------------------------------------------------------------------------
000000r 2               
000000r 2               .define ADDR_SPR(spr_num, member)		SPR_BUFF + ((spr_num)*4) + SPR_STRUCT::member
000000r 2               
000000r 2               
000000r 2               ;*------------------------------------------------------------------------------
000000r 2               ; Get data in big endian
000000r 2               ; dbyt = Define BYTe?
000000r 2               ; Define word data with the hi & lo bytes swapped
000000r 2               ; ($1234=$12,$34)
000000r 2               ;*------------------------------------------------------------------------------
000000r 2               
000000r 2               .define GET_BE(data)					.dbyt data
000000r 2               
000000r 2               
000000r 2               ;*------------------------------------------------------------------------------
000000r 2               ; Get obj position
000000r 2               ; @PARAM	posX, posY
000000r 2               ; @RETURN	$YX
000000r 2               ;*------------------------------------------------------------------------------
000000r 2               
000000r 2               .define GET_OBJ_POS(posX, posY)		($c - (posY)) * $10 + (posX)
000000r 2               
000000r 2               
000000r 2               ;*------------------------------------------------------------------------------
000000r 2               ; Return negative number
000000r 2               ;*------------------------------------------------------------------------------
000000r 2               
000000r 2               .define NEGATIVE(val)	256 - (val)
000000r 2               
000000r 1               .include "./inc/palette.inc"
000000r 2               DEFAULT_PLT:
000000r 2               		; BG
000000r 2  36 17 0F     		.byte $36, $17, $0f
000003r 2  27 17 0F     		.byte $27, $17, $0f				; 27 -> 07/17/27
000006r 2  29 1A 0F     		.byte $29, $1a, $0f
000009r 2  30 21 0F     		.byte $30, $21, $0f
00000Cr 2               		; SPR
00000Cr 2  16 27 18     		.byte $16, $27, $18
00000Fr 2  1A 30 27     		.byte $1a, $30, $27
000012r 2  16 30 27     		.byte $16, $30, $27
000015r 2  0F 36 17     		.byte $0f, $36, $17
000018r 2               
000018r 2               
000018r 2               UNDER_GROUND_PLT:
000018r 2               		; BG
000018r 2  3C 1C 0F     		.byte $3c, $1c, $0f
00001Br 2  27 17 1C     		.byte $27, $17, $1c
00001Er 2  29 1A 09     		.byte $29, $1a, $09
000021r 2  30 21 1C     		.byte $30, $21, $1c
000024r 2               		; SPR
000024r 2  16 27 18     		.byte $16, $27, $18
000027r 2  1C 30 17     		.byte $1c, $30, $17				; black disp: $30 -> $36
00002Ar 2  16 30 27     		.byte $16, $30, $27
00002Dr 2  0C 3C 1C     		.byte $0c, $3c, $1c
000030r 2               
000030r 2               
000030r 1               .include "./inc/struct.inc"
000030r 2               .struct	SPR_STRUCT
000030r 2               		pty		.byte					; PosiTion Y
000030r 2               		num		.byte					; Tile(8*8) number
000030r 2               		att		.byte					; Attribute (VertFlip|HorizonFlip|Prio|Unused(3)|PltNum(2))
000030r 2               		ptx		.byte					; PosiTion X
000030r 2               .endstruct
000030r 2               
000030r 2               
000030r 2               .struct	SPR_TBL
000030r 2               		spr		.tag SPR_STRUCT 64
000030r 2               .endstruct
000030r 2               
000030r 1               .include "./inc/map_data.inc"
000030r 2               ; MAP_DATA[stage][map_num][index]
000030r 2               
000030r 2               STAGE_ARR:
000030r 2  rr rr        	.addr MAP_ARR_11
000032r 2               
000032r 2               MAP_ARR_11:
000032r 2  rr rr        	.addr MAP_11_1
000034r 2  rr rr        	.addr MAP_11_2
000036r 2  FF FF        	.addr $ffff
000038r 2               
000038r 2               MAP_11_1:
000038r 2  0E           	.byte $0e							; GROUND b, c(not d)
000039r 2  42           	.byte 'B'
00003Ar 2  00 00        	.byte %00000000, %00000000			; BLOCK 13
00003Cr 2  C0 47        	.byte (GET_OBJ_POS $0, $0), 'G'
00003Er 2  81 5E        	.byte (GET_OBJ_POS $1, $4), '^'
000040r 2  C1 51        	.byte (GET_OBJ_POS $1, $0), 'Q'
000042r 2  95 51        	.byte (GET_OBJ_POS $5, $3), 'Q'
000044r 2  FE           	.byte OBJMAP_NEXT
000045r 2  70 51        	.byte (GET_OBJ_POS $0, $5), 'Q'
000047r 2  71 51        	.byte (GET_OBJ_POS $1, $5), 'Q'
000049r 2  72 51        	.byte (GET_OBJ_POS $2, $5), 'Q'
00004Br 2  73 51        	.byte (GET_OBJ_POS $3, $5), 'Q'
00004Dr 2  74 51        	.byte (GET_OBJ_POS $4, $5), 'Q'
00004Fr 2  75 51        	.byte (GET_OBJ_POS $5, $5), 'Q'
000051r 2  76 51        	.byte (GET_OBJ_POS $6, $5), 'Q'
000053r 2  77 51        	.byte (GET_OBJ_POS $7, $5), 'Q'
000055r 2  78 51        	.byte (GET_OBJ_POS $8, $5), 'Q'
000057r 2  79 51        	.byte (GET_OBJ_POS $9, $5), 'Q'
000059r 2  7A 51        	.byte (GET_OBJ_POS $a, $5), 'Q'
00005Br 2  7B 51        	.byte (GET_OBJ_POS $b, $5), 'Q'
00005Dr 2  7C 51        	.byte (GET_OBJ_POS $c, $5), 'Q'
00005Fr 2  7D 51        	.byte (GET_OBJ_POS $d, $5), 'Q'
000061r 2  7E 51        	.byte (GET_OBJ_POS $e, $5), 'Q'
000063r 2  7F 51        	.byte (GET_OBJ_POS $f, $5), 'Q'
000065r 2  FF           	.byte OBJMAP_END
000066r 2               
000066r 2               MAP_11_2:
000066r 2  DD           	.byte $dd							; GROUND b, c(not d)
000067r 2  47           	.byte 'G'
000068r 2  00 80        	.byte %00000000, %10000000			; BLOCK 13
00006Ar 2  50 51        	.byte (GET_OBJ_POS $0, $7), 'Q'
00006Cr 2  60 51        	.byte (GET_OBJ_POS $0, $6), 'Q'
00006Er 2  70 51        	.byte (GET_OBJ_POS $0, $5), 'Q'
000070r 2  51 51        	.byte (GET_OBJ_POS $1, $7), 'Q'
000072r 2  61 51        	.byte (GET_OBJ_POS $1, $6), 'Q'
000074r 2  71 51        	.byte (GET_OBJ_POS $1, $5), 'Q'
000076r 2  72 51        	.byte (GET_OBJ_POS $2, $5), 'Q'
000078r 2  73 51        	.byte (GET_OBJ_POS $3, $5), 'Q'
00007Ar 2  FF           	.byte OBJMAP_END
00007Br 2               
00007Br 2               
00007Br 2               
00007Br 2               BROCK_ID_ARR:
00007Br 2               	; 40 = %0100
00007Br 2  rr rr        	.addr OBJ_SKY						; @ (or 0)
00007Dr 2  00 00        	.addr $0000							; A
00007Fr 2  rr rr        	.addr OBJ_BROCK						; B
000081r 2  00 00        	.addr $0000							; C
000083r 2  00 00        	.addr $0000							; D
000085r 2  00 00        	.addr $0000							; E
000087r 2  00 00        	.addr $0000							; F
000089r 2  rr rr        	.addr OBJ_GROUND					; G
00008Br 2  00 00        	.addr $0000							; H
00008Dr 2  00 00        	.addr $0000							; I
00008Fr 2  00 00        	.addr $0000							; J
000091r 2  00 00        	.addr $0000							; K
000093r 2  00 00        	.addr $0000							; L
000095r 2  00 00        	.addr $0000							; M
000097r 2  00 00        	.addr $0000							; N
000099r 2  00 00        	.addr $0000							; O
00009Br 2               	; 50 = %0101
00009Br 2  00 00        	.addr $0000							; P
00009Dr 2  rr rr        	.addr OBJ_QBROCK					; Q
00009Fr 2  00 00        	.addr $0000							; R
0000A1r 2  00 00        	.addr $0000							; S
0000A3r 2  00 00        	.addr $0000							; T
0000A5r 2  00 00        	.addr $0000							; U
0000A7r 2  00 00        	.addr $0000							; V
0000A9r 2  00 00        	.addr $0000							; W
0000ABr 2  00 00        	.addr $0000							; X
0000ADr 2  00 00        	.addr $0000							; Y
0000AFr 2  00 00        	.addr $0000							; Z
0000B1r 2  00 00        	.addr $0000							; [
0000B3r 2  00 00        	.addr $0000							; \
0000B5r 2  00 00        	.addr $0000							; ]
0000B7r 2  rr rr        	.addr OBJ_COIN						; ^
0000B9r 2  00 00        	.addr $0000							; _
0000BBr 2               	; 60 = %0110
0000BBr 2  00 00        	.addr $0000							; `
0000BDr 2  00 00        	.addr $0000							; a
0000BFr 2  00 00        	.addr $0000							; b
0000C1r 2  00 00        	.addr $0000							; c
0000C3r 2  00 00        	.addr $0000							; d
0000C5r 2  00 00        	.addr $0000							; e
0000C7r 2  00 00        	.addr $0000							; f
0000C9r 2  00 00        	.addr $0000							; g
0000CBr 2  00 00        	.addr $0000							; h
0000CDr 2  00 00        	.addr $0000							; i
0000CFr 2  00 00        	.addr $0000							; j
0000D1r 2  00 00        	.addr $0000							; k
0000D3r 2  00 00        	.addr $0000							; l
0000D5r 2  00 00        	.addr $0000							; m
0000D7r 2  00 00        	.addr $0000							; n
0000D9r 2  00 00        	.addr $0000							; o
0000DBr 2               	; 70 = %0111
0000DBr 2  00 00        	.addr $0000							; p
0000DDr 2  00 00        	.addr $0000							; q
0000DFr 2  00 00        	.addr $0000							; r
0000E1r 2  00 00        	.addr $0000							; s
0000E3r 2  00 00        	.addr $0000							; t
0000E5r 2  00 00        	.addr $0000							; u
0000E7r 2  00 00        	.addr $0000							; v
0000E9r 2  00 00        	.addr $0000							; w
0000EBr 2  00 00        	.addr $0000							; x
0000EDr 2  00 00        	.addr $0000							; y
0000EFr 2  00 00        	.addr $0000							; z
0000F1r 2  00 00        	.addr $0000							; {
0000F3r 2  00 00        	.addr $0000							; |
0000F5r 2  00 00        	.addr $0000							; }
0000F7r 2  00 00        	.addr $0000							; ~
0000F9r 2               
0000F9r 2               
0000F9r 2               OBJ_SKY:
0000F9r 2  00 00        	.byte $00, $00
0000FBr 2  00 00        	.byte $00, $00
0000FDr 2               
0000FDr 2               OBJ_QBROCK:
0000FDr 2  90 91        	.byte $90, $91
0000FFr 2  92 93        	.byte $92, $93
000101r 2               
000101r 2               OBJ_BROCK:
000101r 2  94 94        	.byte $94, $94
000103r 2  95 95        	.byte $95, $95
000105r 2               
000105r 2               OBJ_COIN:
000105r 2  84 85        	.byte $84, $85
000107r 2  86 87        	.byte $86, $87
000109r 2               
000109r 2               OBJ_GROUND:
000109r 2  80 81        	.byte $80, $81
00010Br 2  82 83        	.byte $82, $83
00010Dr 2               
00010Dr 2               
00010Dr 1               
00010Dr 1               .code									; ----- code -----
00010Dr 1               
00010Dr 1               .include "./asm/joypad.asm"
00010Dr 2               .scope Joypad
00010Dr 2               
00010Dr 2               BTN_A									= %10000000
00010Dr 2               BTN_B									= %01000000
00010Dr 2               BTN_S									= %00100000
00010Dr 2               BTN_T									= %00010000
00010Dr 2               BTN_U									= %00001000
00010Dr 2               BTN_D									= %00000100
00010Dr 2               BTN_L									= %00000010
00010Dr 2               BTN_R									= %00000001
00010Dr 2               
00010Dr 2               .ZeroPage
00001Ar 2  00           joy1					: .byte 0
00001Br 2  00           joy2					: .byte 0
00001Cr 2  00           joy1_prev				: .byte 0
00001Dr 2  00           joy2_prev				: .byte 0
00001Er 2  00           joy1_pushstart			: .byte 0
00001Fr 2  00           joy2_pushstart			: .byte 0
000020r 2               
000020r 2               
000020r 2               ;*------------------------------------------------------------------------------
000020r 2               ; Get Joypad data (including prev and newly pushed btn)
000020r 2               ; @PARAM	None
000020r 2               ; @BREAK	A
000020r 2               ; @RETURN	None
000020r 2               ;*------------------------------------------------------------------------------
000020r 2               
000020r 2               .code									; ----- code -----
00010Dr 2               
00010Dr 2               .proc _getJoyData
00010Dr 2               		; set prev
00010Dr 2  A5 rr        		lda Joypad::joy1
00010Fr 2  85 rr        		sta Joypad::joy1_prev
000111r 2  A5 rr        		lda Joypad::joy2
000113r 2  85 rr        		sta Joypad::joy2_prev
000115r 2               
000115r 2  20 rr rr     		jsr Joypad::_readJoy
000118r 2               
000118r 2  A5 rr        		lda Joypad::joy1
00011Ar 2  29 0A        		and #Joypad::BTN_U|Joypad::BTN_L				; Compare Up and Left...
00011Cr 2  4A           		lsr
00011Dr 2  25 rr        		and Joypad::joy1						; to Down and Right
00011Fr 2  F0 0A        		beq @GET_PUSHSTART_BTN
000121r 2               		; Use previous frame's directions
000121r 2  A5 rr        		lda Joypad::joy1
000123r 2  45 rr        		eor Joypad::joy1_prev
000125r 2  29 F0        		and #%11110000
000127r 2  45 rr        		eor Joypad::joy1_prev
000129r 2  85 rr        		sta Joypad::joy1
00012Br 2               
00012Br 2               @GET_PUSHSTART_BTN:
00012Br 2               		; set pushstart
00012Br 2  A5 rr        		lda Joypad::joy1_prev
00012Dr 2  49 FF        		eor #%11111111
00012Fr 2  25 rr        		and Joypad::joy1
000131r 2  85 rr        		sta Joypad::joy1_pushstart
000133r 2  A5 rr        		lda Joypad::joy2_prev
000135r 2  49 FF        		eor #%11111111
000137r 2  25 rr        		and Joypad::joy2
000139r 2  85 rr        		sta Joypad::joy2_pushstart
00013Br 2               
00013Br 2  60           		rts
00013Cr 2               		; ------------------------------
00013Cr 2               .endproc
00013Cr 2               
00013Cr 2               
00013Cr 2               ;*------------------------------------------------------------------------------
00013Cr 2               ; Read controller
00013Cr 2               ; @PARAM	None
00013Cr 2               ; @BREAK	A
00013Cr 2               ; @RETURN	None
00013Cr 2               ;*------------------------------------------------------------------------------
00013Cr 2               
00013Cr 2               .code									; ----- code -----
00013Cr 2               
00013Cr 2               .proc _readJoy
00013Cr 2               		; Init controller & Set a ring counter
00013Cr 2  A9 01        		lda #1
00013Er 2  8D 16 40     		sta JOYPAD1
000141r 2  85 rr        		sta Joypad::joy2						; ring counter
000143r 2  4A           		lsr								; A = 0
000144r 2  8D 16 40     		sta JOYPAD1
000147r 2               
000147r 2               @READ_JOY_LOOP:
000147r 2  AD 16 40     		lda JOYPAD1
00014Ar 2  29 03        		and #%00000011
00014Cr 2  C9 01        		cmp #$01						; A - 1 = A + 0xff; if A > 0 then Carry=1
00014Er 2  26 rr        		rol Joypad::joy1						; Carry -> Bit0; Bit7 -> Carry
000150r 2  AD 17 40     		lda JOYPAD2
000153r 2  29 03        		and #%00000011
000155r 2  C9 01        		cmp #$01
000157r 2  26 rr        		rol Joypad::joy2
000159r 2  90 EC        		bcc @READ_JOY_LOOP				; CarryON -> end
00015Br 2  60           		rts
00015Cr 2               		; ------------------------------
00015Cr 2               .endproc
00015Cr 2               
00015Cr 2               
00015Cr 2               .endscope
00015Cr 2               
00015Cr 1               .include "./asm/macro.asm"
00015Cr 2               ; ------------------------------------------------------------------------------
00015Cr 2               ; Load array
00015Cr 2               ; A = Arr[X][Y]
00015Cr 2               ; @PARAM	ADDR: Array Address
00015Cr 2               ; @PARAM	X Y: index (Access Arr[x][y])
00015Cr 2               ; @BREAK	tmp1
00015Cr 2               ; ------------------------------------------------------------------------------
00015Cr 2               
00015Cr 2               .code									; ----- code -----
00015Cr 2               
00015Cr 2               .macro ldarr addr
00015Cr 2               		.if !(.blank(addr))
00015Cr 2               			sty tmp1						; save Y
00015Cr 2               			txa
00015Cr 2               			asl								; ×2（アドレスが16bitなのでARR[x][y]のxが+1 => 読み込むアドレスは+2する必要がある
00015Cr 2               			tay								; アドレッシングに使うためYレジスタへ
00015Cr 2               			lda addr, y						; Low
00015Cr 2               			sta <addr_tmp1
00015Cr 2               			lda addr+1, y					; High
00015Cr 2               			sta >addr_tmp1
00015Cr 2               			ldy tmp1						; restore Y
00015Cr 2               			lda (addr_tmp1), y
00015Cr 2               		.else
00015Cr 2               			.error "Arg addr in macro ldarr is wrong."
00015Cr 2               		.endif
00015Cr 2               .endmacro
00015Cr 2               
00015Cr 2               
00015Cr 2               ; ------------------------------------------------------------------------------
00015Cr 2               ; Calculate Negative Numbers
00015Cr 2               ; ------------------------------------------------------------------------------
00015Cr 2               
00015Cr 2               .code									; ----- code -----
00015Cr 2               
00015Cr 2               .macro cnn
00015Cr 2               		eor #$ff
00015Cr 2               		add #$01
00015Cr 2               .endmacro
00015Cr 2               
00015Cr 2               
00015Cr 2               ; ------------------------------------------------------------------------------
00015Cr 2               ; Addition
00015Cr 2               ; This Macro only supports Immediate/Zeropage/Absolute addressing.
00015Cr 2               ; Other addressing modes are not optimized for speed.
00015Cr 2               ; Other addressing usage: add a, {$00, x} / add a, {($00), y}
00015Cr 2               ; @PARAM	arg1: register or Address
00015Cr 2               ; @PARAM	arg2
00015Cr 2               ; ------------------------------------------------------------------------------
00015Cr 2               
00015Cr 2               .code									; ----- code -----
00015Cr 2               
00015Cr 2               .macro add arg1, arg2
00015Cr 2               		.if (.paramcount = 1)
00015Cr 2               			; arg1: val
00015Cr 2               			; add #3 / add $80
00015Cr 2               			clc
00015Cr 2               			adc arg1
00015Cr 2               		.elseif (.paramcount = 2)
00015Cr 2               			; arg1: target
00015Cr 2               			; arg2: val
00015Cr 2               			.if (.match({arg1}, a))
00015Cr 2               				; add a, #3 / add a, $80
00015Cr 2               				clc
00015Cr 2               				adc arg2
00015Cr 2               			.elseif (.match({arg1}, x))
00015Cr 2               				; add x, ??
00015Cr 2               				.if (\
00015Cr 2               					.match(.left(1, {arg2}), #) &&\
00015Cr 2               					.right(.tcount({arg2})-1, {arg2}) <= 7\
00015Cr 2               				)
00015Cr 2               					; add x, #0~7
00015Cr 2               					.repeat (.right(.tcount({arg2})-1, {arg2}))
00015Cr 2               						inx
00015Cr 2               					.endrepeat
00015Cr 2               				.else
00015Cr 2               					pha
00015Cr 2               					txa
00015Cr 2               					clc
00015Cr 2               					adc arg2
00015Cr 2               					tax
00015Cr 2               					pla
00015Cr 2               				.endif
00015Cr 2               			.elseif (.match({arg1}, y))
00015Cr 2               				; add y, ??
00015Cr 2               				.if (\
00015Cr 2               					.match(.left(1, {arg2}), #) &&\
00015Cr 2               					.right(.tcount({arg2})-1, {arg2}) <= 7\
00015Cr 2               				)
00015Cr 2               					; add y, #0~7
00015Cr 2               					.repeat (.right(.tcount ({arg2})-1, {arg2}))
00015Cr 2               						iny
00015Cr 2               					.endrepeat
00015Cr 2               				.else
00015Cr 2               					pha
00015Cr 2               					tya
00015Cr 2               					clc
00015Cr 2               					adc arg2
00015Cr 2               					tay
00015Cr 2               					pla
00015Cr 2               				.endif
00015Cr 2               			.endif
00015Cr 2               		.else
00015Cr 2               			.error "Args in macro add are wrong."
00015Cr 2               		.endif
00015Cr 2               .endmacro
00015Cr 2               
00015Cr 2               
00015Cr 2               ; ------------------------------------------------------------------------------
00015Cr 2               ; Subtraction
00015Cr 2               ; See macro add for comments
00015Cr 2               ; @PARAM	arg1: register or Address
00015Cr 2               ; @PARAM	arg2
00015Cr 2               ; ------------------------------------------------------------------------------
00015Cr 2               
00015Cr 2               .code									; ----- code -----
00015Cr 2               
00015Cr 2               .macro sub arg1, arg2
00015Cr 2               		.if (.paramcount = 1)
00015Cr 2               			sec
00015Cr 2               			sbc arg1
00015Cr 2               		.elseif (.paramcount = 2 && .match({arg1}, a))
00015Cr 2               			sec
00015Cr 2               			sbc arg2
00015Cr 2               		.elseif (.paramcount = 2 && .match({arg1}, x))
00015Cr 2               			.if (\
00015Cr 2               				.match(.left(1, {arg2}), #) &&\
00015Cr 2               				.right(.tcount({arg2})-1, {arg2}) <= 7\
00015Cr 2               			)
00015Cr 2               				.repeat (.right(.tcount({arg2})-1, {arg2}))
00015Cr 2               					dex
00015Cr 2               				.endrepeat
00015Cr 2               			.else
00015Cr 2               				pha
00015Cr 2               				txa
00015Cr 2               				sec
00015Cr 2               				sbc arg2
00015Cr 2               				tax
00015Cr 2               				pla
00015Cr 2               			.endif
00015Cr 2               		.elseif (.paramcount = 2 && .match({arg1}, y))
00015Cr 2               			.if (\
00015Cr 2               				.match(.left(1, {arg2}), #) &&\
00015Cr 2               				.right(.tcount({arg2})-1, {arg2}) <= 7\
00015Cr 2               			)
00015Cr 2               				.repeat (.right(.tcount ({arg2})-1, {arg2}))
00015Cr 2               					dey
00015Cr 2               				.endrepeat
00015Cr 2               			.else
00015Cr 2               				pha
00015Cr 2               				tya
00015Cr 2               				sec
00015Cr 2               				sbc arg2
00015Cr 2               				tay
00015Cr 2               				pla
00015Cr 2               			.endif
00015Cr 2               		.else
00015Cr 2               			.error "Args in macro sub are wrong."
00015Cr 2               		.endif
00015Cr 2               .endmacro
00015Cr 2               
00015Cr 2               
00015Cr 2               ;*------------------------------------------------------------------------------
00015Cr 2               ; Light shift
00015Cr 2               ; arg1 <<= c
00015Cr 2               ; @PARAM	c: default=#1
00015Cr 2               ;*------------------------------------------------------------------------------
00015Cr 2               
00015Cr 2               .code									; ----- code -----
00015Cr 2               
00015Cr 2               .macro shl c
00015Cr 2               		.if (.blank(c))
00015Cr 2               			asl
00015Cr 2               		.elseif (.match(.left(1, {c}), #))
00015Cr 2               			.repeat	(.right(.tcount ({c})-1, {c}))
00015Cr 2               				asl
00015Cr 2               			.endrepeat
00015Cr 2               		.else
00015Cr 2               			.error "Arg \"c\" in macro shl is wrong."
00015Cr 2               		.endif
00015Cr 2               .endmacro
00015Cr 2               
00015Cr 2               
00015Cr 2               ;*------------------------------------------------------------------------------
00015Cr 2               ; Right shift
00015Cr 2               ; arg1 >>= c
00015Cr 2               ; @PARAM	c: default=#1
00015Cr 2               ;*------------------------------------------------------------------------------
00015Cr 2               
00015Cr 2               .code									; ----- code -----
00015Cr 2               
00015Cr 2               .macro shr c
00015Cr 2               		.if (.blank(c))
00015Cr 2               			lsr
00015Cr 2               		.elseif (.match(.left(1, {c}), #))
00015Cr 2               			.repeat	(.right(.tcount ({c})-1, {c}))
00015Cr 2               				lsr
00015Cr 2               			.endrepeat
00015Cr 2               		.else
00015Cr 2               			.error "Arg \"c\" in macro shr is wrong."
00015Cr 2               		.endif
00015Cr 2               .endmacro
00015Cr 2               
00015Cr 2               
00015Cr 2               ;*------------------------------------------------------------------------------
00015Cr 2               ; Arithmetic left shift
00015Cr 2               ;! Deprecated (Not shortened)
00015Cr 2               ; A >>= c
00015Cr 2               ; @PARAM	c: default=1
00015Cr 2               ;*------------------------------------------------------------------------------
00015Cr 2               
00015Cr 2               .code									; ----- code -----
00015Cr 2               
00015Cr 2               .macro ashl c
00015Cr 2               		cmp #%1000_0000
00015Cr 2               		php								; Save carry
00015Cr 2               		.if (.blank(c))
00015Cr 2               			; ashl
00015Cr 2               			shl #2
00015Cr 2               		.elseif (.match(.left(1, {c}), #))
00015Cr 2               			; ashl #4
00015Cr 2               			shl #((.right(.tcount ({c})-1, {c})) + 1)
00015Cr 2               		.else
00015Cr 2               			.error "Arg \"c\" in macro ashl is wrong."
00015Cr 2               		.endif
00015Cr 2               		plp
00015Cr 2               		ror								; a /= 2, carry into bit7
00015Cr 2               .endmacro
00015Cr 2               
00015Cr 2               
00015Cr 2               ;*------------------------------------------------------------------------------
00015Cr 2               ; Arithmetic right shift
00015Cr 2               ; A >>= c
00015Cr 2               ; @PARAM	c: default=1
00015Cr 2               ;
00015Cr 2               ; To ASR a memory location
00015Cr 2               ; (From http://wiki.nesdev.com/w/index.php/Synthetic_instructions#Arithmetic_shift_right)
00015Cr 2               ; 	lda addr		; Copy memory into A
00015Cr 2               ; 	asl				; Copy sign bit of A into carry (shorter than CMP)
00015Cr 2               ; 	ror addr
00015Cr 2               ;*------------------------------------------------------------------------------
00015Cr 2               
00015Cr 2               .code									; ----- code -----
00015Cr 2               
00015Cr 2               .macro ashr c
00015Cr 2               		.if (.blank(c))
00015Cr 2               			; ashr
00015Cr 2               			cmp #%1000_0000				; Bit7 into carry
00015Cr 2               			ror							; Shift carry into Bit7
00015Cr 2               		.elseif (.match(.left(1, {c}), #))
00015Cr 2               			; ashr #4
00015Cr 2               			.repeat (.right(.tcount ({c})-1, {c}))
00015Cr 2               				cmp #%1000_0000
00015Cr 2               				ror
00015Cr 2               			.endrepeat
00015Cr 2               		.else
00015Cr 2               			.error "Arg \"c\" in macro ashr is wrong."
00015Cr 2               		.endif
00015Cr 2               .endmacro
00015Cr 2               
00015Cr 2               
00015Cr 2               
00015Cr 2               .macro tfrPlt n
00015Cr 2               		; Transfar pallete
00015Cr 2               		lda #>PLT_TABLE_ADDR
00015Cr 2               		sta PPU_ADDR
00015Cr 2               		lda #<PLT_TABLE_ADDR			; Addr lo = 0
00015Cr 2               		sta PPU_ADDR
00015Cr 2               		tax								; X = 0
00015Cr 2               :
00015Cr 2               		ldy #3
00015Cr 2               		lda #$22						; under ground -> #$0f
00015Cr 2               		sta PPU_DATA
00015Cr 2               :
00015Cr 2               		lda DEFAULT_PLT, x				; under ground -> UNDER_GROUND_PLT
00015Cr 2               		sta PPU_DATA
00015Cr 2               		inx
00015Cr 2               		dey
00015Cr 2               		bne :-
00015Cr 2               		cpx #$3*8
00015Cr 2               		bcc :--
00015Cr 2               
00015Cr 2               	lda #$23
00015Cr 2               	sta PPU_ADDR
00015Cr 2               	lda #$c0
00015Cr 2               	sta PPU_ADDR
00015Cr 2               	lda #$ff
00015Cr 2               	sta PPU_DATA
00015Cr 2               	sta PPU_DATA
00015Cr 2               	sta PPU_DATA
00015Cr 2               	sta PPU_DATA
00015Cr 2               	sta PPU_DATA
00015Cr 2               	sta PPU_DATA
00015Cr 2               	sta PPU_DATA
00015Cr 2               	sta PPU_DATA
00015Cr 2               .endmacro
00015Cr 2               
00015Cr 1               .include "./asm/subfunc.asm"
00015Cr 2               .scope Subfunc
00015Cr 2               
00015Cr 2               ;*------------------------------------------------------------------------------
00015Cr 2               ; Restore PPU setting
00015Cr 2               ; @PARAM	None
00015Cr 2               ; @BREAK	A
00015Cr 2               ; @RETURN	None
00015Cr 2               ;*------------------------------------------------------------------------------
00015Cr 2               
00015Cr 2               .code									; ----- code -----
00015Cr 2               
00015Cr 2               .proc _restorePPUSet
00015Cr 2  A5 rr        		lda ppu_ctrl1_cpy
00015Er 2  8D 00 20     		sta PPU_CTRL1
000161r 2  A5 rr        		lda ppu_ctrl2_cpy
000163r 2  8D 01 20     		sta PPU_CTRL2
000166r 2  60           		rts
000167r 2               		; ------------------------------
000167r 2               .endproc
000167r 2               
000167r 2               
000167r 2               
000167r 2               ;*------------------------------------------------------------------------------
000167r 2               ; Set scroll position
000167r 2               ; Use during NMI or executing raster scroll.
000167r 2               ; @PARAM	None
000167r 2               ; @BREAK	A
000167r 2               ; @RETURN	None
000167r 2               ;*------------------------------------------------------------------------------
000167r 2               
000167r 2               .code									; ----- code -----
000167r 2               
000167r 2               .proc _setScroll
000167r 2  A5 rr        		lda scroll_x
000169r 2  8D 05 20     		sta PPU_SCROLL
00016Cr 2  A5 rr        		lda scroll_y
00016Er 2  8D 05 20     		sta PPU_SCROLL
000171r 2               
000171r 2               	; TODO: きちんとスクロール実装したらメインスクリーンの切り替え実装
000171r 2  A5 rr        	lda ppu_ctrl1_cpy
000173r 2  29 FC        	and #%1111_1100
000175r 2  85 rr        	sta ppu_ctrl1_cpy
000177r 2  8D 00 20     	sta PPU_CTRL1
00017Ar 2               
00017Ar 2  60           		rts
00017Br 2               		; ------------------------------
00017Br 2               .endproc
00017Br 2               
00017Br 2               
00017Br 2               ;*------------------------------------------------------------------------------
00017Br 2               ; Wait starting vblank
00017Br 2               ; @PARAM	None
00017Br 2               ; @BREAK	None
00017Br 2               ; @RETURN	Non
00017Br 2               ;*------------------------------------------------------------------------------
00017Br 2               
00017Br 2               .code									; ----- code -----
00017Br 2               
00017Br 2               .proc _waitVblank
00017Br 2  2C 02 20     		bit $2002
00017Er 2  10 FB        		bpl _waitVblank
000180r 2  60           		rts
000181r 2               		; ------------------------------
000181r 2               .endproc
000181r 2               
000181r 2               
000181r 2               ;*------------------------------------------------------------------------------
000181r 2               ; Disp status text
000181r 2               ; @PARAM	None
000181r 2               ; @BREAK	A X Y
000181r 2               ; @RETURN	None
000181r 2               ;*------------------------------------------------------------------------------
000181r 2               
000181r 2               .code									; ----- code -----
000181r 2               
000181r 2               .proc _dispStatus
000181r 2  A6 rr        		ldx bg_buff_pointer
000183r 2  A0 1F        		ldy #(@TEXT_END - @TEXT)
000185r 2               @STORE_PPU_DATA_LOOP:
000185r 2  BD rr rr     		lda @TEXT, x
000188r 2  F0 07        		beq @END_STORE
00018Ar 2  9D 49 01     		sta BG_BUFF, x
00018Dr 2  E8           		inx
00018Er 2  88           		dey
00018Fr 2  D0 F4        		bne @STORE_PPU_DATA_LOOP
000191r 2               @END_STORE:
000191r 2  86 rr        		stx bg_buff_pointer
000193r 2  86 80        		stx $80
000195r 2  60           		rts
000196r 2               		; ------------------------------
000196r 2               
000196r 2               .rodata									; ----- data -----
000000r 2               @TEXT:
000000r 2  FE 20 22     		.byte PPU_VERTICAL_MODE
000003r 2               		ADDR_BG_BE 2, 1, 0
000003r 2  53 43 4F 52  		.byte "SCORE XXXXXX  C:YY  TIME ZZZ"
000007r 2  45 20 58 58  
00000Br 2  58 58 58 58  
00001Fr 2               @TEXT_END:
00001Fr 2               
00001Fr 2               .endproc
00001Fr 2               
00001Fr 2               
00001Fr 2               ;*------------------------------------------------------------------------------
00001Fr 2               ; Prepare plt data
00001Fr 2               ; @PARAM	None
00001Fr 2               ; @BREAK	A X Y
00001Fr 2               ; @RETURN	None
00001Fr 2               ;*------------------------------------------------------------------------------
00001Fr 2               
00001Fr 2               .proc _preparePltData
00001Fr 2  60           		rts
000020r 2               .endproc
000020r 2               
000020r 2               
000020r 2               .endscope
000020r 2               
000020r 1               .include "./asm/nmi.asm"
000020r 2               ;*------------------------------------------------------------------------------
000020r 2               ; BG_BUFFを読み取り，指定アドレスに書き込んでカウンタをインクリメント
000020r 2               ; Read PPU update data & store to PPU
000020r 2               ; @PARAM	ADDR: Forwarding address
000020r 2               ; @BREAK	A X
000020r 2               ; @RETURN	None
000020r 2               ;*------------------------------------------------------------------------------
000020r 2               
000020r 2               .code									; ----- code -----
000196r 2               
000196r 2               .macro tfrDataToPPU ADDR
000196r 2               	lda BG_BUFF, x
000196r 2               	sta ADDR
000196r 2               	inx
000196r 2               .endmacro
000196r 2               
000196r 2               ; memo
000196r 2               ; ----- PPU buff data structure -----
000196r 2               ; r: Direction
000196r 2               ; 	Bit0 is a flag, others are 1.
000196r 2               ; 	-> 0b1111_111[0/1]
000196r 2               ; 	-> 0xFE（Horizontal）/0xFF（Vertical）
000196r 2               ; a: Addr
000196r 2               ; d: Data
000196r 2               ; r [a a] [d d d ... d] r [a a] [d d ... d]
000196r 2               
000196r 2               
000196r 2               ;*------------------------------------------------------------------------------
000196r 2               ; NMI (Interrupt)
000196r 2               ; @BREAK X Y (When end main process.)
000196r 2               ; To shorten the clock, put the buffer data on the stack
000196r 2               ; 	(Shorten clock by buff data length)
000196r 2               ; 	pla -> 3 clc
000196r 2               ; 	lda ZP/ABSORUTE, x -> 4 clc
000196r 2               ;*------------------------------------------------------------------------------
000196r 2               
000196r 2               .code									; ----- code -----
000196r 2               
000196r 2               .proc _nmi
000196r 2  48           		pha								; If main processing has not finished, tmp_rgstA may be in use
000197r 2  E6 rr        		inc nmi_cnt
000199r 2  A5 rr        		lda is_processing_main
00019Br 2  F0 02        		beq @NMI_MAIN
00019Dr 2  68           		pla
00019Er 2  40           		rti	; --------------------------
00019Fr 2               
00019Fr 2               @NMI_MAIN:
00019Fr 2               
00019Fr 2  A2 00        	ldx #0
0001A1r 2  86 rr        	stx tmp1
0001A3r 2               @PLT_STORE_LOOP:
0001A3r 2  A5 rr        	lda plt_addr+1
0001A5r 2  8D 06 20     	sta PPU_ADDR
0001A8r 2  A5 rr        	lda plt_addr+0
0001AAr 2  18 69 08     	add #8
0001ADr 2  18 65 rr     	add tmp1
0001B0r 2  8D 06 20     	sta PPU_ADDR
0001B3r 2               
0001B3r 2  BD 34 01     	lda BG_PLT_BUFF, x
0001B6r 2  8D 07 20     	sta PPU_DATA
0001B9r 2  A5 rr        	lda tmp1
0001BBr 2  18 69 08     	add #8
0001BEr 2  85 rr        	sta tmp1
0001C0r 2  E8           	inx
0001C1r 2  E0 07        	cpx #7
0001C3r 2  90 DE        	bcc @PLT_STORE_LOOP
0001C5r 2               
0001C5r 2  A5 rr        		lda ppu_ctrl1_cpy
0001C7r 2  09 04        		ora #%0000_0100					; Vertical mode
0001C9r 2  85 rr        		sta ppu_ctrl1_cpy
0001CBr 2  8D 00 20     		sta PPU_CTRL1					; Not use restorePPUSet()
0001CEr 2               
0001CEr 2               		; line 1
0001CEr 2  A5 rr        		lda ppu_bg_addr+1				; hi
0001D0r 2  8D 06 20     		sta PPU_ADDR
0001D3r 2  A5 rr        		lda ppu_bg_addr+0				; lo
0001D5r 2  8D 06 20     		sta PPU_ADDR
0001D8r 2               
0001D8r 2  A2 00        		ldx #0
0001DAr 2               @STORE_MAP_LOOP:
0001DAr 2  BD 00 01     		lda BG_MAP_BUFF, x
0001DDr 2  8D 07 20     		sta PPU_DATA
0001E0r 2  E8           		inx
0001E1r 2  E0 1A        		cpx #$1a
0001E3r 2  D0 F5        		bne @STORE_MAP_LOOP
0001E5r 2               
0001E5r 2               		; line 2
0001E5r 2  A5 rr        		lda ppu_bg_addr+1				; hi
0001E7r 2  8D 06 20     		sta PPU_ADDR
0001EAr 2  A6 rr        		ldx ppu_bg_addr+0				; lo (increment)
0001ECr 2  E8           		inx
0001EDr 2  8E 06 20     		stx PPU_ADDR
0001F0r 2               
0001F0r 2  A2 00        		ldx #0
0001F2r 2               @STORE_MAP_LOOP2:
0001F2r 2  BD 1A 01     		lda BG_MAP_BUFF+$1a, x
0001F5r 2  8D 07 20     		sta PPU_DATA
0001F8r 2  E8           		inx
0001F9r 2  E0 1A        		cpx #$1a
0001FBr 2  D0 F5        		bne @STORE_MAP_LOOP2
0001FDr 2               
0001FDr 2  A9 00        		lda #0
0001FFr 2  C5 rr        		cmp bg_buff_pointer
000201r 2  F0 35        		beq @STORE_CHR
000203r 2  AA           		tax
000204r 2  BD 49 01     		lda BG_BUFF, x
000207r 2               @SET_MODE:
000207r 2  29 01        		and #%00000001					; Get flag
000209r 2  0A 0A        		shl #2							; Move flag to Bit2
00020Br 2  85 rr        		sta tmp1						; Start using tmp1
00020Dr 2  A5 rr        		lda ppu_ctrl1_cpy
00020Fr 2  29 FB        		and #%11111011					; Mask direction flag
000211r 2  05 rr        		ora tmp1						; End using tmp1
000213r 2  85 rr        		sta ppu_ctrl1_cpy
000215r 2  8D 00 20     		sta PPU_CTRL1					; Not use restorePPUSet()
000218r 2               @SET_ADDR:
000218r 2  E8           		inx								; Not do inx when go to @EXIT
000219r 2  BD 49 01     		lda BG_BUFF, x
00021Cr 2  8D 06 20     		sta PPU_ADDR
00021Fr 2  E8           		inx
000220r 2  BD 49 01     		lda BG_BUFF, x
000223r 2  8D 06 20     		sta PPU_ADDR
000226r 2  E8           		inx
000227r 2               @STORE_DATA:
000227r 2  BD 49 01     		lda BG_BUFF, x
00022Ar 2  A8           		tay
00022Br 2  C9 FE        		cmp #$fe
00022Dr 2  B0 D8        		bcs @SET_MODE					; no inx
00022Fr 2  98           		tya
000230r 2  8D 07 20     		sta PPU_DATA
000233r 2  E8           		inx
000234r 2  E4 rr        		cpx bg_buff_pointer
000236r 2  D0 EF        		bne @STORE_DATA
000238r 2               
000238r 2               		; @SET_MODE + @SET_ADDR = 51 cycle
000238r 2               		; @STORE_DATA (return @STORE_DATA) = 24 cycle
000238r 2               		; @STORE_DATA (return @SET_MODE) = 13 cycle
000238r 2               
000238r 2               		; str1 = "A  B"
000238r 2               		; 	=> 51 + space_len * 24 cycle
000238r 2               		; 	=> mode(1) + addr(2) + data(2 + space_len) = (5 + space_len) bytes
000238r 2               		; 	|  len  || 1  | 2  |  3  |  4  |
000238r 2               		; 	| cycle || 75 | 99 | 123 | 147 |
000238r 2               		;	| bytes || 6  | 7  |  8  |  9  |
000238r 2               		; str2 = 'A', str3 = 'B'
000238r 2               		; 	=> (51 + 13) * 2 = 64 * 2 = 128 cycle
000238r 2               		; 	=> (mode(1) + addr(2) + data(1)) * 2 = 8 bytes
000238r 2               		; space length:
000238r 2               		; 	1: 75 cycle,	6 bytes (str1)
000238r 2               		; 	2: 99 cycle,	7 bytes
000238r 2               		; 	3: 123 cycle,	8 bytes
000238r 2               		; 	4~: 128 cycle,	8 bytes (str2)
000238r 2               @STORE_CHR:
000238r 2  A9 00        		lda #0
00023Ar 2  8D 03 20     		sta OAM_ADDR
00023Dr 2  A9 03        		lda #$03
00023Fr 2  8D 14 40     		sta OAM_DMA
000242r 2               
000242r 2               @EXIT:
000242r 2  A9 01        		lda #1
000244r 2  85 rr        		sta is_processing_main
000246r 2  4A           		shr
000247r 2  85 rr        		sta bg_buff_pointer				; A = 0
000249r 2  E6 rr        		inc frm_cnt
00024Br 2  20 rr rr     		jsr Subfunc::_setScroll
00024Er 2  68           		pla
00024Fr 2  40           		rti	; --------------------------
000250r 2               .endproc
000250r 2               
000250r 1               .include "./asm/init.asm"
000250r 2               .code									; ----- code -----
000250r 2               
000250r 2               .macro init
000250r 2               		sei								; Ban IRQ
000250r 2               		cld								; Ban BCD
000250r 2               		ldx #$ff
000250r 2               		txs
000250r 2               		inx
000250r 2               		stx PPU_CTRL1
000250r 2               		stx PPU_CTRL2
000250r 2               		stx SOUND_DP_1					; Ban IRQ of APU DMC (bit7)
000250r 2               
000250r 2               		/*
000250r 2               		A & $2002 -> set Z(zero flag)
000250r 2               		$2002 bit7(vblank) -> N(negative), bit6(sprite 0 hit) -> V(overflow)
000250r 2               		Reset vblank & sprite 0 hit flag
000250r 2               		(The state of this flag after reset is undefined.)
000250r 2               		*/
000250r 2               		bit $2002
000250r 2               
000250r 2               		jsr Subfunc::_waitVblank					; 1st time
000250r 2               
000250r 2               		; It takes about 30,000 cycles for the PPU to stabilize.
000250r 2               
000250r 2               		lda #$20
000250r 2               		sta PPU_ADDR
000250r 2               		txa								; X = A = 0
000250r 2               		sta PPU_ADDR
000250r 2               @CLR_MEM:
000250r 2               		sta $00, x
000250r 2               		sta $0100, x
000250r 2               		sta $0200, x
000250r 2               		sta $0400, x
000250r 2               		sta $0500, x
000250r 2               		sta $0600, x
000250r 2               		sta $0700, x
000250r 2               		inx
000250r 2               		bne @CLR_MEM
000250r 2               
000250r 2               		; CLEAR $2000~27ff
000250r 2               		ldy #8
000250r 2               @CLR_VRAM:
000250r 2               		sta PPU_DATA
000250r 2               		inx
000250r 2               		bne @CLR_VRAM
000250r 2               		dey
000250r 2               		bne @CLR_VRAM
000250r 2               
000250r 2               		lda #$ff
000250r 2               @CLR_CHR_MEM:
000250r 2               		sta $0300, x
000250r 2               		inx
000250r 2               		bne @CLR_CHR_MEM
000250r 2               
000250r 2               		; Store initial value
000250r 2               		lda #%10010000					; |NMI-ON|PPU=MASTER|SPR8*8|BG$1000|SPR$0000|VRAM+1|SCREEN$2000|
000250r 2               		sta ppu_ctrl1_cpy
000250r 2               		lda #%00011110					; |R|G|B|DISP-SPR|DISP-BG|SHOW-L8-SPR|SHOW-L8-BG|MODE=COLOR|
000250r 2               		sta ppu_ctrl2_cpy
000250r 2               
000250r 2               		jsr Subfunc::_waitVblank		; 2nd time
000250r 2               
000250r 2               		tfrPlt 0
000250r 2               
000250r 2               		lda #0
000250r 2               		sta OAM_ADDR
000250r 2               		lda #$03
000250r 2               		sta OAM_DMA
000250r 2               
000250r 2               	lda #$ff
000250r 2               	sta DrawMap::row_counter
000250r 2               
000250r 2               	and #0
000250r 2               	sta DrawMap::index
000250r 2               
000250r 2               	lda #'G'
000250r 2               	sta DrawMap::fill_ground_block
000250r 2               
000250r 2               	; test(load map 1 of world 1-1)
000250r 2               	ldy #0
000250r 2               	jsr DrawMap::_setStageAddr
000250r 2               	jsr DrawMap::_setMapAddr
000250r 2               
000250r 2               		; Screen On
000250r 2               		jsr Subfunc::_restorePPUSet
000250r 2               		jsr Subfunc::_setScroll
000250r 2               
000250r 2               		jsr Subfunc::_waitVblank
000250r 2               		jsr Subfunc::_dispStatus
000250r 2               .endmacro
000250r 2               
000250r 1               .include "./asm/draw_map.asm"
000250r 2               .scope DrawMap
000250r 2               
000250r 2               .ZeroPage
000020r 2  00           map_buff_num			: .byte 0
000021r 2  00 00        map_arr_addr			: .addr 0
000023r 2  00 00        map_addr				: .addr 0		; Map obj/position data (-> data addr: ROM)
000025r 2  00           isend_draw_stage		: .byte 0
000026r 2  00           row_counter				: .byte 0		; Every time this prg executed -> increment
000027r 2  00           index					: .byte 0		; index of map_addr
000028r 2  00           cnt_map_next			: .byte 0		; data (read from map_addr) = SP code(go next map) -> increment this counter
000029r 2  00           map_arr_num				: .byte 0
00002Ar 2  00           fill_upper				: .byte 0
00002Br 2  00           fill_lower				: .byte 0
00002Cr 2  00           fill_ground_block		: .byte 0
00002Dr 2  00           fill_block				: .byte 0
00002Er 2  00           fill_ground_end			: .byte 0
00002Fr 2               
00002Fr 2               
00002Fr 2               ;*------------------------------------------------------------------------------
00002Fr 2               ; Transfar obj data (8*8) to BG map buff($04XX/$05XX)
00002Fr 2               ; @PARAM	X: Block ID
00002Fr 2               ; @BREAK	A X Y
00002Fr 2               ; @RETURN	None
00002Fr 2               ;*------------------------------------------------------------------------------
00002Fr 2               
00002Fr 2               .macro trfToBgMapBuf
00002Fr 2               		lda BROCK_ID_ARR+LO, x
00002Fr 2               		sta addr_tmp2+LO
00002Fr 2               		lda BROCK_ID_ARR+HI, x
00002Fr 2               		sta addr_tmp2+HI
00002Fr 2               
00002Fr 2               		ldx bg_map_buff_index
00002Fr 2               
00002Fr 2               		ldy #0
00002Fr 2               		lda (addr_tmp2), y
00002Fr 2               		sta BG_MAP_BUFF+0, x
00002Fr 2               
00002Fr 2               		iny
00002Fr 2               		lda (addr_tmp2), y
00002Fr 2               		sta BG_MAP_BUFF+($0d*2), x
00002Fr 2               
00002Fr 2               		inx
00002Fr 2               
00002Fr 2               		iny
00002Fr 2               		lda (addr_tmp2), y
00002Fr 2               		sta BG_MAP_BUFF+0, x
00002Fr 2               
00002Fr 2               		iny
00002Fr 2               		lda (addr_tmp2), y
00002Fr 2               		sta BG_MAP_BUFF+($0d*2), x
00002Fr 2               
00002Fr 2               		inx
00002Fr 2               
00002Fr 2               		stx bg_map_buff_index
00002Fr 2               .endmacro
00002Fr 2               
00002Fr 2               
00002Fr 2               .macro incRowCounter
00002Fr 2               		ldy DrawMap::row_counter
00002Fr 2               		iny
00002Fr 2               		cpy #$10
00002Fr 2               		bne @NO_OVF_ROW_CNT
00002Fr 2               		ldy #0
00002Fr 2               		inc DrawMap::map_buff_num
00002Fr 2               @NO_OVF_ROW_CNT:
00002Fr 2               		sty DrawMap::row_counter
00002Fr 2               .endmacro
00002Fr 2               
00002Fr 2               
00002Fr 2               .macro initIndex
00002Fr 2               		ldy #NEGATIVE 1
00002Fr 2               		sty DrawMap::index
00002Fr 2               .endmacro
00002Fr 2               
00002Fr 2               
00002Fr 2               .macro fillBlocks
00002Fr 2               	lda addr_tmp2+LO
00002Fr 2               	and #BYT_LO
00002Fr 2               	sta addr_tmp2+LO
00002Fr 2               	txa
00002Fr 2               	pha
00002Fr 2               	tya
00002Fr 2               	pha
00002Fr 2               	ldx #0
00002Fr 2               	ldy #0
00002Fr 2               @LOOP:
00002Fr 2               	lda FILL_BLOCKS, y
00002Fr 2               	sta (addr_tmp2, x)
00002Fr 2               	lda addr_tmp2+LO
00002Fr 2               	add #$10
00002Fr 2               	sta addr_tmp2+LO
00002Fr 2               	iny
00002Fr 2               	cpy #$d
00002Fr 2               	bne @LOOP
00002Fr 2               
00002Fr 2               	pla
00002Fr 2               	tay
00002Fr 2               	pla
00002Fr 2               	tax
00002Fr 2               .endmacro
00002Fr 2               
00002Fr 2               
00002Fr 2               .macro loadNextMap
00002Fr 2               		inc DrawMap::map_arr_num
00002Fr 2               		ldy DrawMap::map_arr_num		; Y = ++map_arr_num
00002Fr 2               		jsr _setMapAddr
00002Fr 2               .endmacro
00002Fr 2               
00002Fr 2               
00002Fr 2               .macro setPpuBgAddr
00002Fr 2               		lda #0
00002Fr 2               		sta tmp1						; Start using tmp1
00002Fr 2               
00002Fr 2               		lda addr_tmp1+LO
00002Fr 2               		add #$40
00002Fr 2               		shl #1
00002Fr 2               		rol tmp1
00002Fr 2               		sta ppu_bg_addr+LO
00002Fr 2               
00002Fr 2               		lda addr_tmp1+HI				; 4 or 5
00002Fr 2               		and #BIT0
00002Fr 2               		shl #2							; 0 or 4
00002Fr 2               		ora #$20						; $20 or $24
00002Fr 2               		ora tmp1						; End using tmp1
00002Fr 2               		sta ppu_bg_addr+HI
00002Fr 2               .endmacro
00002Fr 2               
00002Fr 2               
00002Fr 2               ;*------------------------------------------------------------------------------
00002Fr 2               ; Update one row
00002Fr 2               ; @PARAM	None
00002Fr 2               ; @BREAK	A X Y tmp1 addr_tmp1 addr_tmp2
00002Fr 2               ; @RETURN	None
00002Fr 2               /* main label
00002Fr 2               	@START:
00002Fr 2               	@GET_POS_AND_OBJ_LOOP:
00002Fr 2               	@END_OF_MAP:						-> goto nextlabel (@LOAD_NEXT_MAP)
00002Fr 2               	@LOAD_NEXT_MAP:						-> goto @GET_POS_AND_OBJ_LOOP
00002Fr 2               	@END_OF_STAGE:						-> goto nextlabel (@PREPARE_BG_MAP_BUF)
00002Fr 2               	@PREPARE_BG_MAP_BUF:
00002Fr 2               	@STORE_BG_MAP_BUF_LOOP:
00002Fr 2               */
00002Fr 2               ;*------------------------------------------------------------------------------
00002Fr 2               
00002Fr 2               .code									; ----- code -----
000250r 2               
000250r 2               .proc _updateOneLine
000250r 2  A5 rr        		lda DrawMap::isend_draw_stage
000252r 2  F0 01        		beq @START
000254r 2  60           		rts
000255r 2               		; ------------------------------
000255r 2               
000255r 2               @START:
000255r 2  A4 rr C8 C0  		incRowCounter
000259r 2  10 D0 04 A0  
00025Dr 2  00 E6 rr 84  
000262r 2               
000262r 2  A5 rr        		lda DrawMap::map_buff_num
000264r 2  29 01        		and #BIT0
000266r 2  09 04        		ora #4
000268r 2  85 rr        		sta addr_tmp2+HI
00026Ar 2               
00026Ar 2  A5 rr        		lda DrawMap::row_counter
00026Cr 2  85 rr        		sta addr_tmp2
00026Er 2               
00026Er 2  A5 rr 29 0F  		fillBlocks
000272r 2  85 rr 8A 48  
000276r 2  98 48 A2 00  
000291r 2               
000291r 2  A4 rr        		ldy DrawMap::index
000293r 2               @GET_POS_AND_OBJ_LOOP:
000293r 2               		; ----------- get pos ----------
000293r 2  B1 rr        		lda (DrawMap::map_addr), y
000295r 2  85 rr        		sta tmp1
000297r 2               
000297r 2               		; Check Special Code
000297r 2  C9 FE        		cmp #OBJMAP_NEXT
000299r 2  F0 38        		beq @LOAD_NEXT_MAP
00029Br 2               
00029Br 2  C9 FF        		cmp #OBJMAP_END
00029Dr 2  F0 25        		beq @END_OF_MAP
00029Fr 2               
00029Fr 2               		; Check if it can be updated
00029Fr 2  29 0F        		and #BYT_LO
0002A1r 2  C5 rr        		cmp DrawMap::row_counter
0002A3r 2  D0 1A        		bne @GET_POS_AND_OBJ_LOOP_EXIT
0002A5r 2               
0002A5r 2  A5 rr        		lda DrawMap::map_buff_num
0002A7r 2  C5 rr        		cmp DrawMap::cnt_map_next		; Count OBJMAP_NEXT (is not reset until the stage changes)
0002A9r 2  D0 14        		bne @GET_POS_AND_OBJ_LOOP_EXIT
0002ABr 2               
0002ABr 2               		; -- Set addr of bg map buff ---
0002ABr 2  29 01        		and #BIT0
0002ADr 2  09 04        		ora #4
0002AFr 2  85 rr        		sta addr_tmp1+HI
0002B1r 2               
0002B1r 2               
0002B1r 2  A5 rr        		lda tmp1						; End using tmp1
0002B3r 2  85 rr        		sta addr_tmp1+LO
0002B5r 2               
0002B5r 2               		; ----------- get chr ----------
0002B5r 2  C8           		iny
0002B6r 2  A2 00        		ldx #0
0002B8r 2  B1 rr        		lda (DrawMap::map_addr), y
0002BAr 2  81 rr        		sta (addr_tmp1, x)
0002BCr 2               
0002BCr 2  C8           		iny
0002BDr 2  D0 D4        		bne @GET_POS_AND_OBJ_LOOP		; Jmp
0002BFr 2               		; ------------------------------
0002BFr 2               
0002BFr 2               @GET_POS_AND_OBJ_LOOP_EXIT:
0002BFr 2  84 rr        		sty DrawMap::index
0002C1r 2  4C rr rr     		jmp @PREPARE_BG_MAP_BUF
0002C4r 2               		; ------------------------------
0002C4r 2               
0002C4r 2               
0002C4r 2               		; End of map data (Not end of stage)
0002C4r 2               @END_OF_MAP:
0002C4r 2  E6 rr A4 rr  		loadNextMap
0002C8r 2  20 rr rr     
0002CBr 2               
0002CBr 2  A5 rr        		lda DrawMap::map_addr+HI
0002CDr 2  C9 FF        		cmp #ENDCODE					; A = Addr Hi
0002CFr 2  F0 08        		beq @END_OF_STAGE
0002D1r 2               
0002D1r 2  A0 03        		ldy #3							; この後inyされてy(index) = 4に
0002D3r 2               
0002D3r 2               @LOAD_NEXT_MAP:
0002D3r 2  E6 rr        		inc DrawMap::cnt_map_next
0002D5r 2  C8           		iny
0002D6r 2  4C rr rr     		jmp @GET_POS_AND_OBJ_LOOP
0002D9r 2               		; ------------------------------
0002D9r 2               
0002D9r 2               @END_OF_STAGE:
0002D9r 2  A0 00        		ldy #0
0002DBr 2  84 rr        		sty DrawMap::index
0002DDr 2  C8           		iny								; Y = 1
0002DEr 2  84 rr        		sty DrawMap::isend_draw_stage
0002E0r 2               
0002E0r 2               @PREPARE_BG_MAP_BUF:
0002E0r 2  A5 rr        		lda row_counter
0002E2r 2  85 rr        		sta addr_tmp1+LO				; PosY = 0
0002E4r 2               
0002E4r 2  A9 00 85 rr  		setPpuBgAddr
0002E8r 2  A5 rr 18 69  
0002ECr 2  40 0A 26 rr  
0002FEr 2               
0002FEr 2               		; Store plt addr(ppu)
0002FEr 2  A5 rr        		lda addr_tmp1+LO				; posX
000300r 2  4A           		shr #1
000301r 2  18 69 C0     		add #$c0
000304r 2  85 rr        		sta plt_addr+LO
000306r 2               
000306r 2  A5 rr        		lda addr_tmp1+HI
000308r 2  29 01        		and #1
00030Ar 2  0A 0A        		shl #2
00030Cr 2  18 69 23     		add #$23
00030Fr 2  85 rr        		sta plt_addr+HI
000311r 2               
000311r 2  A0 00        		ldy #0
000313r 2  84 rr        		sty bg_map_buff_index
000315r 2               
000315r 2               @STORE_BG_MAP_BUF_LOOP:					; for (y = 0; y < $0d; y++)
000315r 2  98           		tya
000316r 2  0A 0A 0A 0A  		shl #4
00031Ar 2  A8           		tay
00031Br 2  B1 rr        		lda (addr_tmp1), y
00031Dr 2               
00031Dr 2               		; prepare plt data -------------
00031Dr 2  84 rr        		sty tmp2						; (save counter) += $10
00031Fr 2  A4 rr        		ldy tmp1						; (save counter) += 1
000321r 2  48           		pha
000322r 2  29 30        		and #BIT5|BIT4
000324r 2  AA           		tax								; X: plt num(bit4-5) : tmp (Start using)
000325r 2  A5 rr        		lda DrawMap::row_counter
000327r 2  29 01        		and #BIT0
000329r 2  85 rr        		sta tmp3
00032Br 2  98           		tya
00032Cr 2  29 01        		and #BIT0
00032Er 2  0A           		shl #1
00032Fr 2  05 rr        		ora tmp3
000331r 2  85 rr        		sta tmp3
000333r 2               
000333r 2               		; y /= 2 (Use @PLT0) -> MEMO: 短縮可能
000333r 2  98           		tya
000334r 2  4A           		shr #1
000335r 2  A8           		tay
000336r 2               
000336r 2  8A           		txa								; End using X (plt num)
000337r 2  A6 rr        		ldx tmp3
000339r 2               		/*
000339r 2               		PLT_DATA = BLOCK3|BLOCK2|BLOCK1|BLOCK0
000339r 2               		-------------------------------
000339r 2               		| BLOCK0(>>4) | BLOCK1(>>2) |
000339r 2               		| BLOCK2(0)   | BLOCK3(<<2) |
000339r 2               		-------------------------------
000339r 2               		*/
000339r 2  F0 09        		beq @BLOCK0
00033Br 2  CA           		dex
00033Cr 2  F0 0D        		beq @BLOCK1
00033Er 2  CA           		dex
00033Fr 2  F0 11        		beq @BLOCK2
000341r 2  CA           		dex
000342r 2  F0 0C        		beq @BLOCK3
000344r 2               @BLOCK0:
000344r 2  4A 4A 4A 4A  		shr #4
000348r 2  4C rr rr     		jmp @STORE_TO_PLT_BUFF
00034Br 2               		; ------------------------------
00034Br 2               @BLOCK1:
00034Br 2  4A 4A        		shr #2
00034Dr 2  4C rr rr     		jmp @ADD_LEFT_BLOCK_PLT
000350r 2               		; ------------------------------
000350r 2               @BLOCK3:
000350r 2  0A 0A        		shl #2
000352r 2               @BLOCK2:
000352r 2               @ADD_LEFT_BLOCK_PLT:
000352r 2  19 34 01     		ora BG_PLT_BUFF, y
000355r 2               @STORE_TO_PLT_BUFF:
000355r 2  99 34 01     		sta BG_PLT_BUFF, y
000358r 2               
000358r 2  68           		pla
000359r 2  A4 rr        		ldy tmp2
00035Br 2               
00035Br 2  29 3F        		and #BIT5|BIT4|BIT3|BIT2|BIT1|BIT0
00035Dr 2  0A           		shl #1
00035Er 2               
00035Er 2  AA           		tax
00035Fr 2  BD rr rr 85  		trfToBgMapBuf
000363r 2  rr BD rr rr  
000367r 2  85 rr A6 rr  
000388r 2               
000388r 2  A4 rr        		ldy tmp1
00038Ar 2  C8           		iny
00038Br 2  84 rr        		sty tmp1
00038Dr 2  C0 0D        		cpy #$0d
00038Fr 2  90 84        		bcc @STORE_BG_MAP_BUF_LOOP
000391r 2               
000391r 2  60           		rts
000392r 2               		;-------------------------------
000392r 2               .endproc
000392r 2               
000392r 2               ;*------------------------------------------------------------------------------
000392r 2               ; Set addr of stages
000392r 2               ; @PARAM	Y: stage number
000392r 2               ; @BREAK	A Y
000392r 2               ; @RETURN	None (A = addr Hi)
000392r 2               ;*------------------------------------------------------------------------------
000392r 2               
000392r 2               .code									; ----- code -----
000392r 2               
000392r 2               .proc _setStageAddr
000392r 2  98           		tya
000393r 2  0A           		shl
000394r 2  A8           		tay
000395r 2               
000395r 2  B9 rr rr     		lda STAGE_ARR, y
000398r 2  85 rr        		sta DrawMap::map_arr_addr
00039Ar 2               
00039Ar 2  B9 rr rr     		lda STAGE_ARR+1, y
00039Dr 2  85 rr        		sta DrawMap::map_arr_addr+1
00039Fr 2               
00039Fr 2  60           		rts
0003A0r 2               		; ------------------------------
0003A0r 2               .endproc
0003A0r 2               
0003A0r 2               
0003A0r 2               ;*------------------------------------------------------------------------------
0003A0r 2               ; Set addr of maps
0003A0r 2               ; @PARAM	Y: map index
0003A0r 2               ; @BREAK	A Y
0003A0r 2               ; @RETURN	None
0003A0r 2               ;*------------------------------------------------------------------------------
0003A0r 2               
0003A0r 2               .code									; ----- code -----
0003A0r 2               
0003A0r 2               .proc _setMapAddr
0003A0r 2  98           		tya
0003A1r 2  0A           		shl
0003A2r 2  A8           		tay
0003A3r 2  48           		pha								; push y
0003A4r 2               
0003A4r 2  B1 rr        		lda (DrawMap::map_arr_addr), y
0003A6r 2  85 rr        		sta DrawMap::map_addr
0003A8r 2               
0003A8r 2  C8           		iny
0003A9r 2  B1 rr        		lda (DrawMap::map_arr_addr), y
0003ABr 2  85 rr        		sta DrawMap::map_addr+1
0003ADr 2               
0003ADr 2               	; ffコードをこの関数の返値にして，この関数の外でマップ終了を判定しているが
0003ADr 2               	; その前に@NO_EXIT以下の処理を行ってしまい，バグるため，ここで抜ける
0003ADr 2               	; 直接@END_OF_STAGEにジャンプしてもOKなはずだが（マップ終了判定でジャンプするラベル）
0003ADr 2               	; procを使っているため今は無理
0003ADr 2  C9 FF        	cmp #ENDCODE
0003AFr 2  D0 05        	bne @NO_EXIT
0003B1r 2  68           	pla
0003B2r 2  A8           	tay
0003B3r 2  A9 FF        	lda #ENDCODE
0003B5r 2  60           	rts
0003B6r 2               @NO_EXIT:
0003B6r 2               
0003B6r 2               	; ------------------------------
0003B6r 2               
0003B6r 2               
0003B6r 2               	; ----------- fill ground ----------
0003B6r 2  A0 00        	ldy #0
0003B8r 2               
0003B8r 2  B1 rr        	lda (DrawMap::map_addr), y
0003BAr 2  29 0F        	and #%0000_1111
0003BCr 2  85 rr        	sta DrawMap::fill_ground_end
0003BEr 2               
0003BEr 2  B1 rr        	lda (DrawMap::map_addr), y
0003C0r 2  4A 4A 4A 4A  	shr #4
0003C4r 2  AA           	tax
0003C5r 2  E4 rr        	cpx DrawMap::fill_ground_end
0003C7r 2  F0 0A        	beq @FILL_GROUND_LOOP_END
0003C9r 2               
0003C9r 2  A5 rr        	lda DrawMap::fill_ground_block
0003CBr 2               
0003CBr 2               @FILL_GROUND_LOOP:
0003CBr 2  9D 3C 01     	sta FILL_BLOCKS, x
0003CEr 2  E8           	inx
0003CFr 2  E4 rr        	cpx DrawMap::fill_ground_end
0003D1r 2  D0 F8        	bne @FILL_GROUND_LOOP
0003D3r 2               @FILL_GROUND_LOOP_END:
0003D3r 2               
0003D3r 2               	; ------------ fill block ----------
0003D3r 2  C8           	iny									; y = 1
0003D4r 2  B1 rr        	lda (DrawMap::map_addr), y
0003D6r 2  85 rr        	sta DrawMap::fill_block
0003D8r 2               
0003D8r 2  C8           	iny									; y = 2
0003D9r 2  B1 rr        	lda (DrawMap::map_addr), y
0003DBr 2  0A 0A 0A     	shl #3
0003DEr 2  A2 00        	ldx #0
0003E0r 2               @FILL_BLOCK_LOOP_UPPER:
0003E0r 2  0A           	shl #1
0003E1r 2  90 07        	bcc @NO_BLOCK1
0003E3r 2  48           	pha
0003E4r 2  A5 rr        	lda DrawMap::fill_block
0003E6r 2  9D 3C 01     	sta FILL_BLOCKS, x
0003E9r 2  68           	pla
0003EAr 2               @NO_BLOCK1:
0003EAr 2  E8           	inx
0003EBr 2  E0 05        	cpx #$5
0003EDr 2  90 F1        	bcc @FILL_BLOCK_LOOP_UPPER
0003EFr 2               
0003EFr 2  C8           	iny									; y = 3
0003F0r 2  B1 rr        	lda (DrawMap::map_addr), y
0003F2r 2               @FILL_BLOCK_LOOP_LOWER:
0003F2r 2  0A           	shl #1
0003F3r 2  90 07        	bcc @NO_BLOCK2
0003F5r 2  48           	pha
0003F6r 2  A5 rr        	lda DrawMap::fill_block
0003F8r 2  9D 3C 01     	sta FILL_BLOCKS, x
0003FBr 2  68           	pla
0003FCr 2               @NO_BLOCK2:
0003FCr 2  E8           	inx
0003FDr 2  E0 0D        	cpx #$d
0003FFr 2  90 F1        	bcc @FILL_BLOCK_LOOP_LOWER
000401r 2               
000401r 2  C8           	iny									; y = 4
000402r 2  84 rr        	sty DrawMap::index
000404r 2               	; ----------------------------------
000404r 2               
000404r 2  68           		pla
000405r 2  A8           		tay
000406r 2               
000406r 2  60           		rts
000407r 2               		; ------------------------------
000407r 2               .endproc
000407r 2               
000407r 2               
000407r 2               .endscope
000407r 2               
000407r 1               .include "main.asm"
000407r 2               ;*------------------------------------------------------------------------------
000407r 2               ; MAIN routine
000407r 2               ;*------------------------------------------------------------------------------
000407r 2               
000407r 2               .code									; ----- code -----
000407r 2               
000407r 2               .proc _main
000407r 2  A5 rr        		lda is_processing_main
000409r 2  F0 FC        		beq _main
00040Br 2               
00040Br 2  20 rr rr     		jsr Joypad::_getJoyData
00040Er 2               
00040Er 2  A5 rr        		lda Joypad::joy1_pushstart
000410r 2  29 80        		and #Joypad::BTN_A
000412r 2  F0 06        		beq @NO_PUSHED_BTN_A
000414r 2               
000414r 2  20 rr rr     		jsr DrawMap::_updateOneLine
000417r 2  20 rr rr     		jsr Subfunc::_preparePltData
00041Ar 2               @NO_PUSHED_BTN_A:
00041Ar 2               
00041Ar 2               		; ----- End main -----
00041Ar 2  A9 00        		lda #0
00041Cr 2  85 rr        		sta is_processing_main
00041Er 2  4C rr rr     		jmp _main
000421r 2               		; ------------------------------
000421r 2               .endproc
000421r 2               
000421r 1               
000421r 1               ; Use .org
000421r 1               .org SPR_BUFF
000300  1  xx xx xx xx  		.tag SPR_TBL
000304  1  xx xx xx xx  
000308  1  xx xx xx xx  
000400  1               
000400  1               
000400  1               .code									; ----- code -----
000400  1               .org $8000
008000  1               .segment "STARTUP"
008000  1               
008000  1               .proc _reset
008000  1  78 D8 A2 FF  		init
008004  1  9A E8 8E 00  
008008  1  20 8E 01 20  
0080C1  1               
0080C1  1  A9 01        		lda #1
0080C3  1  85 rr        		sta is_processing_main
0080C5  1               
0080C5  1  4C rr rr     		jmp _main
0080C8  1               		; ------------------------------
0080C8  1               .endproc
0080C8  1               
0080C8  1               
0080C8  1               .proc _irq
0080C8  1  40           		rti
0080C9  1               .endproc
0080C9  1               
0080C9  1               
0080C9  1               .segment "CHARS"
0080C9  1  03 0F 1F 1F  		.incbin "spr_bg.chr"
0080CD  1  1C 24 26 66  
0080D1  1  00 00 00 00  
00A0C9  1               
00A0C9  1               
00A0C9  1               .segment "VECINFO"
00A0C9  1  rr rr        		.addr _nmi
00A0CB  1  00 80        		.addr _reset
00A0CD  1  C8 80        		.addr _irq
00A0CD  1               
