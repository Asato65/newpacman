ca65 V2.19 - Git de30a57
Main file   : mario.asm
Current file: mario.asm

000000r 1               .setcpu "6502"
000000r 1               .feature c_comments						; Allow C language type comments (/* comments */)
000000r 1               .feature underline_in_numbers			; Allow notation %1010_0010
000000r 1               .feature string_escapes					; Allow \t, \n, \" and so on
000000r 1               .linecont +								; Allow line breaks in the middle of lines if you put a backslash at the end of the line
000000r 1               
000000r 1               
000000r 1               .segment "HEADER"
000000r 1  4E 45 53 1A  		.byte "NES", $1a
000004r 1  02           		.byte $02						; Program bank
000005r 1  01           		.byte $01						; Charactor bank
000006r 1  01           		.byte $01						; Vartical mirror
000007r 1  00           		.byte $00
000008r 1  00 00 00 00  		.byte $00, $00, $00, $00
00000Cr 1  00 00 00 00  		.byte $00, $00, $00, $00
000010r 1               
000010r 1               
000010r 1               .rodata									; ----- data -----
000000r 1               
000000r 1               .include "const.inc"
000000r 2               PPU_VERTICAL_MODE						= %11111110
000000r 2               PPU_HORIZONTAL_MODE						= %11111111
000000r 2               
000000r 2               ENDCODE									= $ff
000000r 2               
000000r 2               OBJMAP_NEXT								= $fe
000000r 2               OBJMAP_END								= $ff
000000r 2               
000000r 2               PPU_CTRL1_STD							= %10010000			; |NMION|PPU=MASTER|SPR8*8|BG$1000|SPR$0000|VRAM+1|SCRN$2000(2)|
000000r 2               PPU_CTRL2_STD							= %00011110			; |R|G|B|DISP-SPR|DISP-BG|SHOW-L8SPR|SHOW-L8BG|MODE=COLOR|
000000r 2               
000000r 2               
000000r 2               BIT0									= %00000001
000000r 2               BIT1									= %00000010
000000r 2               BIT2									= %00000100
000000r 2               BIT3									= %00001000
000000r 2               BIT4									= %00010000
000000r 2               BIT5									= %00100000
000000r 2               BIT6									= %01000000
000000r 2               BIT7									= %10000000
000000r 2               
000000r 2               BYT_GET_HI								= %11110000
000000r 2               BYT_GET_LO								= %00001111
000000r 2               
000000r 2               LO										= 0
000000r 2               HI										= 1
000000r 2               
000000r 2               INIT = 0
000000r 2               
000000r 2               PLAYER_SPR_ID							= $1				; スプライトID
000000r 2               PLAYER_CHR_BUFF_INDEX					= $0				; スプライトRAMのインデックス（0爆弾の次に配置する）
000000r 2               PLAYER_WIDTH							= $c
000000r 2               PLAYER_PADDING							= $2
000000r 2               
000000r 2               PLAYER_MAX_POSX							= $70				; マリオの行ける最大X座標（スクロールロックが無いとき）
000000r 2               
000000r 1               .include "const_addr.inc"
000000r 2               ZP					= $00
000000r 2               ; Unused $0200
000000r 2               bg_map_buff			= $0100				; size = $d ($10 - $3) * $4 = $40 - $c = $34
000000r 2               bg_plt_buff			= $0134				; size = 8
000000r 2               fill_block_arr		= $013c				; size = 13 ($d)
000000r 2               bg_buff				= $0149
000000r 2               CHR_BUFF			= $0700
000000r 2               MAP1				= $0400
000000r 2               MAP2				= $0500
000000r 2               USER_MEM			= $0700
000000r 2               
000000r 2               PLT_TABLE_ADDR		= $3f00
000000r 2               
000000r 2               ; PPU_CTRL1			= $2000		; nes.incで定義済み
000000r 2               ; PPU_CTRL2			= $2001
000000r 2               PPU_STATUS			= $2002
000000r 2               OAM_ADDR			= $2003
000000r 2               OAM_DATA			= $2004
000000r 2               PPU_SCROLL			= $2005
000000r 2               PPU_ADDR			= $2006
000000r 2               PPU_DATA			= $2007
000000r 2               OAM_DMA				= $4014
000000r 2               
000000r 2               
000000r 2               SOUND_SQ1_1			= $4000				; Duty(2)|time counter|音響変化|ボリューム(4)
000000r 2               SOUND_SQ1_2			= $4001				; 周波数変化|変化速度(3)|変化方向|変化範囲(3)
000000r 2               SOUND_SQ1_3			= $4002				; 周波数下位
000000r 2               SOUND_SQ1_4			= $4003				; 再生時間(5)|周波数上位(3)
000000r 2               SOUND_SQ2_1			= $4004
000000r 2               SOUND_SQ2_2			= $4005
000000r 2               SOUND_SQ2_3			= $4006
000000r 2               SOUND_SQ2_4			= $4007
000000r 2               SOUND_TR_1			= $4008				; 再生時間カウンタ|カウンタを使用した長さ(7)
000000r 2               SOUND_TR_2			= $400A				; 周波数下位
000000r 2               SOUND_TR_3			= $400B				; 再生時間(5)|周波数上位(3)
000000r 2               SOUND_NS_1			= $400C				; 未使用(2)|再生時間カウンタ|音響固定|ボリューム(3)
000000r 2               SOUND_NS_2			= $400E				; 乱数タイプ(高周波)|未使用(3)|サンプルレート(4)
000000r 2               SOUND_NS_3			= $400F				; 再生時間(5)|未使用(3)
000000r 2               SOUND_DP_1			= $4010
000000r 2               SOUND_DP_2			= $4011
000000r 2               SOUND_DP_3			= $4012
000000r 2               SOUND_DP_4			= $4013
000000r 2               SOUND_CHANNEL		= $4015				; 未使用(3)|DPCM|ノイズ|三角波|CH2|CH1
000000r 2               
000000r 2               
000000r 2               JOYPAD1				= $4016
000000r 2               JOYPAD2				= $4017
000000r 2               
000000r 1               .include "var_addr.inc"
000000r 2               ; ZeroPage
000000r 2               .segment "ZEROPAGE"
000000r 2  00           tmp1					: .byte 0
000001r 2  00           tmp2					: .byte 0
000002r 2  00           tmp3					: .byte 0
000003r 2  00           tmp4					: .byte 0
000004r 2  00           tmp5					: .byte 0
000005r 2  00           tmp6					: .byte 0
000006r 2               
000006r 2  00           bg_buff_pointer			: .byte 0
000007r 2  00 00        addr_tmp1				: .addr 0
000009r 2  00 00        addr_tmp2				: .addr 0
00000Br 2               
00000Br 2  00           bg_map_buff_index		: .byte 0		; BG（マップ）専用バッファ
00000Cr 2               
00000Cr 2  00 00        ppu_bg_addr				: .addr 0
00000Er 2               
00000Er 2  00           tmp_rgstA				: .byte 0
00000Fr 2  00           tmp_rgstX				: .byte 0
000010r 2  00           tmp_rgstY				: .byte 0
000011r 2               
000011r 2               ; These are not used often, but are used in NMI
000011r 2  00           ppu_ctrl1_cpy			: .byte 0		; |NMI-ON|PPU=MASTER|SPR8*8|BG$1000|SPR$0000|VRAM+1|SCREEN$2000(2)|
000012r 2  00           ppu_ctrl2_cpy			: .byte 0		; |R|G|B|DISP-SPR|DISP-BG|SHOW-L8-SPR|SHOW-L8-BG|MODE=COLOR|
000013r 2               
000013r 2  00           scroll_x				: .byte 0
000014r 2  00           scroll_amount			: .byte 0
000015r 2               
000015r 2  00           main_disp				: .byte 0
000016r 2               
000016r 2  00           nmi_cnt					: .byte 0
000017r 2  00           frm_cnt					: .byte 0
000018r 2  00           is_processing_main		: .byte 0
000019r 2               
000019r 2  00 00        plt_addr				: .addr 0
00001Br 2               
00001Br 2  00           is_updated_map			: .byte 0
00001Cr 2               
00001Cr 2  00           is_scroll_locked		: .byte 0
00001Dr 2               
00001Dr 2  00           is_jumping				: .byte 0
00001Er 2               
00001Er 2               
00001Er 2               .segment "BUFF_MEM"
000000r 2               
000000r 2               
000000r 2  xx xx xx xx  spr_posX_arr						: .res 6
000004r 2  xx xx        
000006r 2  xx xx xx xx  spr_posX_tmp_arr					: .res 6
00000Ar 2  xx xx        
00000Cr 2  xx xx xx xx  spr_velocity_x_arr					: .res 6
000010r 2  xx xx        
000012r 2  xx xx xx xx  spr_float_velocity_x_arr			: .res 6
000016r 2  xx xx        
000018r 2  xx xx xx xx  spr_decimal_part_velocity_x_arr		: .res 6		; 小数部分のみ（補正値）
00001Cr 2  xx xx        
00001Er 2               
00001Er 2  xx xx xx xx  spr_posY_arr						: .res 6
000022r 2  xx xx        
000024r 2  xx xx xx xx  spr_posY_tmp_arr					: .res 6
000028r 2  xx xx        
00002Ar 2  xx xx xx xx  spr_velocity_y_arr					: .res 6
00002Er 2  xx xx        
000030r 2  xx xx xx xx  spr_decimal_part_velocity_y_arr		: .res 6		; 小数部分のみ（補正値）
000034r 2  xx xx        
000036r 2  xx xx xx xx  spr_pos_y_origin					: .res 6
00003Ar 2  xx xx        
00003Cr 2  xx xx xx xx  spr_decimal_part_force_y			: .res 6		; 現在の加速度
000040r 2  xx xx        
000042r 2  xx xx xx xx  spr_force_fall_y					: .res 6		; 降下時の加速度
000046r 2  xx xx        
000048r 2  xx xx xx xx  spr_pos_y_decimal_part				: .res 6
00004Cr 2  xx xx        
00004Er 2  xx xx xx xx  spr_fix_val_y						: .res 6		; 加速度補正値
000052r 2  xx xx        
000054r 2               
000054r 2  xx xx xx xx  spr_anime_timer						: .res 6
000058r 2  xx xx        
00005Ar 2  xx xx xx xx  spr_anime_num						: .res 6
00005Er 2  xx xx        
000060r 2  xx xx xx xx  spr_id_arr							: .res 6		; id = 0: no spr
000064r 2  xx xx        
000066r 2  xx xx xx xx  spr_attr_arr						: .res 6		; bit0: 向き（1のとき右向き）
00006Ar 2  xx xx        
00006Cr 2               
00006Cr 2               
00006Cr 2               .code
000000r 2               
000000r 1               .include "defmacro.inc"
000000r 2               ;*------------------------------------------------------------------------------
000000r 2               ; Calcurate BG address
000000r 2               ; @PARAMS	 ptx: X coordinate
000000r 2               ; @PARAMS	 pty: Y coordinate
000000r 2               ; @PARAMS	 scn: Screen number
000000r 2               ;*------------------------------------------------------------------------------
000000r 2               
000000r 2               .define ADDR_BG (ptx, pty, scn)			$2000 + (ptx) + ((pty) * $20) + ((scn) * $400)
000000r 2               .define ADDR_BG_BE (ptx, pty, scn)		GET_BE ADDR_BG (ptx), (pty), (scn)
000000r 2               
000000r 2               ;*------------------------------------------------------------------------------
000000r 2               ; Calcurate SPR address
000000r 2               ; @PARAMS	 spr_num: Sprite number (0~63)
000000r 2               ; @PARAMS	 member:
000000r 2               ; 	pty: PosiTion Y
000000r 2               ; 	num: Tile(8*8) number
000000r 2               ; 	att: Attribute (VertFlip|HorizonFlip|Prio|Unused(3)|PltNum(2))
000000r 2               ; 	ptx: PosiTion X
000000r 2               ;*------------------------------------------------------------------------------
000000r 2               
000000r 2               .define ADDR_SPR(spr_num, member)		CHR_BUFF + ((spr_num)*4) + SPR_STRUCT::member
000000r 2               
000000r 2               
000000r 2               ;*------------------------------------------------------------------------------
000000r 2               ; Get data in big endian
000000r 2               ; dbyt = Define BYTe?
000000r 2               ; Define word data with the hi & lo bytes swapped
000000r 2               ; ($1234=$12,$34)
000000r 2               ;*------------------------------------------------------------------------------
000000r 2               
000000r 2               .define GET_BE(data)					.dbyt data
000000r 2               
000000r 2               
000000r 2               ;*------------------------------------------------------------------------------
000000r 2               ; Get obj position
000000r 2               ; @PARAMS		posX, posY
000000r 2               ; @RETURNS		$YX
000000r 2               ;*------------------------------------------------------------------------------
000000r 2               
000000r 2               .define GET_OBJ_POS(posX, posY)		($c - (posY)) * $10 + (posX)
000000r 2               
000000r 2               
000000r 2               ;*------------------------------------------------------------------------------
000000r 2               ; Return negative number
000000r 2               ;*------------------------------------------------------------------------------
000000r 2               
000000r 2               .define NEGATIVE(val)	256 - (val)
000000r 2               
000000r 1               .include "palette.inc"
000000r 2               DEFAULT_PLT:
000000r 2               		; BG
000000r 2  36 17 0F     		.byte $36, $17, $0f
000003r 2  27 17 0F     		.byte $27, $17, $0f				; 27 -> 07/17/27
000006r 2  29 1A 0F     		.byte $29, $1a, $0f
000009r 2  30 21 0F     		.byte $30, $21, $0f
00000Cr 2               		; SPR
00000Cr 2  16 27 18     		.byte $16, $27, $18
00000Fr 2  1A 30 27     		.byte $1a, $30, $27
000012r 2  16 30 27     		.byte $16, $30, $27
000015r 2  0F 36 17     		.byte $0f, $36, $17
000018r 2               
000018r 2               
000018r 2               UNDER_GROUND_PLT:
000018r 2               		; BG
000018r 2  3C 1C 0F     		.byte $3c, $1c, $0f
00001Br 2  27 17 1C     		.byte $27, $17, $1c
00001Er 2  29 1A 09     		.byte $29, $1a, $09
000021r 2  30 21 1C     		.byte $30, $21, $1c
000024r 2               		; SPR
000024r 2  16 27 18     		.byte $16, $27, $18
000027r 2  1C 30 17     		.byte $1c, $30, $17				; black disp: $30 -> $36
00002Ar 2  16 30 27     		.byte $16, $30, $27
00002Dr 2  0C 3C 1C     		.byte $0c, $3c, $1c
000030r 2               
000030r 2               
000030r 1               .include "struct.inc"
000030r 2               .struct	SPR_STRUCT
000030r 2               		pty		.byte					; PosiTion Y
000030r 2               		num		.byte					; Tile(8*8) number
000030r 2               		att		.byte					; Attribute (VertFlip|HorizonFlip|Prio|Unused(3)|PltNum(2))
000030r 2               		ptx		.byte					; PosiTion X
000030r 2               .endstruct
000030r 2               
000030r 2               
000030r 2               .struct	SPR_TBL
000030r 2               		spr		.tag SPR_STRUCT 64
000030r 2               .endstruct
000030r 2               
000030r 1               .include "map_data.inc"
000030r 2               ; MAP_DATA[stage][map_num][index]
000030r 2               
000030r 2               STAGE_ARR:
000030r 2  rr rr        	.addr MAP_ARR_11
000032r 2  rr rr        	.addr MAP_ARR_12
000034r 2               
000034r 2               MAP_ARR_11:
000034r 2  rr rr        	.addr MAP_11_1
000036r 2  rr rr        	.addr MAP_11_2
000038r 2  FF FF        	.addr $ffff
00003Ar 2               
00003Ar 2               MAP_ARR_12:
00003Ar 2  rr rr        	.addr MAP_12_1
00003Cr 2  FF FF        	.addr $ffff
00003Er 2               
00003Er 2               MAP_11_1:
00003Er 2  BD           	.byte $bd
00003Fr 2  42           	.byte 'B'
000040r 2  00 00        	.byte %00000000, %00000000
000042r 2  90 42        	.byte (GET_OBJ_POS $0, $3), 'B'
000044r 2  A5 42        	.byte (GET_OBJ_POS $5, $2), 'B'
000046r 2  78 42        	.byte (GET_OBJ_POS $8, $5), 'B'
000048r 2  49 42        	.byte (GET_OBJ_POS $9, $8), 'B'
00004Ar 2  79 51        	.byte (GET_OBJ_POS $9, $5), 'Q'
00004Cr 2  4A 51        	.byte (GET_OBJ_POS $a, $8), 'Q'
00004Er 2  7A 42        	.byte (GET_OBJ_POS $a, $5), 'B'
000050r 2  4B 42        	.byte (GET_OBJ_POS $b, $8), 'B'
000052r 2  7B 51        	.byte (GET_OBJ_POS $b, $5), 'Q'
000054r 2  7C 42        	.byte (GET_OBJ_POS $c, $5), 'B'
000056r 2  FE           	.byte OBJMAP_NEXT
000057r 2  C0 00        	.byte (GET_OBJ_POS $0, $0), 0
000059r 2  B0 00        	.byte (GET_OBJ_POS $0, $1), 0
00005Br 2  C1 00        	.byte (GET_OBJ_POS $1, $0), 0
00005Dr 2  B1 00        	.byte (GET_OBJ_POS $1, $1), 0
00005Fr 2  72 42        	.byte (GET_OBJ_POS $2, $5), 'B'
000061r 2  FF           	.byte OBJMAP_END
000062r 2               
000062r 2               MAP_11_2:
000062r 2  BD           	.byte $bd
000063r 2  42           	.byte 'B'
000064r 2  00 00        	.byte %00000000, %00000000
000066r 2  70 51        	.byte (GET_OBJ_POS $0, $5), 'Q'
000068r 2  60 51        	.byte (GET_OBJ_POS $0, $6), 'Q'
00006Ar 2  50 42        	.byte (GET_OBJ_POS $0, $7), 'B'
00006Cr 2  71 51        	.byte (GET_OBJ_POS $1, $5), 'Q'
00006Er 2  61 51        	.byte (GET_OBJ_POS $1, $6), 'Q'
000070r 2  51 51        	.byte (GET_OBJ_POS $1, $7), 'Q'
000072r 2  72 51        	.byte (GET_OBJ_POS $2, $5), 'Q'
000074r 2  73 51        	.byte (GET_OBJ_POS $3, $5), 'Q'
000076r 2  FF           	.byte OBJMAP_END
000077r 2               
000077r 2               MAP_12_1:
000077r 2  BD           	.byte $bd
000078r 2  42           	.byte 'B'
000079r 2  10 00        	.byte %00010000, %00000000
00007Br 2  A0 42        	.byte (GET_OBJ_POS $0, $2), 'B'
00007Dr 2  90 42        	.byte (GET_OBJ_POS $0, $3), 'B'
00007Fr 2  80 42        	.byte (GET_OBJ_POS $0, $4), 'B'
000081r 2  70 42        	.byte (GET_OBJ_POS $0, $5), 'B'
000083r 2  60 42        	.byte (GET_OBJ_POS $0, $6), 'B'
000085r 2  50 42        	.byte (GET_OBJ_POS $0, $7), 'B'
000087r 2  40 42        	.byte (GET_OBJ_POS $0, $8), 'B'
000089r 2  30 42        	.byte (GET_OBJ_POS $0, $9), 'B'
00008Br 2  20 42        	.byte (GET_OBJ_POS $0, $a), 'B'
00008Dr 2  10 42        	.byte (GET_OBJ_POS $0, $b), 'B'
00008Fr 2  00 42        	.byte (GET_OBJ_POS $0, $c), 'B'
000091r 2  01 00        	.byte (GET_OBJ_POS $1, $c), 0
000093r 2  02 00        	.byte (GET_OBJ_POS $2, $c), 0
000095r 2  03 00        	.byte (GET_OBJ_POS $3, $c), 0
000097r 2  04 00        	.byte (GET_OBJ_POS $4, $c), 0
000099r 2  05 00        	.byte (GET_OBJ_POS $5, $c), 0
00009Br 2  8B 51        	.byte (GET_OBJ_POS $b, $4), 'Q'
00009Dr 2  8C 51        	.byte (GET_OBJ_POS $c, $4), 'Q'
00009Fr 2  8D 51        	.byte (GET_OBJ_POS $d, $4), 'Q'
0000A1r 2  8E 51        	.byte (GET_OBJ_POS $e, $4), 'Q'
0000A3r 2  8F 51        	.byte (GET_OBJ_POS $f, $4), 'Q'
0000A5r 2  FE           	.byte OBJMAP_NEXT
0000A6r 2  A2 42        	.byte (GET_OBJ_POS $2, $2), 'B'
0000A8r 2  A4 42        	.byte (GET_OBJ_POS $4, $2), 'B'
0000AAr 2  94 42        	.byte (GET_OBJ_POS $4, $3), 'B'
0000ACr 2  A6 42        	.byte (GET_OBJ_POS $6, $2), 'B'
0000AEr 2  96 42        	.byte (GET_OBJ_POS $6, $3), 'B'
0000B0r 2  86 42        	.byte (GET_OBJ_POS $6, $4), 'B'
0000B2r 2  A8 42        	.byte (GET_OBJ_POS $8, $2), 'B'
0000B4r 2  98 42        	.byte (GET_OBJ_POS $8, $3), 'B'
0000B6r 2  88 42        	.byte (GET_OBJ_POS $8, $4), 'B'
0000B8r 2  78 42        	.byte (GET_OBJ_POS $8, $5), 'B'
0000BAr 2  7A 42        	.byte (GET_OBJ_POS $a, $5), 'B'
0000BCr 2  AC 42        	.byte (GET_OBJ_POS $c, $2), 'B'
0000BEr 2  9C 42        	.byte (GET_OBJ_POS $c, $3), 'B'
0000C0r 2  8C 42        	.byte (GET_OBJ_POS $c, $4), 'B'
0000C2r 2  7C 42        	.byte (GET_OBJ_POS $c, $5), 'B'
0000C4r 2  AE 42        	.byte (GET_OBJ_POS $e, $2), 'B'
0000C6r 2  9E 42        	.byte (GET_OBJ_POS $e, $3), 'B'
0000C8r 2  8E 42        	.byte (GET_OBJ_POS $e, $4), 'B'
0000CAr 2  FE           	.byte OBJMAP_NEXT
0000CBr 2  A0 42        	.byte (GET_OBJ_POS $0, $2), 'B'
0000CDr 2  90 42        	.byte (GET_OBJ_POS $0, $3), 'B'
0000CFr 2  A2 42        	.byte (GET_OBJ_POS $2, $2), 'B'
0000D1r 2  FF           	.byte OBJMAP_END
0000D2r 2               
0000D2r 2               
0000D2r 2               BROCK_ID_ARR:
0000D2r 2               	; 40 = %0100
0000D2r 2  rr rr        	.addr OBJ_SKY						; @ (or 0)
0000D4r 2  00 00        	.addr $0000							; A
0000D6r 2  rr rr        	.addr OBJ_BROCK						; B
0000D8r 2  00 00        	.addr $0000							; C
0000DAr 2  00 00        	.addr $0000							; D
0000DCr 2  00 00        	.addr $0000							; E
0000DEr 2  00 00        	.addr $0000							; F
0000E0r 2  rr rr        	.addr OBJ_GROUND					; G
0000E2r 2  00 00        	.addr $0000							; H
0000E4r 2  00 00        	.addr $0000							; I
0000E6r 2  00 00        	.addr $0000							; J
0000E8r 2  00 00        	.addr $0000							; K
0000EAr 2  00 00        	.addr $0000							; L
0000ECr 2  00 00        	.addr $0000							; M
0000EEr 2  00 00        	.addr $0000							; N
0000F0r 2  00 00        	.addr $0000							; O
0000F2r 2               	; 50 = %0101
0000F2r 2  00 00        	.addr $0000							; P
0000F4r 2  rr rr        	.addr OBJ_QBROCK					; Q
0000F6r 2  00 00        	.addr $0000							; R
0000F8r 2  00 00        	.addr $0000							; S
0000FAr 2  00 00        	.addr $0000							; T
0000FCr 2  00 00        	.addr $0000							; U
0000FEr 2  00 00        	.addr $0000							; V
000100r 2  00 00        	.addr $0000							; W
000102r 2  00 00        	.addr $0000							; X
000104r 2  00 00        	.addr $0000							; Y
000106r 2  00 00        	.addr $0000							; Z
000108r 2  00 00        	.addr $0000							; [
00010Ar 2  00 00        	.addr $0000							; \
00010Cr 2  00 00        	.addr $0000							; ]
00010Er 2  rr rr        	.addr OBJ_COIN						; ^
000110r 2  00 00        	.addr $0000							; _
000112r 2               	; 60 = %0110
000112r 2  00 00        	.addr $0000							; `
000114r 2  00 00        	.addr $0000							; a
000116r 2  00 00        	.addr $0000							; b
000118r 2  00 00        	.addr $0000							; c
00011Ar 2  00 00        	.addr $0000							; d
00011Cr 2  00 00        	.addr $0000							; e
00011Er 2  00 00        	.addr $0000							; f
000120r 2  00 00        	.addr $0000							; g
000122r 2  00 00        	.addr $0000							; h
000124r 2  00 00        	.addr $0000							; i
000126r 2  00 00        	.addr $0000							; j
000128r 2  00 00        	.addr $0000							; k
00012Ar 2  00 00        	.addr $0000							; l
00012Cr 2  00 00        	.addr $0000							; m
00012Er 2  00 00        	.addr $0000							; n
000130r 2  00 00        	.addr $0000							; o
000132r 2               	; 70 = %0111
000132r 2  00 00        	.addr $0000							; p
000134r 2  00 00        	.addr $0000							; q
000136r 2  00 00        	.addr $0000							; r
000138r 2  00 00        	.addr $0000							; s
00013Ar 2  00 00        	.addr $0000							; t
00013Cr 2  00 00        	.addr $0000							; u
00013Er 2  00 00        	.addr $0000							; v
000140r 2  00 00        	.addr $0000							; w
000142r 2  00 00        	.addr $0000							; x
000144r 2  00 00        	.addr $0000							; y
000146r 2  00 00        	.addr $0000							; z
000148r 2  00 00        	.addr $0000							; {
00014Ar 2  00 00        	.addr $0000							; |
00014Cr 2  00 00        	.addr $0000							; }
00014Er 2  00 00        	.addr $0000							; ~
000150r 2               
000150r 2               
000150r 2               OBJ_SKY:
000150r 2  00 00        	.byte $00, $00
000152r 2  00 00        	.byte $00, $00
000154r 2               
000154r 2               OBJ_QBROCK:
000154r 2  90 91        	.byte $90, $91
000156r 2  92 93        	.byte $92, $93
000158r 2               
000158r 2               OBJ_BROCK:
000158r 2  94 94        	.byte $94, $94
00015Ar 2  95 95        	.byte $95, $95
00015Cr 2               
00015Cr 2               OBJ_COIN:
00015Cr 2  84 85        	.byte $84, $85
00015Er 2  86 87        	.byte $86, $87
000160r 2               
000160r 2               OBJ_GROUND:
000160r 2  80 81        	.byte $80, $81
000162r 2  82 83        	.byte $82, $83
000164r 2               
000164r 2               
000164r 1               
000164r 1               .code									; ----- code -----
000164r 1               
000164r 1               .include "joypad.asm"
000164r 2               .scope Joypad
000164r 2               
000164r 2               BTN_A									= %10000000
000164r 2               BTN_B									= %01000000
000164r 2               BTN_S									= %00100000
000164r 2               BTN_T									= %00010000
000164r 2               BTN_U									= %00001000
000164r 2               BTN_D									= %00000100
000164r 2               BTN_L									= %00000010
000164r 2               BTN_R									= %00000001
000164r 2               
000164r 2               .ZeroPage
00001Er 2  00           joy1					: .byte 0
00001Fr 2  00           joy2					: .byte 0
000020r 2  00           joy1_prev				: .byte 0
000021r 2  00           joy2_prev				: .byte 0
000022r 2  00           joy1_pushstart			: .byte 0
000023r 2  00           joy2_pushstart			: .byte 0
000024r 2               
000024r 2               
000024r 2               ;*------------------------------------------------------------------------------
000024r 2               ; Get Joypad data (including prev and newly pushed btn)
000024r 2               ; @PARAMS		None
000024r 2               ; @CLOBBERS		A
000024r 2               ; @RETURNS		None
000024r 2               ;*------------------------------------------------------------------------------
000024r 2               
000024r 2               .code									; ----- code -----
000164r 2               
000164r 2               .proc _getJoyData
000164r 2               		; set prev
000164r 2  A5 rr        		lda Joypad::joy1
000166r 2  85 rr        		sta Joypad::joy1_prev
000168r 2  A5 rr        		lda Joypad::joy2
00016Ar 2  85 rr        		sta Joypad::joy2_prev
00016Cr 2               
00016Cr 2  20 rr rr     		jsr Joypad::_readJoy
00016Fr 2               
00016Fr 2  A5 rr        		lda Joypad::joy1
000171r 2  29 0A        		and #Joypad::BTN_U|Joypad::BTN_L				; Compare Up and Left...
000173r 2  4A           		lsr
000174r 2  25 rr        		and Joypad::joy1						; to Down and Right
000176r 2  F0 0A        		beq @GET_PUSHSTART_BTN
000178r 2               		; Use previous frame's directions
000178r 2  A5 rr        		lda Joypad::joy1
00017Ar 2  45 rr        		eor Joypad::joy1_prev
00017Cr 2  29 F0        		and #%11110000
00017Er 2  45 rr        		eor Joypad::joy1_prev
000180r 2  85 rr        		sta Joypad::joy1
000182r 2               
000182r 2               @GET_PUSHSTART_BTN:
000182r 2               		; set pushstart
000182r 2  A5 rr        		lda Joypad::joy1_prev
000184r 2  49 FF        		eor #%11111111
000186r 2  25 rr        		and Joypad::joy1
000188r 2  85 rr        		sta Joypad::joy1_pushstart
00018Ar 2  A5 rr        		lda Joypad::joy2_prev
00018Cr 2  49 FF        		eor #%11111111
00018Er 2  25 rr        		and Joypad::joy2
000190r 2  85 rr        		sta Joypad::joy2_pushstart
000192r 2               
000192r 2  60           		rts
000193r 2               		; ------------------------------
000193r 2               .endproc
000193r 2               
000193r 2               
000193r 2               ;*------------------------------------------------------------------------------
000193r 2               ; Read controller
000193r 2               ; @PARAMS		None
000193r 2               ; @CLOBBERS		A
000193r 2               ; @RETURNS		None
000193r 2               ;*------------------------------------------------------------------------------
000193r 2               
000193r 2               .code									; ----- code -----
000193r 2               
000193r 2               .proc _readJoy
000193r 2               		; Init controller & Set a ring counter
000193r 2  A9 01        		lda #1
000195r 2  8D 16 40     		sta JOYPAD1
000198r 2  85 rr        		sta Joypad::joy2						; ring counter
00019Ar 2  4A           		lsr								; A = 0
00019Br 2  8D 16 40     		sta JOYPAD1
00019Er 2               
00019Er 2               @READ_JOY_LOOP:
00019Er 2  AD 16 40     		lda JOYPAD1
0001A1r 2  29 03        		and #%00000011
0001A3r 2  C9 01        		cmp #$01						; A - 1 = A + 0xff; if A > 0 then Carry=1
0001A5r 2  26 rr        		rol Joypad::joy1						; Carry -> Bit0; Bit7 -> Carry
0001A7r 2  AD 17 40     		lda JOYPAD2
0001AAr 2  29 03        		and #%00000011
0001ACr 2  C9 01        		cmp #$01
0001AEr 2  26 rr        		rol Joypad::joy2
0001B0r 2  90 EC        		bcc @READ_JOY_LOOP				; CarryON -> end
0001B2r 2  60           		rts
0001B3r 2               		; ------------------------------
0001B3r 2               .endproc
0001B3r 2               
0001B3r 2               
0001B3r 2               .endscope
0001B3r 2               
0001B3r 1               .include "macro.asm"
0001B3r 2               ; ------------------------------------------------------------------------------
0001B3r 2               ; Load array
0001B3r 2               ; A = Arr[X][Y]
0001B3r 2               ; @PARAMS		ADDR: Array Address
0001B3r 2               ; @PARAMS		X Y: index (Access Arr[x][y])
0001B3r 2               ; @CLOBBERS		tmp6 addr_tmp1
0001B3r 2               ; ------------------------------------------------------------------------------
0001B3r 2               
0001B3r 2               .code									; ----- code -----
0001B3r 2               
0001B3r 2               .macro ldarr addr
0001B3r 2               		.if !(.blank(addr))
0001B3r 2               			sty tmp6						; save Y
0001B3r 2               			txa
0001B3r 2               			asl								; ×2（アドレスが16bitなのでARR[x][y]のxが+1 => 読み込むアドレスは+2する必要がある
0001B3r 2               			tay								; アドレッシングに使うためYレジスタへ
0001B3r 2               			lda addr, y						; Low
0001B3r 2               			sta addr_tmp1+0
0001B3r 2               			lda addr+1, y					; High
0001B3r 2               			sta addr_tmp1+1
0001B3r 2               			ldy tmp6						; restore Y
0001B3r 2               			lda (addr_tmp1), y
0001B3r 2               		.else
0001B3r 2               			.error "Arg addr in macro ldarr is wrong."
0001B3r 2               		.endif
0001B3r 2               .endmacro
0001B3r 2               
0001B3r 2               
0001B3r 2               ; ------------------------------------------------------------------------------
0001B3r 2               ; Calculate Negative Numbers
0001B3r 2               ; ------------------------------------------------------------------------------
0001B3r 2               
0001B3r 2               .code									; ----- code -----
0001B3r 2               
0001B3r 2               .macro cnn
0001B3r 2               		eor #$ff
0001B3r 2               		add #$01
0001B3r 2               .endmacro
0001B3r 2               
0001B3r 2               
0001B3r 2               ; ------------------------------------------------------------------------------
0001B3r 2               ; Addition
0001B3r 2               ; This Macro only supports Immediate/Zeropage/Absolute addressing.
0001B3r 2               ; Other addressing modes are not optimized for speed.
0001B3r 2               ; Other addressing usage: add a, {$00, x} / add a, {($00), y}
0001B3r 2               ; @PARAMS		arg1: register or Address
0001B3r 2               ; @PARAMS		arg2
0001B3r 2               ; ------------------------------------------------------------------------------
0001B3r 2               
0001B3r 2               .code									; ----- code -----
0001B3r 2               
0001B3r 2               .macro add arg1, arg2
0001B3r 2               		.if (.paramcount = 1)
0001B3r 2               			; arg1: val
0001B3r 2               			; add #3 / add $80
0001B3r 2               			clc
0001B3r 2               			adc arg1
0001B3r 2               		.elseif (.paramcount = 2)
0001B3r 2               			; arg1: target
0001B3r 2               			; arg2: val
0001B3r 2               			.if (.match({arg1}, a))
0001B3r 2               				; add a, #3 / add a, $80
0001B3r 2               				clc
0001B3r 2               				adc arg2
0001B3r 2               			.elseif (.match({arg1}, x))
0001B3r 2               				; add x, ??
0001B3r 2               				.if (\
0001B3r 2               					.match(.left(1, {arg2}), #) &&\
0001B3r 2               					.right(.tcount({arg2})-1, {arg2}) <= 7\
0001B3r 2               				)
0001B3r 2               					; add x, #0~7
0001B3r 2               					.repeat (.right(.tcount({arg2})-1, {arg2}))
0001B3r 2               						inx
0001B3r 2               					.endrepeat
0001B3r 2               				.else
0001B3r 2               					pha
0001B3r 2               					txa
0001B3r 2               					clc
0001B3r 2               					adc arg2
0001B3r 2               					tax
0001B3r 2               					pla
0001B3r 2               				.endif
0001B3r 2               			.elseif (.match({arg1}, y))
0001B3r 2               				; add y, ??
0001B3r 2               				.if (\
0001B3r 2               					.match(.left(1, {arg2}), #) &&\
0001B3r 2               					.right(.tcount({arg2})-1, {arg2}) <= 7\
0001B3r 2               				)
0001B3r 2               					; add y, #0~7
0001B3r 2               					.repeat (.right(.tcount ({arg2})-1, {arg2}))
0001B3r 2               						iny
0001B3r 2               					.endrepeat
0001B3r 2               				.else
0001B3r 2               					pha
0001B3r 2               					tya
0001B3r 2               					clc
0001B3r 2               					adc arg2
0001B3r 2               					tay
0001B3r 2               					pla
0001B3r 2               				.endif
0001B3r 2               			.endif
0001B3r 2               		.else
0001B3r 2               			.error "Args in macro add are wrong."
0001B3r 2               		.endif
0001B3r 2               .endmacro
0001B3r 2               
0001B3r 2               
0001B3r 2               ; ------------------------------------------------------------------------------
0001B3r 2               ; Subtraction
0001B3r 2               ; See macro add for comments
0001B3r 2               ; @PARAMS		arg1: register or Address
0001B3r 2               ; @PARAMS		arg2
0001B3r 2               ; ------------------------------------------------------------------------------
0001B3r 2               
0001B3r 2               .code									; ----- code -----
0001B3r 2               
0001B3r 2               .macro sub arg1, arg2
0001B3r 2               		.if (.paramcount = 1)
0001B3r 2               			sec
0001B3r 2               			sbc arg1
0001B3r 2               		.elseif (.paramcount = 2 && .match({arg1}, a))
0001B3r 2               			sec
0001B3r 2               			sbc arg2
0001B3r 2               		.elseif (.paramcount = 2 && .match({arg1}, x))
0001B3r 2               			.if (\
0001B3r 2               				.match(.left(1, {arg2}), #) &&\
0001B3r 2               				.right(.tcount({arg2})-1, {arg2}) <= 7\
0001B3r 2               			)
0001B3r 2               				.repeat (.right(.tcount({arg2})-1, {arg2}))
0001B3r 2               					dex
0001B3r 2               				.endrepeat
0001B3r 2               			.else
0001B3r 2               				pha
0001B3r 2               				txa
0001B3r 2               				sec
0001B3r 2               				sbc arg2
0001B3r 2               				tax
0001B3r 2               				pla
0001B3r 2               			.endif
0001B3r 2               		.elseif (.paramcount = 2 && .match({arg1}, y))
0001B3r 2               			.if (\
0001B3r 2               				.match(.left(1, {arg2}), #) &&\
0001B3r 2               				.right(.tcount({arg2})-1, {arg2}) <= 7\
0001B3r 2               			)
0001B3r 2               				.repeat (.right(.tcount ({arg2})-1, {arg2}))
0001B3r 2               					dey
0001B3r 2               				.endrepeat
0001B3r 2               			.else
0001B3r 2               				pha
0001B3r 2               				tya
0001B3r 2               				sec
0001B3r 2               				sbc arg2
0001B3r 2               				tay
0001B3r 2               				pla
0001B3r 2               			.endif
0001B3r 2               		.else
0001B3r 2               			.error "Args in macro sub are wrong."
0001B3r 2               		.endif
0001B3r 2               .endmacro
0001B3r 2               
0001B3r 2               
0001B3r 2               ;*------------------------------------------------------------------------------
0001B3r 2               ; Light shift
0001B3r 2               ; arg1 <<= c
0001B3r 2               ; @PARAMS		c: default=#1
0001B3r 2               ;*------------------------------------------------------------------------------
0001B3r 2               
0001B3r 2               .code									; ----- code -----
0001B3r 2               
0001B3r 2               .macro shl c
0001B3r 2               		.if (.blank(c))
0001B3r 2               			asl
0001B3r 2               		.elseif (.match(.left(1, {c}), #))
0001B3r 2               			.repeat	(.right(.tcount ({c})-1, {c}))
0001B3r 2               				asl
0001B3r 2               			.endrepeat
0001B3r 2               		.else
0001B3r 2               			.error "Arg \"c\" in macro shl is wrong."
0001B3r 2               		.endif
0001B3r 2               .endmacro
0001B3r 2               
0001B3r 2               
0001B3r 2               ;*------------------------------------------------------------------------------
0001B3r 2               ; Right shift
0001B3r 2               ; arg1 >>= c
0001B3r 2               ; @PARAMS		c: default=#1
0001B3r 2               ;*------------------------------------------------------------------------------
0001B3r 2               
0001B3r 2               .code									; ----- code -----
0001B3r 2               
0001B3r 2               .macro shr c
0001B3r 2               		.if (.blank(c))
0001B3r 2               			lsr
0001B3r 2               		.elseif (.match(.left(1, {c}), #))
0001B3r 2               			.repeat	(.right(.tcount ({c})-1, {c}))
0001B3r 2               				lsr
0001B3r 2               			.endrepeat
0001B3r 2               		.else
0001B3r 2               			.error "Arg \"c\" in macro shr is wrong."
0001B3r 2               		.endif
0001B3r 2               .endmacro
0001B3r 2               
0001B3r 2               
0001B3r 2               ;*------------------------------------------------------------------------------
0001B3r 2               ; Arithmetic left shift
0001B3r 2               ;! Deprecated (Not shortened)
0001B3r 2               ; A >>= c
0001B3r 2               ; @PARAMS		c: default=1
0001B3r 2               ;*------------------------------------------------------------------------------
0001B3r 2               
0001B3r 2               .code									; ----- code -----
0001B3r 2               
0001B3r 2               .macro ashl c
0001B3r 2               		cmp #%1000_0000
0001B3r 2               		php								; Save carry
0001B3r 2               		.if (.blank(c))
0001B3r 2               			; ashl
0001B3r 2               			shl #2
0001B3r 2               		.elseif (.match(.left(1, {c}), #))
0001B3r 2               			; ashl #4
0001B3r 2               			shl #((.right(.tcount ({c})-1, {c})) + 1)
0001B3r 2               		.else
0001B3r 2               			.error "Arg \"c\" in macro ashl is wrong."
0001B3r 2               		.endif
0001B3r 2               		plp
0001B3r 2               		ror								; a /= 2, carry into bit7
0001B3r 2               .endmacro
0001B3r 2               
0001B3r 2               
0001B3r 2               ;*------------------------------------------------------------------------------
0001B3r 2               ; Arithmetic right shift
0001B3r 2               ; A >>= c
0001B3r 2               ; @PARAMS		c: default=1
0001B3r 2               ;
0001B3r 2               ; To ASR a memory location
0001B3r 2               ; (From http://wiki.nesdev.com/w/index.php/Synthetic_instructions#Arithmetic_shift_right)
0001B3r 2               ; 	lda addr		; Copy memory into A
0001B3r 2               ; 	asl				; Copy sign bit of A into carry (shorter than CMP)
0001B3r 2               ; 	ror addr
0001B3r 2               ;*------------------------------------------------------------------------------
0001B3r 2               
0001B3r 2               .code									; ----- code -----
0001B3r 2               
0001B3r 2               .macro ashr c
0001B3r 2               		.if (.blank(c))
0001B3r 2               			; ashr
0001B3r 2               			cmp #%1000_0000				; Bit7 into carry
0001B3r 2               			ror							; Shift carry into Bit7
0001B3r 2               		.elseif (.match(.left(1, {c}), #))
0001B3r 2               			; ashr #4
0001B3r 2               			.repeat (.right(.tcount ({c})-1, {c}))
0001B3r 2               				cmp #%1000_0000
0001B3r 2               				ror
0001B3r 2               			.endrepeat
0001B3r 2               		.else
0001B3r 2               			.error "Arg \"c\" in macro ashr is wrong."
0001B3r 2               		.endif
0001B3r 2               .endmacro
0001B3r 2               
0001B3r 2               
0001B3r 2               
0001B3r 2               .macro tfrPlt
0001B3r 2               		; Transfar pallete
0001B3r 2               		lda #>PLT_TABLE_ADDR
0001B3r 2               		sta PPU_ADDR
0001B3r 2               		lda #<PLT_TABLE_ADDR			; Addr lo = 0
0001B3r 2               		sta PPU_ADDR
0001B3r 2               		tax								; X = 0
0001B3r 2               :
0001B3r 2               		ldy #3
0001B3r 2               		lda #$22						; under ground -> #$0f
0001B3r 2               		sta PPU_DATA
0001B3r 2               :
0001B3r 2               		lda DEFAULT_PLT, x				; under ground -> UNDER_GROUND_PLT
0001B3r 2               		sta PPU_DATA
0001B3r 2               		inx
0001B3r 2               		dey
0001B3r 2               		bne :-
0001B3r 2               		cpx #$3*8
0001B3r 2               		bcc :--
0001B3r 2               
0001B3r 2               		lda #$23
0001B3r 2               		sta PPU_ADDR
0001B3r 2               		lda #$c0
0001B3r 2               		sta PPU_ADDR
0001B3r 2               		lda #$ff
0001B3r 2               		sta PPU_DATA
0001B3r 2               		sta PPU_DATA
0001B3r 2               		sta PPU_DATA
0001B3r 2               		sta PPU_DATA
0001B3r 2               		sta PPU_DATA
0001B3r 2               		sta PPU_DATA
0001B3r 2               		sta PPU_DATA
0001B3r 2               		sta PPU_DATA
0001B3r 2               .endmacro
0001B3r 2               
0001B3r 1               .include "subfunc.asm"			; インクルードが必要ないような，深い階層で使われる関数群
0001B3r 2               .scope Subfunc
0001B3r 2               
0001B3r 2               ;*------------------------------------------------------------------------------
0001B3r 2               ; Restore PPU setting
0001B3r 2               ; @PARAMS		None
0001B3r 2               ; @CLOBBERS		A
0001B3r 2               ; @RETURNS		None
0001B3r 2               ;*------------------------------------------------------------------------------
0001B3r 2               
0001B3r 2               .code									; ----- code -----
0001B3r 2               
0001B3r 2               .proc _restorePPUSet
0001B3r 2  A5 rr        		lda ppu_ctrl1_cpy
0001B5r 2  8D 00 20     		sta PPU_CTRL1
0001B8r 2  A5 rr        		lda ppu_ctrl2_cpy
0001BAr 2  8D 01 20     		sta PPU_CTRL2
0001BDr 2  60           		rts
0001BEr 2               		; ------------------------------
0001BEr 2               .endproc
0001BEr 2               
0001BEr 2               
0001BEr 2               
0001BEr 2               ;*------------------------------------------------------------------------------
0001BEr 2               ; Set scroll position & change disp
0001BEr 2               ; Use during NMI or executing raster scroll.
0001BEr 2               ; @PARAMS		None
0001BEr 2               ; @CLOBBERS		A
0001BEr 2               ; @RETURNS		None
0001BEr 2               ;*------------------------------------------------------------------------------
0001BEr 2               
0001BEr 2               .code									; ----- code -----
0001BEr 2               
0001BEr 2               .proc _setScroll
0001BEr 2               		; lda is_scroll_locked
0001BEr 2               		; bne @EXIT
0001BEr 2               
0001BEr 2  A5 rr        		lda scroll_x
0001C0r 2  8D 05 20     		sta PPU_SCROLL
0001C3r 2  A9 00        		lda #0
0001C5r 2  8D 05 20     		sta PPU_SCROLL
0001C8r 2               
0001C8r 2  A5 rr        		lda ppu_ctrl1_cpy
0001CAr 2  29 FE        		and #%1111_1110
0001CCr 2  05 rr        		ora main_disp
0001CEr 2  85 rr        		sta ppu_ctrl1_cpy
0001D0r 2  8D 00 20     		sta PPU_CTRL1
0001D3r 2               
0001D3r 2               @EXIT:
0001D3r 2  60           		rts
0001D4r 2               		; ------------------------------
0001D4r 2               .endproc
0001D4r 2               
0001D4r 2               
0001D4r 2               ;*------------------------------------------------------------------------------
0001D4r 2               ; Wait starting vblank
0001D4r 2               ; @PARAMS		None
0001D4r 2               ; @CLOBBERS		None
0001D4r 2               ; @RETURNS		None
0001D4r 2               ;*------------------------------------------------------------------------------
0001D4r 2               
0001D4r 2               .code									; ----- code -----
0001D4r 2               
0001D4r 2               .proc _waitVblank
0001D4r 2  2C 02 20     		bit $2002
0001D7r 2  10 FB        		bpl _waitVblank
0001D9r 2  60           		rts
0001DAr 2               		; ------------------------------
0001DAr 2               .endproc
0001DAr 2               
0001DAr 2               
0001DAr 2               ;*------------------------------------------------------------------------------
0001DAr 2               ; Disp status text
0001DAr 2               ; @PARAMS		None
0001DAr 2               ; @CLOBBERS		A X Y
0001DAr 2               ; @RETURNS		None
0001DAr 2               ;*------------------------------------------------------------------------------
0001DAr 2               
0001DAr 2               .code									; ----- code -----
0001DAr 2               
0001DAr 2               .proc _dispStatus
0001DAr 2  A6 rr        		ldx bg_buff_pointer
0001DCr 2  A0 1F        		ldy #(@TEXT_END - @TEXT)
0001DEr 2               @STORE_PPU_DATA_LOOP:
0001DEr 2  BD rr rr     		lda @TEXT, x
0001E1r 2  F0 07        		beq @END_STORE
0001E3r 2  9D 49 01     		sta bg_buff, x
0001E6r 2  E8           		inx
0001E7r 2  88           		dey
0001E8r 2  D0 F4        		bne @STORE_PPU_DATA_LOOP
0001EAr 2               @END_STORE:
0001EAr 2  86 rr        		stx bg_buff_pointer
0001ECr 2  60           		rts
0001EDr 2               		; ------------------------------
0001EDr 2               
0001EDr 2               .rodata									; ----- data -----
000000r 2               @TEXT:
000000r 2  FE 20 22     		.byte PPU_VERTICAL_MODE
000003r 2               		ADDR_BG_BE 2, 1, 0
000003r 2  53 43 4F 52  		.byte "SCORE XXXXXX  C:YY  TIME ZZZ"
000007r 2  45 20 58 58  
00000Br 2  58 58 58 58  
00001Fr 2               @TEXT_END:
00001Fr 2               
00001Fr 2               .endproc
00001Fr 2               
00001Fr 2               
00001Fr 2               ;*------------------------------------------------------------------------------
00001Fr 2               ; Sleep for one frame
00001Fr 2               ; @PARAMS		None
00001Fr 2               ; @CLOBBERS		A
00001Fr 2               ; @RETURNS		None (A = 1)
00001Fr 2               ;*------------------------------------------------------------------------------
00001Fr 2               
00001Fr 2               .proc _sleepOneFrame
00001Fr 2  A9 00        		lda #0
000021r 2  85 rr        		sta is_processing_main
000023r 2               :
000023r 2  A5 rr        		lda is_processing_main
000025r 2  F0 FC        		beq :-
000027r 2               
000027r 2  60           		rts
000028r 2               		; ------------------------------
000028r 2               .endproc
000028r 2               
000028r 2               
000028r 2               .endscope
000028r 2               
000028r 1               .include "draw_map.asm"
000028r 2               .include "draw_map_macro.asm"
000028r 3               .code									; ----- code -----
0001EDr 3               
0001EDr 3               ;*------------------------------------------------------------------------------
0001EDr 3               ; Transfar obj data (8*8) to BG map buff($04XX/$05XX)
0001EDr 3               ; @PARAMS		X: Block ID
0001EDr 3               ; @CLOBBERS		A X Y
0001EDr 3               ; @RETURNS		None (Y: 3)
0001EDr 3               ;*------------------------------------------------------------------------------
0001EDr 3               
0001EDr 3               .macro trfToBgMapBuf
0001EDr 3               		lda BROCK_ID_ARR+LO, x
0001EDr 3               		sta addr_tmp2+LO
0001EDr 3               		lda BROCK_ID_ARR+HI, x
0001EDr 3               		sta addr_tmp2+HI
0001EDr 3               
0001EDr 3               		ldx bg_map_buff_index
0001EDr 3               
0001EDr 3               		ldy #0
0001EDr 3               		lda (addr_tmp2), y
0001EDr 3               		sta bg_map_buff+0, x
0001EDr 3               
0001EDr 3               		iny
0001EDr 3               		lda (addr_tmp2), y
0001EDr 3               		sta bg_map_buff+($0d*2), x
0001EDr 3               
0001EDr 3               		inx
0001EDr 3               
0001EDr 3               		iny
0001EDr 3               		lda (addr_tmp2), y
0001EDr 3               		sta bg_map_buff+0, x
0001EDr 3               
0001EDr 3               		iny
0001EDr 3               		lda (addr_tmp2), y
0001EDr 3               		sta bg_map_buff+($0d*2), x
0001EDr 3               
0001EDr 3               		inx
0001EDr 3               
0001EDr 3               		stx bg_map_buff_index
0001EDr 3               .endmacro
0001EDr 3               
0001EDr 3               
0001EDr 3               ;*------------------------------------------------------------------------------
0001EDr 3               ; Increment row_counter
0001EDr 3               ; @PARAMS		None
0001EDr 3               ; @CLOBBERS		Y
0001EDr 3               ; @RETURNS		None (Y: row_counter)
0001EDr 3               ;*------------------------------------------------------------------------------
0001EDr 3               
0001EDr 3               .macro incRowCounter
0001EDr 3               		.local @NO_OVF_ROW_CNT
0001EDr 3               
0001EDr 3               		ldy DrawMap::row_counter
0001EDr 3               		iny
0001EDr 3               		cpy #$10
0001EDr 3               		bne @NO_OVF_ROW_CNT
0001EDr 3               
0001EDr 3               		ldy #0
0001EDr 3               		inc DrawMap::map_buff_num
0001EDr 3               @NO_OVF_ROW_CNT:
0001EDr 3               		sty DrawMap::row_counter
0001EDr 3               .endmacro
0001EDr 3               
0001EDr 3               
0001EDr 3               ;*------------------------------------------------------------------------------
0001EDr 3               ; index = 0xff
0001EDr 3               ; @PARAMS		None
0001EDr 3               ; @CLOBBERS		Y
0001EDr 3               ; @RETURNS		None (Y: 0xff)
0001EDr 3               ;*------------------------------------------------------------------------------
0001EDr 3               
0001EDr 3               .macro initIndex
0001EDr 3               		ldy #NEGATIVE 1
0001EDr 3               		sty DrawMap::index
0001EDr 3               .endmacro
0001EDr 3               
0001EDr 3               
0001EDr 3               ;*------------------------------------------------------------------------------
0001EDr 3               ; Fill blocks (store to bg buff)
0001EDr 3               ; @PARAMS		None
0001EDr 3               ; @CLOBBERS		A X Y
0001EDr 3               ; @RETURNS		None (A = X)
0001EDr 3               ;*------------------------------------------------------------------------------
0001EDr 3               
0001EDr 3               .macro fillBlocks
0001EDr 3               		.local @LOOP
0001EDr 3               
0001EDr 3               		lda addr_tmp2+LO
0001EDr 3               		and #BYT_GET_LO
0001EDr 3               		sta addr_tmp2+LO
0001EDr 3               
0001EDr 3               		ldx #0
0001EDr 3               		ldy #0
0001EDr 3               @LOOP:
0001EDr 3               		lda fill_block_arr, y
0001EDr 3               		sta (addr_tmp2, x)
0001EDr 3               
0001EDr 3               		lda addr_tmp2+LO
0001EDr 3               		add #$10
0001EDr 3               		sta addr_tmp2+LO
0001EDr 3               
0001EDr 3               		iny
0001EDr 3               		cpy #$d
0001EDr 3               		bne @LOOP
0001EDr 3               .endmacro
0001EDr 3               
0001EDr 3               
0001EDr 3               ;*------------------------------------------------------------------------------
0001EDr 3               ; fill ground (store to fill buff)
0001EDr 3               ; @PARAMS		None
0001EDr 3               ; @CLOBBERS		A X Y
0001EDr 3               ; @RETURNS		None
0001EDr 3               ;*------------------------------------------------------------------------------
0001EDr 3               
0001EDr 3               .macro ramFillGround
0001EDr 3               		.local @FILL_SKY_LOOP1
0001EDr 3               		.local @FILL_SKY_LOOP1_END
0001EDr 3               		.local @FILL_GROUND_LOOP
0001EDr 3               		.local @FILL_GROUND_LOOP_END
0001EDr 3               		.local @FILL_SKY_LOOP2
0001EDr 3               		.local @END_FILL_GROUND
0001EDr 3               
0001EDr 3               		ldy #0
0001EDr 3               
0001EDr 3               		lda (DrawMap::map_addr), y
0001EDr 3               		and #BYT_GET_LO
0001EDr 3               		sta DrawMap::fill_ground_end
0001EDr 3               
0001EDr 3               		lda (DrawMap::map_addr), y
0001EDr 3               		shr #4
0001EDr 3               		sta DrawMap::fill_ground_start
0001EDr 3               
0001EDr 3               
0001EDr 3               		lda #0
0001EDr 3               		tax
0001EDr 3               @FILL_SKY_LOOP1:
0001EDr 3               		cpx DrawMap::fill_ground_start
0001EDr 3               		bcs @FILL_SKY_LOOP1_END
0001EDr 3               		sta fill_block_arr, x
0001EDr 3               		inx
0001EDr 3               		cpx #$d
0001EDr 3               		bcc @FILL_SKY_LOOP1
0001EDr 3               		bcs @END_FILL_GROUND
0001EDr 3               @FILL_SKY_LOOP1_END:
0001EDr 3               
0001EDr 3               		lda DrawMap::fill_ground_block
0001EDr 3               @FILL_GROUND_LOOP:
0001EDr 3               		cpx DrawMap::fill_ground_end
0001EDr 3               		bcs @FILL_GROUND_LOOP_END
0001EDr 3               		sta fill_block_arr, x
0001EDr 3               		inx
0001EDr 3               		cpx #$d
0001EDr 3               		bcc @FILL_GROUND_LOOP
0001EDr 3               		bcs @END_FILL_GROUND
0001EDr 3               @FILL_GROUND_LOOP_END:
0001EDr 3               
0001EDr 3               		lda #0
0001EDr 3               @FILL_SKY_LOOP2:
0001EDr 3               		sta fill_block_arr, x
0001EDr 3               		inx
0001EDr 3               		cpx #$d
0001EDr 3               		bcc @FILL_SKY_LOOP2
0001EDr 3               
0001EDr 3               @END_FILL_GROUND:
0001EDr 3               .endmacro
0001EDr 3               
0001EDr 3               
0001EDr 3               ;*------------------------------------------------------------------------------
0001EDr 3               ; fill blocks (store to fill buff)
0001EDr 3               ; @PARAMS		None
0001EDr 3               ; @CLOBBERS		A X Y
0001EDr 3               ; @RETURNS		None
0001EDr 3               ;*------------------------------------------------------------------------------
0001EDr 3               
0001EDr 3               .macro ramFillBlocks
0001EDr 3               		.local @FILL_BLOCK_LOOP_UPPER
0001EDr 3               		.local @NO_BLOCK1
0001EDr 3               		.local @FILL_BLOCK_LOOP_LOWER
0001EDr 3               		.local @NO_BLOCK2
0001EDr 3               
0001EDr 3               		ldy #1
0001EDr 3               		lda (DrawMap::map_addr), y		; ブロック種類
0001EDr 3               		sta DrawMap::fill_block
0001EDr 3               
0001EDr 3               
0001EDr 3               		iny
0001EDr 3               		lda (DrawMap::map_addr), y		; 上位
0001EDr 3               		shl #3							; 上位3ビット削除
0001EDr 3               
0001EDr 3               		ldx #0
0001EDr 3               @FILL_BLOCK_LOOP_UPPER:
0001EDr 3               		shl #1
0001EDr 3               		bcc @NO_BLOCK1
0001EDr 3               
0001EDr 3               		pha
0001EDr 3               		lda DrawMap::fill_block
0001EDr 3               		sta fill_block_arr, x
0001EDr 3               		pla
0001EDr 3               
0001EDr 3               @NO_BLOCK1:
0001EDr 3               		inx
0001EDr 3               		cpx #$5
0001EDr 3               		bcc @FILL_BLOCK_LOOP_UPPER
0001EDr 3               
0001EDr 3               
0001EDr 3               		iny
0001EDr 3               		lda (DrawMap::map_addr), y		; 下位
0001EDr 3               @FILL_BLOCK_LOOP_LOWER:
0001EDr 3               		shl #1
0001EDr 3               		bcc @NO_BLOCK2
0001EDr 3               
0001EDr 3               		pha
0001EDr 3               		lda DrawMap::fill_block
0001EDr 3               		sta fill_block_arr, x
0001EDr 3               		pla
0001EDr 3               
0001EDr 3               @NO_BLOCK2:
0001EDr 3               		inx
0001EDr 3               		cpx #$d
0001EDr 3               		bcc @FILL_BLOCK_LOOP_LOWER
0001EDr 3               .endmacro
0001EDr 3               
0001EDr 3               
0001EDr 3               ;*------------------------------------------------------------------------------
0001EDr 3               ; Load next map
0001EDr 3               ; @PARAMS		None
0001EDr 3               ; @CLOBBERS		Y
0001EDr 3               ; @RETURNS		None
0001EDr 3               ;*------------------------------------------------------------------------------
0001EDr 3               
0001EDr 3               .macro loadNextMap
0001EDr 3               		inc DrawMap::map_arr_num
0001EDr 3               		ldy DrawMap::map_arr_num		; Y = ++map_arr_num
0001EDr 3               		jsr _setMapAddr
0001EDr 3               .endmacro
0001EDr 3               
0001EDr 3               
0001EDr 3               ;*------------------------------------------------------------------------------
0001EDr 3               ; set BG addr (PPU)
0001EDr 3               ; @PARAMS		None
0001EDr 3               ; @CLOBBERS		A
0001EDr 3               ; @RETURNS		None
0001EDr 3               ;*------------------------------------------------------------------------------
0001EDr 3               
0001EDr 3               .macro setPpuBgAddr
0001EDr 3               		lda #0
0001EDr 3               		sta tmp1						; Start using tmp1
0001EDr 3               
0001EDr 3               		lda addr_tmp1+LO
0001EDr 3               		add #$40
0001EDr 3               		shl #1
0001EDr 3               		rol tmp1
0001EDr 3               		sta ppu_bg_addr+LO
0001EDr 3               
0001EDr 3               		lda addr_tmp1+HI				; 4 or 5
0001EDr 3               		and #BIT0
0001EDr 3               		shl #2							; 0 or 4
0001EDr 3               		ora #$20						; $20 or $24
0001EDr 3               		ora tmp1						; End using tmp1
0001EDr 3               		sta ppu_bg_addr+HI
0001EDr 3               .endmacro
0001EDr 3               
0001EDr 2               
0001EDr 2               .scope DrawMap
0001EDr 2               
0001EDr 2               .ZeroPage
000024r 2  00           map_buff_num			: .byte 0
000025r 2  00 00        map_arr_addr			: .addr 0
000027r 2  00 00        map_addr				: .addr 0		; Map obj/position data (-> data addr: ROM)
000029r 2  00           isend_draw_stage		: .byte 0
00002Ar 2  00           row_counter				: .byte 0		; Every time this prg executed -> increment
00002Br 2  00           index					: .byte 0		; index of map_addr
00002Cr 2  00           cnt_map_next			: .byte 0		; data (read from map_addr) = SP code(go next map) -> increment this counter
00002Dr 2  00           map_arr_num				: .byte 0
00002Er 2  00           fill_upper				: .byte 0
00002Fr 2  00           fill_lower				: .byte 0
000030r 2  00           fill_ground_block		: .byte 0
000031r 2  00           fill_block				: .byte 0
000032r 2  00           fill_ground_end			: .byte 0
000033r 2  00           fill_ground_start		: .byte 0
000034r 2               
000034r 2               
000034r 2               ;*------------------------------------------------------------------------------
000034r 2               ; Update one row
000034r 2               ; @PARAMS		None
000034r 2               ; @CLOBBERS		A X Y tmp1 tmp2 addr_tmp1 addr_tmp2
000034r 2               ; @RETURNS		None
000034r 2               /* main label
000034r 2               	@START:
000034r 2               	@GET_POS_AND_OBJ_LOOP:
000034r 2               	@END_OF_MAP:						-> goto nextlabel (@LOAD_NEXT_MAP)
000034r 2               	@LOAD_NEXT_MAP:						-> goto @GET_POS_AND_OBJ_LOOP
000034r 2               	@END_OF_STAGE:						-> goto nextlabel (@PREPARE_BG_MAP_BUF)
000034r 2               	@PREPARE_BG_MAP_BUF:
000034r 2               	@STORE_BG_MAP_BUF_LOOP:
000034r 2               */
000034r 2               ;*------------------------------------------------------------------------------
000034r 2               
000034r 2               .code									; ----- code -----
0001EDr 2               
0001EDr 2               .proc _updateOneLine
0001EDr 2  A5 rr        		lda DrawMap::isend_draw_stage
0001EFr 2  F0 01        		beq @START
0001F1r 2  60           		rts
0001F2r 2               		; ------------------------------
0001F2r 2               
0001F2r 2               @START:
0001F2r 2  A9 01        		lda #1
0001F4r 2  85 rr        		sta is_updated_map
0001F6r 2               
0001F6r 2  A4 rr C8 C0  		incRowCounter
0001FAr 2  10 D0 04 A0  
0001FEr 2  00 E6 rr 84  
000203r 2               
000203r 2  A5 rr        		lda DrawMap::map_buff_num
000205r 2  29 01        		and #BIT0
000207r 2  09 04        		ora #4
000209r 2  85 rr        		sta addr_tmp2+HI
00020Br 2               
00020Br 2  A5 rr        		lda DrawMap::row_counter
00020Dr 2  85 rr        		sta addr_tmp2+LO
00020Fr 2               
00020Fr 2  A5 rr 29 0F  		fillBlocks
000213r 2  85 rr A2 00  
000217r 2  A0 00 B9 3C  
00022Ar 2               
00022Ar 2  A4 rr        		ldy DrawMap::index
00022Cr 2               @GET_POS_AND_OBJ_LOOP:
00022Cr 2               		; ----------- get pos ----------
00022Cr 2  B1 rr        		lda (DrawMap::map_addr), y
00022Er 2  85 rr        		sta tmp1
000230r 2               
000230r 2               		; Check Special Code
000230r 2  C9 FE        		cmp #OBJMAP_NEXT
000232r 2  F0 38        		beq @LOAD_NEXT_MAP
000234r 2               
000234r 2  C9 FF        		cmp #OBJMAP_END
000236r 2  F0 25        		beq @END_OF_MAP
000238r 2               
000238r 2               		; Check if it can be updated
000238r 2  29 0F        		and #BYT_GET_LO
00023Ar 2  C5 rr        		cmp DrawMap::row_counter
00023Cr 2  D0 1A        		bne @GET_POS_AND_OBJ_LOOP_EXIT
00023Er 2               
00023Er 2  A5 rr        		lda DrawMap::map_buff_num
000240r 2  C5 rr        		cmp DrawMap::cnt_map_next		; Count OBJMAP_NEXT (is not reset until the stage changes)
000242r 2  D0 14        		bne @GET_POS_AND_OBJ_LOOP_EXIT
000244r 2               
000244r 2               		; -- Set addr of bg map buff ---
000244r 2  29 01        		and #BIT0
000246r 2  09 04        		ora #4
000248r 2  85 rr        		sta addr_tmp1+HI
00024Ar 2               
00024Ar 2               
00024Ar 2  A5 rr        		lda tmp1						; End using tmp1
00024Cr 2  85 rr        		sta addr_tmp1+LO
00024Er 2               
00024Er 2               		; ----------- get chr ----------
00024Er 2  C8           		iny
00024Fr 2  A2 00        		ldx #0
000251r 2  B1 rr        		lda (DrawMap::map_addr), y
000253r 2  81 rr        		sta (addr_tmp1, x)
000255r 2               
000255r 2  C8           		iny
000256r 2  D0 D4        		bne @GET_POS_AND_OBJ_LOOP		; Jmp
000258r 2               		; ------------------------------
000258r 2               
000258r 2               @GET_POS_AND_OBJ_LOOP_EXIT:
000258r 2  84 rr        		sty DrawMap::index
00025Ar 2  4C rr rr     		jmp @PREPARE_BG_MAP_BUF
00025Dr 2               		; ------------------------------
00025Dr 2               
00025Dr 2               
00025Dr 2               		; End of map data (Not end of stage)
00025Dr 2               @END_OF_MAP:
00025Dr 2  E6 rr A4 rr  		loadNextMap
000261r 2  20 rr rr     
000264r 2               
000264r 2  A5 rr        		lda DrawMap::map_addr+HI
000266r 2  C9 FF        		cmp #ENDCODE					; A = Addr Hi
000268r 2  F0 08        		beq @END_OF_STAGE
00026Ar 2               
00026Ar 2  A0 03        		ldy #3							; この後inyされてy(index) = 4に
00026Cr 2               
00026Cr 2               @LOAD_NEXT_MAP:
00026Cr 2  E6 rr        		inc DrawMap::cnt_map_next
00026Er 2  C8           		iny
00026Fr 2  4C rr rr     		jmp @GET_POS_AND_OBJ_LOOP
000272r 2               		; ------------------------------
000272r 2               
000272r 2               @END_OF_STAGE:
000272r 2  A0 00        		ldy #0
000274r 2  84 rr        		sty DrawMap::index
000276r 2  C8           		iny								; Y = 1
000277r 2  84 rr        		sty DrawMap::isend_draw_stage
000279r 2               
000279r 2               @PREPARE_BG_MAP_BUF:
000279r 2  A5 rr        		lda DrawMap::row_counter
00027Br 2  85 rr        		sta addr_tmp1+LO				; PosY = 0
00027Dr 2               
00027Dr 2  A5 rr        		lda DrawMap::map_buff_num
00027Fr 2  29 01        		and #BIT0
000281r 2  09 04        		ora #4
000283r 2  85 rr        		sta addr_tmp1+HI
000285r 2               
000285r 2  A9 00 85 rr  		setPpuBgAddr
000289r 2  A5 rr 18 69  
00028Dr 2  40 0A 26 rr  
00029Fr 2               
00029Fr 2               		; Store plt addr(ppu)
00029Fr 2  A5 rr        		lda addr_tmp1+LO				; posX
0002A1r 2  4A           		shr #1
0002A2r 2  18 69 C0     		add #$c0
0002A5r 2  85 rr        		sta plt_addr+LO
0002A7r 2               
0002A7r 2  A5 rr        		lda addr_tmp1+HI
0002A9r 2  29 01        		and #1
0002ABr 2  0A 0A        		shl #2
0002ADr 2  18 69 23     		add #$23
0002B0r 2  85 rr        		sta plt_addr+HI
0002B2r 2               
0002B2r 2  A0 00        		ldy #0
0002B4r 2  84 rr        		sty bg_map_buff_index
0002B6r 2               
0002B6r 2               @STORE_BG_MAP_BUF_LOOP:					; for (y = 0; y < $0d; y++)
0002B6r 2  98           		tya
0002B7r 2  0A 0A 0A 0A  		shl #4
0002BBr 2  A8           		tay
0002BCr 2  B1 rr        		lda (addr_tmp1), y
0002BEr 2               
0002BEr 2               		; prepare plt data -------------
0002BEr 2  84 rr        		sty tmp2						; (save counter) += $10
0002C0r 2  A4 rr        		ldy tmp1						; (save counter) += 1
0002C2r 2  48           		pha								; push
0002C3r 2  29 30        		and #BIT5|BIT4
0002C5r 2  AA           		tax								; X: plt num(bit4-5) : tmp (Start using)
0002C6r 2  A5 rr        		lda DrawMap::row_counter
0002C8r 2  29 01        		and #BIT0
0002CAr 2  85 rr        		sta tmp3
0002CCr 2  98           		tya
0002CDr 2  29 01        		and #BIT0
0002CFr 2  0A           		shl #1
0002D0r 2  05 rr        		ora tmp3
0002D2r 2  85 rr        		sta tmp3
0002D4r 2               
0002D4r 2               		; y /= 2 (Use @PLT0) -> MEMO: 短縮可能
0002D4r 2  98           		tya
0002D5r 2  4A           		shr #1
0002D6r 2  A8           		tay
0002D7r 2               
0002D7r 2  8A           		txa								; End using X (plt num)
0002D8r 2  A6 rr        		ldx tmp3
0002DAr 2               		/*
0002DAr 2               		PLT_DATA = BLOCK3|BLOCK2|BLOCK1|BLOCK0
0002DAr 2               		-------------------------------
0002DAr 2               		| BLOCK0(>>4) | BLOCK1(>>2) |
0002DAr 2               		| BLOCK2(0)   | BLOCK3(<<2) |
0002DAr 2               		-------------------------------
0002DAr 2               		*/
0002DAr 2  F0 09        		beq @BLOCK0
0002DCr 2  CA           		dex
0002DDr 2  F0 0D        		beq @BLOCK1
0002DFr 2  CA           		dex
0002E0r 2  F0 11        		beq @BLOCK2
0002E2r 2  CA           		dex
0002E3r 2  F0 0C        		beq @BLOCK3
0002E5r 2               @BLOCK0:
0002E5r 2  4A 4A 4A 4A  		shr #4
0002E9r 2  4C rr rr     		jmp @STORE_TO_PLT_BUFF
0002ECr 2               		; ------------------------------
0002ECr 2               @BLOCK1:
0002ECr 2  4A 4A        		shr #2
0002EEr 2  4C rr rr     		jmp @ADD_LEFT_BLOCK_PLT
0002F1r 2               		; ------------------------------
0002F1r 2               @BLOCK3:
0002F1r 2  0A 0A        		shl #2
0002F3r 2               @BLOCK2:
0002F3r 2               @ADD_LEFT_BLOCK_PLT:
0002F3r 2  19 34 01     		ora bg_plt_buff, y
0002F6r 2               @STORE_TO_PLT_BUFF:
0002F6r 2  99 34 01     		sta bg_plt_buff, y
0002F9r 2               
0002F9r 2  68           		pla								; pull
0002FAr 2  A4 rr        		ldy tmp2
0002FCr 2               
0002FCr 2  29 3F        		and #BIT5|BIT4|BIT3|BIT2|BIT1|BIT0
0002FEr 2  0A           		shl #1
0002FFr 2               
0002FFr 2  AA           		tax
000300r 2  BD rr rr 85  		trfToBgMapBuf
000304r 2  rr BD rr rr  
000308r 2  85 rr A6 rr  
000329r 2               
000329r 2  A4 rr        		ldy tmp1
00032Br 2  C8           		iny
00032Cr 2  84 rr        		sty tmp1
00032Er 2  C0 0D        		cpy #$0d
000330r 2  90 84        		bcc @STORE_BG_MAP_BUF_LOOP
000332r 2               
000332r 2  60           		rts
000333r 2               		;-------------------------------
000333r 2               .endproc
000333r 2               
000333r 2               ;*------------------------------------------------------------------------------
000333r 2               ; Set addr of stages
000333r 2               ; @PARAMS		Y: stage number
000333r 2               ; @CLOBBERS		A Y
000333r 2               ; @RETURNS		None (A = addr Hi)
000333r 2               ;*------------------------------------------------------------------------------
000333r 2               
000333r 2               .code									; ----- code -----
000333r 2               
000333r 2               .proc _setStageAddr
000333r 2  98           		tya
000334r 2  0A           		shl #1
000335r 2  A8           		tay
000336r 2               
000336r 2  B9 rr rr     		lda STAGE_ARR+LO, y
000339r 2  85 rr        		sta DrawMap::map_arr_addr+LO
00033Br 2  B9 rr rr     		lda STAGE_ARR+HI, y
00033Er 2  85 rr        		sta DrawMap::map_arr_addr+HI
000340r 2               
000340r 2  60           		rts
000341r 2               		; ------------------------------
000341r 2               .endproc
000341r 2               
000341r 2               
000341r 2               ;*------------------------------------------------------------------------------
000341r 2               ; Set addr of maps
000341r 2               ; @PARAMS		Y: map index
000341r 2               ; @CLOBBERS		A Y
000341r 2               ; @RETURNS		None
000341r 2               ;*------------------------------------------------------------------------------
000341r 2               
000341r 2               .code									; ----- code -----
000341r 2               
000341r 2               .proc _setMapAddr
000341r 2  98           		tya
000342r 2  0A           		shl #1
000343r 2  A8           		tay
000344r 2  48           		pha								; push y
000345r 2               
000345r 2  B1 rr        		lda (DrawMap::map_arr_addr), y
000347r 2  85 rr        		sta DrawMap::map_addr+LO
000349r 2  C8           		iny
00034Ar 2  B1 rr        		lda (DrawMap::map_arr_addr), y
00034Cr 2  85 rr        		sta DrawMap::map_addr+HI
00034Er 2               
00034Er 2               		; ffコードをこの関数の返値にして，この関数の外でマップ終了を判定しているが
00034Er 2               		; その前に@NO_EXIT以下の処理を行ってしまい，バグるため，ここで抜ける
00034Er 2               		; 直接@END_OF_STAGEにジャンプしてもOKなはずだが（マップ終了判定でジャンプするラベル）
00034Er 2               		; procを使っているため今は無理
00034Er 2  C9 FF        		cmp #ENDCODE
000350r 2  D0 05        		bne @NO_EXIT
000352r 2  68           		pla
000353r 2  A8           		tay
000354r 2  A9 FF        		lda #ENDCODE
000356r 2  60           		rts
000357r 2               		; ------------------------------
000357r 2               
000357r 2               @NO_EXIT:
000357r 2  A0 00 B1 rr  		ramFillGround
00035Br 2  29 0F 85 rr  
00035Fr 2  B1 rr 4A 4A  
000392r 2  A0 01 B1 rr  		ramFillBlocks
000396r 2  85 rr C8 B1  
00039Ar 2  rr 0A 0A 0A  
0003C1r 2               
0003C1r 2  A0 04        		ldy #4								; マクロ後inyでもy = 4
0003C3r 2  84 rr        		sty DrawMap::index
0003C5r 2               
0003C5r 2  68           		pla
0003C6r 2  A8           		tay
0003C7r 2               
0003C7r 2  60           		rts
0003C8r 2               		; ------------------------------
0003C8r 2               .endproc
0003C8r 2               
0003C8r 2               
0003C8r 2               ;*------------------------------------------------------------------------------
0003C8r 2               ; Change stage
0003C8r 2               ; @PARAMS		Y: Stage number
0003C8r 2               ; @CLOBBERS		A Y
0003C8r 2               ; @RETURNS		None
0003C8r 2               ;*------------------------------------------------------------------------------
0003C8r 2               
0003C8r 2               .proc _changeStage
0003C8r 2  A9 00        		lda #0
0003CAr 2  85 rr        		sta is_updated_map
0003CCr 2  20 rr rr     		jsr Subfunc::_sleepOneFrame
0003CFr 2               
0003CFr 2               		; Change bg color (black)
0003CFr 2  A9 3F        		lda #$3f
0003D1r 2  8D 06 20     		sta PPU_ADDR
0003D4r 2  A9 00        		lda #$00
0003D6r 2  8D 06 20     		sta PPU_ADDR
0003D9r 2  A9 0F        		lda #$0f
0003DBr 2  8D 07 20     		sta PPU_DATA
0003DEr 2  A9 3F        		lda #$3f
0003E0r 2  8D 06 20     		sta PPU_ADDR
0003E3r 2  A9 00        		lda #$00
0003E5r 2  8D 06 20     		sta PPU_ADDR
0003E8r 2               
0003E8r 2  A9 FF        		lda #$ff
0003EAr 2  85 rr        		sta DrawMap::row_counter
0003ECr 2               
0003ECr 2  A9 00        		lda #0
0003EEr 2  85 rr        		sta DrawMap::index
0003F0r 2  85 rr        		sta main_disp
0003F2r 2  85 rr        		sta DrawMap::cnt_map_next		; count ff
0003F4r 2  85 rr        		sta DrawMap::map_buff_num
0003F6r 2  85 rr        		sta DrawMap::isend_draw_stage
0003F8r 2  85 rr        		sta DrawMap::map_arr_num
0003FAr 2  85 rr        		sta scroll_x
0003FCr 2  85 rr        		sta ppu_ctrl2_cpy
0003FEr 2  8D 01 20     		sta PPU_CTRL2
000401r 2               
000401r 2  A9 47        		lda #'G'
000403r 2  85 rr        		sta DrawMap::fill_ground_block
000405r 2               
000405r 2  20 rr rr     		jsr DrawMap::_setStageAddr
000408r 2  A0 00        		ldy #0
00040Ar 2  20 rr rr     		jsr DrawMap::_setMapAddr
00040Dr 2               
00040Dr 2  A9 18        		lda #$18
00040Fr 2               @DISP_LOOP:
00040Fr 2  48           		pha
000410r 2  A9 01        		lda #1
000412r 2  85 rr        		sta is_updated_map
000414r 2  20 rr rr     		jsr DrawMap::_updateOneLine
000417r 2  20 rr rr     		jsr Subfunc::_sleepOneFrame
00041Ar 2  68           		pla
00041Br 2  38 E9 01     		sub #1
00041Er 2  D0 EF        		bne @DISP_LOOP
000420r 2               
000420r 2               		; Restore bg color
000420r 2  A9 3F        		lda #$3f
000422r 2  8D 06 20     		sta PPU_ADDR
000425r 2  A9 00        		lda #$00
000427r 2  8D 06 20     		sta PPU_ADDR
00042Ar 2  A9 22        		lda #$22
00042Cr 2  8D 07 20     		sta PPU_DATA
00042Fr 2  A9 3F        		lda #$3f
000431r 2  8D 06 20     		sta PPU_ADDR
000434r 2  A9 00        		lda #$00
000436r 2  8D 06 20     		sta PPU_ADDR
000439r 2               
000439r 2  20 rr rr     		jsr Subfunc::_setScroll
00043Cr 2               
00043Cr 2  A9 00        		lda #0
00043Er 2  85 rr        		sta is_updated_map
000440r 2  20 rr rr     		jsr Subfunc::_sleepOneFrame
000443r 2               
000443r 2  A9 1E        		lda #%00011110
000445r 2  85 rr        		sta ppu_ctrl2_cpy
000447r 2  20 rr rr     		jsr Subfunc::_restorePPUSet		; Display ON
00044Ar 2               
00044Ar 2  60           		rts
00044Br 2               		; ------------------------------
00044Br 2               
00044Br 2               .endproc
00044Br 2               
00044Br 2               
00044Br 2               .endscope
00044Br 2               
00044Br 1               .include "sprite.asm"
00044Br 2               /***************** メモ *****************
00044Br 2               
00044Br 2               キャラクター情報を，キャラクターごとにまとめる
00044Br 2               
00044Br 2               例：）クリボー
00044Br 2               アニメーションの数：２
00044Br 2               タイルインデックス
00044Br 2               タイル属性
00044Br 2               初期速度
00044Br 2               スプライト：
00044Br 2               	アニメーション
00044Br 2               	ジャンプ（空中）
00044Br 2               	やられた時
00044Br 2               	→ ファイヤー，スターでやられた時には
00044Br 2               	やられた時のスプライト＋向きを反転
00044Br 2               
00044Br 2               
00044Br 2               
00044Br 2               今後：
00044Br 2               あたり判定大きさ
00044Br 2               速度変化（ハンマーブロスなどのアニメーション）: この時地形判定不要？
00044Br 2               踏めるか，ファイヤー耐性は？
00044Br 2               
00044Br 2               
00044Br 2               
00044Br 2               ***************************************/
00044Br 2               
00044Br 2               
00044Br 2               
00044Br 2               CHR_ATTR:
00044Br 2  00 00 00 40  		.byte %0000_0000, %0000_0000, %0000_0000, %0100_0000		; standing
00044Fr 2  00 00 00 40  		.byte %0000_0000, %0000_0000, %0000_0000, %0100_0000		; walk1
000453r 2  00 00 00 40  		.byte %0000_0000, %0000_0000, %0000_0000, %0100_0000		; walk2
000457r 2  00 00 00 40  		.byte %0000_0000, %0000_0000, %0000_0000, %0100_0000		; walk3, fall
00045Br 2  00 00 00 40  		.byte %0000_0000, %0000_0000, %0000_0000, %0100_0000		; jumping
00045Fr 2               
00045Fr 2               CHR_ID:
00045Fr 2  3A 37 4F 4F  		.byte $3a, $37, $4f, $4f		; standing
000463r 2  32 33 34 35  		.byte $32, $33, $34, $35		; walk1
000467r 2  36 37 38 39  		.byte $36, $37, $38, $39		; walk2
00046Br 2  3A 37 3B 3C  		.byte $3a, $37, $3b, $3c		; walk3, falling
00046Fr 2  32 41 42 43  		.byte $32, $41, $42, $43		; jumping
000473r 2               
000473r 2               
000473r 2  00 00 00 40  PLAYER_STANDING_ATTR:		.byte %0000_0000, %0000_0000, %0000_0000, %0100_0000
000477r 2  00 00 00 00  PLAYER_WALK1_ATTR:			.byte %0000_0000, %0000_0000, %0000_0000, %0000_0000
00047Br 2  00 00 00 00  PLAYER_WALK2_ATTR:			.byte %0000_0000, %0000_0000, %0000_0000, %0000_0000
00047Fr 2  00 00 00 00  PLAYER_WALK3_FALLING_ATTR:	.byte %0000_0000, %0000_0000, %0000_0000, %0000_0000
000483r 2  00 00 00 00  PLAYER_JUMPING_ATTR:		.byte %0000_0000, %0000_0000, %0000_0000, %0000_0000
000487r 2  00 00 00 00  PLAYER_BRAKING_ATTR:		.byte %0000_0000, %0000_0000, %0000_0000, %0000_0000
00048Br 2               
00048Br 2  3A 37 4F 4F  PLAYER_STANDING:		.byte $3a, $37, $4f, $4f
00048Fr 2  32 33 34 35  PLAYER_WALK1:			.byte $32, $33, $34, $35
000493r 2  36 37 38 39  PLAYER_WALK2:			.byte $36, $37, $38, $39
000497r 2  3A 37 3B 3C  PLAYER_WALK3_FALLING:	.byte $3a, $37, $3b, $3c
00049Br 2  32 41 42 43  PLAYER_JUMPING:			.byte $32, $41, $42, $43
00049Fr 2  3D 3E 3F 40  PLAYER_BRAKING:			.byte $3d, $3e, $3f, $40
0004A3r 2               
0004A3r 2               
0004A3r 2               CHR_ATTR_TABLE:
0004A3r 2  rr rr        		.word PLAYER_STANDING_ATTR
0004A5r 2  rr rr rr rr  		.word PLAYER_WALK1_ATTR, PLAYER_WALK2_ATTR, PLAYER_WALK3_FALLING_ATTR
0004A9r 2  rr rr        
0004ABr 2  rr rr        		.word PLAYER_JUMPING_ATTR
0004ADr 2  rr rr        		.word PLAYER_BRAKING_ATTR
0004AFr 2               
0004AFr 2               CHR_ID_TABLE:
0004AFr 2  rr rr        		.word PLAYER_STANDING
0004B1r 2  rr rr rr rr  		.word PLAYER_WALK1, PLAYER_WALK2, PLAYER_WALK3_FALLING
0004B5r 2  rr rr        
0004B7r 2  rr rr        		.word PLAYER_JUMPING
0004B9r 2  rr rr        		.word PLAYER_BRAKING
0004BBr 2               
0004BBr 2               
0004BBr 2               MAX_SPD_L:
0004BBr 2  E8 D8        		.byte $e8, $d8
0004BDr 2               
0004BDr 2               MAX_SPD_R:
0004BDr 2  18 28        		.byte $18, $28
0004BFr 2               
0004BFr 2               AMOUNT_INC_SPD_L:
0004BFr 2  FF FE FD     		.byte $ff, $fe, $fd
0004C2r 2               
0004C2r 2               AMOUNT_INC_SPD_R:
0004C2r 2  01 02 03     		.byte $01, $02, $03
0004C5r 2               
0004C5r 2               
0004C5r 2               
0004C5r 2               .scope Sprite
0004C5r 2               
0004C5r 2               .code									; ----- code -----
0004C5r 2               
0004C5r 2               ;*------------------------------------------------------------------------------
0004C5r 2               ; Move sprite
0004C5r 2               ; @PARAMS		X: sprite id
0004C5r 2               ; @CLOBBERS		A Y tmp1
0004C5r 2               ; @RETURNS		None
0004C5r 2               ;*------------------------------------------------------------------------------
0004C5r 2               .proc _moveSprite
0004C5r 2               ; 		dex									; sprid=0のときスプライトは無なので，必ず1から始まる→0から始まるように修正
0004C5r 2               ; 		lda spr_velocity_x_arr, x
0004C5r 2               ; 		bne :+
0004C5r 2               ; 		sta scroll_amount
0004C5r 2               ; :
0004C5r 2               ; 		clc
0004C5r 2               ; 		adc spr_posX_arr, x
0004C5r 2               ; 		cmp #$f0
0004C5r 2               ; 		bcc :+
0004C5r 2               ; 		pha
0004C5r 2               ; 		lda spr_posX_tmp_arr, x
0004C5r 2               ; 		sec
0004C5r 2               ; 		sbc spr_posX_arr, x
0004C5r 2               ; 		tay								; move_dxを求める（移動量）
0004C5r 2               ; 		pla
0004C5r 2               ; 		cpy #$80
0004C5r 2               ; 		bcc :+
0004C5r 2               ; 		; posX < 0 && move_dx < 0
0004C5r 2               ; 		lda #0
0004C5r 2               ; :
0004C5r 2               
0004C5r 2               ; ; スクロールロック時の処理
0004C5r 2               ; 		ldy is_scroll_locked
0004C5r 2               ; 		bne @STORE_POSX
0004C5r 2               
0004C5r 2               ; 		cmp #PLAYER_MAX_POSX
0004C5r 2               ; 		bcs @MOVE_SCROLL
0004C5r 2               
0004C5r 2               ; @STORE_POSX:
0004C5r 2               ; 		cmp #($100-(PLAYER_WIDTH+PLAYER_PADDING))
0004C5r 2               ; 		bcc @STOP_MOVE
0004C5r 2               ; 		beq @STOP_MOVE
0004C5r 2               
0004C5r 2               ; 		lda #($100-(PLAYER_WIDTH+PLAYER_PADDING))
0004C5r 2               ; @STOP_MOVE:
0004C5r 2               ; 		sta spr_posX_arr, x
0004C5r 2               ; 		jmp @MOVE_Y
0004C5r 2               ; 		; ------------------------------
0004C5r 2               
0004C5r 2               ; @MOVE_SCROLL:
0004C5r 2               ; 		sub #PLAYER_MAX_POSX
0004C5r 2               ; 		sta scroll_amount
0004C5r 2               
0004C5r 2               ; 		lda #PLAYER_MAX_POSX
0004C5r 2               ; 		sta spr_posX_arr, x
0004C5r 2               
0004C5r 2               ; @MOVE_Y:
0004C5r 2               ; 		lda spr_posY_tmp_arr, x
0004C5r 2               ; 		sta spr_posY_arr, x
0004C5r 2               
0004C5r 2               ; 		rts
0004C5r 2               ; 		; ------------------------------
0004C5r 2               
0004C5r 2  CA           	dex									; sprid=0のときスプライトは無なので，必ず1から始まる→0から始まるように修正
0004C6r 2               
0004C6r 2               	; Y方向
0004C6r 2  BD rr rr     	lda spr_posY_tmp_arr, x
0004C9r 2  9D rr rr     	sta spr_posY_arr, x
0004CCr 2               
0004CCr 2               	; X方向
0004CCr 2  BD rr rr     	lda spr_posX_tmp_arr, x
0004CFr 2  C9 F8        	cmp #$f8
0004D1r 2  90 01        	bcc :+
0004D3r 2               	; マリオが左端を超えた時
0004D3r 2               	; lda #0
0004D3r 2               	; sta spr_posX_arr, x
0004D3r 2  60           	rts
0004D4r 2               	; ------------------------------
0004D4r 2               :
0004D4r 2               	; 右端チェック
0004D4r 2  A4 rr        	ldy is_scroll_locked
0004D6r 2  F0 0A        	beq :++
0004D8r 2               	; スクロールロック時
0004D8r 2  C9 F2        	cmp #($100-PLAYER_WIDTH-PLAYER_PADDING)
0004DAr 2  90 02        	bcc :+
0004DCr 2               	; 右端を超えた時
0004DCr 2  A9 F2        	lda #($100-PLAYER_WIDTH-PLAYER_PADDING)
0004DEr 2               :
0004DEr 2  9D rr rr     	sta spr_posX_arr, x
0004E1r 2  60           	rts
0004E2r 2               	; ------------------------------
0004E2r 2               :
0004E2r 2  C9 70        	cmp #PLAYER_MAX_POSX
0004E4r 2  90 09        	bcc :+
0004E6r 2               	; マリオが右端を超えた時
0004E6r 2  38 E9 70     	sub #PLAYER_MAX_POSX
0004E9r 2  85 rr        	sta scroll_amount
0004EBr 2  A9 70        	lda #PLAYER_MAX_POSX
0004EDr 2  D0 04        	bne :++
0004EFr 2               :
0004EFr 2  A0 00        	ldy #0
0004F1r 2  84 rr        	sty scroll_amount
0004F3r 2               :
0004F3r 2  9D rr rr     	sta spr_posX_arr, x
0004F6r 2               
0004F6r 2  60           	rts
0004F7r 2               	; ------------------------------
0004F7r 2               
0004F7r 2               .endproc
0004F7r 2               
0004F7r 2               
0004F7r 2               ;*------------------------------------------------------------------------------
0004F7r 2               ; 通常の向きでスプライトをバッファ転送する
0004F7r 2               ; @PARAMS		x: sprite id（-1された状態)
0004F7r 2               ; @PARAMS		y: buff index（ストアし始める最初のindex）
0004F7r 2               ; @PARAMS		tmp1: posY
0004F7r 2               ; @PARAMS		tmp2: posX
0004F7r 2               ; @CLOBBERS		A X Y
0004F7r 2               ; @RETURNS		None
0004F7r 2               ;*------------------------------------------------------------------------------
0004F7r 2               .proc _tfrSprToBuffNormal
0004F7r 2               		; Upper left
0004F7r 2  A5 rr        		lda tmp1
0004F9r 2  99 00 07     		sta CHR_BUFF+$0, y
0004FCr 2  99 04 07     		sta CHR_BUFF+$4, y
0004FFr 2  18 69 08     		add #8
000502r 2  99 08 07     		sta CHR_BUFF+$8, y
000505r 2  99 0C 07     		sta CHR_BUFF+$c, y
000508r 2               
000508r 2  A5 rr        		lda tmp2
00050Ar 2  99 03 07     		sta CHR_BUFF+$3, y
00050Dr 2  99 0B 07     		sta CHR_BUFF+$b, y
000510r 2  18 69 08     		add #8
000513r 2  99 07 07     		sta CHR_BUFF+$7, y
000516r 2  99 0F 07     		sta CHR_BUFF+$f, y
000519r 2               
000519r 2               
000519r 2  84 rr        		sty tmp_rgstY
00051Br 2  BD rr rr     		lda spr_anime_num, x
00051Er 2  AA           		tax
00051Fr 2               
00051Fr 2  A0 00        		ldy #0
000521r 2  84 rr 8A 0A  		ldarr CHR_ATTR_TABLE
000525r 2  A8 B9 rr rr  
000529r 2  85 rr B9 rr  
000534r 2  A4 rr        		ldy tmp_rgstY
000536r 2  99 02 07     		sta CHR_BUFF+$2, y
000539r 2  A0 01        		ldy #1
00053Br 2  84 rr 8A 0A  		ldarr CHR_ATTR_TABLE
00053Fr 2  A8 B9 rr rr  
000543r 2  85 rr B9 rr  
00054Er 2  A4 rr        		ldy tmp_rgstY
000550r 2  99 06 07     		sta CHR_BUFF+$6, y
000553r 2  A0 02        		ldy #2
000555r 2  84 rr 8A 0A  		ldarr CHR_ATTR_TABLE
000559r 2  A8 B9 rr rr  
00055Dr 2  85 rr B9 rr  
000568r 2  A4 rr        		ldy tmp_rgstY
00056Ar 2  99 0A 07     		sta CHR_BUFF+$a, y
00056Dr 2  A0 03        		ldy #3
00056Fr 2  84 rr 8A 0A  		ldarr CHR_ATTR_TABLE
000573r 2  A8 B9 rr rr  
000577r 2  85 rr B9 rr  
000582r 2  A4 rr        		ldy tmp_rgstY
000584r 2  99 0E 07     		sta CHR_BUFF+$e, y
000587r 2               
000587r 2  A0 00        		ldy #0
000589r 2  84 rr 8A 0A  		ldarr CHR_ID_TABLE
00058Dr 2  A8 B9 rr rr  
000591r 2  85 rr B9 rr  
00059Cr 2  A4 rr        		ldy tmp_rgstY
00059Er 2  99 01 07     		sta CHR_BUFF+$1, y
0005A1r 2  A0 01        		ldy #1
0005A3r 2  84 rr 8A 0A  		ldarr CHR_ID_TABLE
0005A7r 2  A8 B9 rr rr  
0005ABr 2  85 rr B9 rr  
0005B6r 2  A4 rr        		ldy tmp_rgstY
0005B8r 2  99 05 07     		sta CHR_BUFF+$5, y
0005BBr 2  A0 02        		ldy #2
0005BDr 2  84 rr 8A 0A  		ldarr CHR_ID_TABLE
0005C1r 2  A8 B9 rr rr  
0005C5r 2  85 rr B9 rr  
0005D0r 2  A4 rr        		ldy tmp_rgstY
0005D2r 2  99 09 07     		sta CHR_BUFF+$9, y
0005D5r 2  A0 03        		ldy #3
0005D7r 2  84 rr 8A 0A  		ldarr CHR_ID_TABLE
0005DBr 2  A8 B9 rr rr  
0005DFr 2  85 rr B9 rr  
0005EAr 2  A4 rr        		ldy tmp_rgstY
0005ECr 2  99 0D 07     		sta CHR_BUFF+$d, y
0005EFr 2               
0005EFr 2  60           		rts
0005F0r 2               		; ------------------------------
0005F0r 2               .endproc
0005F0r 2               
0005F0r 2               
0005F0r 2               ;*------------------------------------------------------------------------------
0005F0r 2               ; 左右反転してスプライトをバッファ転送する
0005F0r 2               ; @PARAMS		x: sprite id（-1された状態)
0005F0r 2               ; @PARAMS		y: buff index（ストアし始める最初のindex）
0005F0r 2               ; @PARAMS		tmp1: posY
0005F0r 2               ; @PARAMS		tmp2: posX
0005F0r 2               ; @CLOBBERS		A X Y
0005F0r 2               ; @RETURNS		None
0005F0r 2               ;*------------------------------------------------------------------------------
0005F0r 2               .proc _tfrSprToBuffFlipX
0005F0r 2  A5 rr        		lda tmp1
0005F2r 2  99 00 07     		sta CHR_BUFF+$0, y
0005F5r 2  99 04 07     		sta CHR_BUFF+$4, y
0005F8r 2  18 69 08     		add #8
0005FBr 2  99 08 07     		sta CHR_BUFF+$8, y
0005FEr 2  99 0C 07     		sta CHR_BUFF+$c, y
000601r 2               
000601r 2  A5 rr        		lda tmp2
000603r 2  99 07 07     		sta CHR_BUFF+$7, y
000606r 2  99 0F 07     		sta CHR_BUFF+$f, y
000609r 2  18 69 08     		add #8
00060Cr 2  99 03 07     		sta CHR_BUFF+$3, y
00060Fr 2  99 0B 07     		sta CHR_BUFF+$b, y
000612r 2               
000612r 2  84 rr        		sty tmp_rgstY
000614r 2  BD rr rr     		lda spr_anime_num, x
000617r 2  AA           		tax
000618r 2               
000618r 2  A0 00        		ldy #0
00061Ar 2  84 rr 8A 0A  		ldarr CHR_ATTR_TABLE
00061Er 2  A8 B9 rr rr  
000622r 2  85 rr B9 rr  
00062Dr 2  49 40        		eor #%0100_0000						; 左右反転
00062Fr 2  A4 rr        		ldy tmp_rgstY
000631r 2  99 02 07     		sta CHR_BUFF+$2, y
000634r 2  A0 01        		ldy #1
000636r 2  84 rr 8A 0A  		ldarr CHR_ATTR_TABLE
00063Ar 2  A8 B9 rr rr  
00063Er 2  85 rr B9 rr  
000649r 2  49 40        		eor #%0100_0000
00064Br 2  A4 rr        		ldy tmp_rgstY
00064Dr 2  99 06 07     		sta CHR_BUFF+$6, y
000650r 2  A0 02        		ldy #2
000652r 2  84 rr 8A 0A  		ldarr CHR_ATTR_TABLE
000656r 2  A8 B9 rr rr  
00065Ar 2  85 rr B9 rr  
000665r 2  49 40        		eor #%0100_0000
000667r 2  A4 rr        		ldy tmp_rgstY
000669r 2  99 0A 07     		sta CHR_BUFF+$a, y
00066Cr 2  A0 03        		ldy #3
00066Er 2  84 rr 8A 0A  		ldarr CHR_ATTR_TABLE
000672r 2  A8 B9 rr rr  
000676r 2  85 rr B9 rr  
000681r 2  49 40        		eor #%0100_0000
000683r 2  A4 rr        		ldy tmp_rgstY
000685r 2  99 0E 07     		sta CHR_BUFF+$e, y
000688r 2               
000688r 2  A0 00        		ldy #0
00068Ar 2  84 rr 8A 0A  		ldarr CHR_ID_TABLE
00068Er 2  A8 B9 rr rr  
000692r 2  85 rr B9 rr  
00069Dr 2  A4 rr        		ldy tmp_rgstY
00069Fr 2  99 01 07     		sta CHR_BUFF+$1, y
0006A2r 2  A0 01        		ldy #1
0006A4r 2  84 rr 8A 0A  		ldarr CHR_ID_TABLE
0006A8r 2  A8 B9 rr rr  
0006ACr 2  85 rr B9 rr  
0006B7r 2  A4 rr        		ldy tmp_rgstY
0006B9r 2  99 05 07     		sta CHR_BUFF+$5, y
0006BCr 2  A0 02        		ldy #2
0006BEr 2  84 rr 8A 0A  		ldarr CHR_ID_TABLE
0006C2r 2  A8 B9 rr rr  
0006C6r 2  85 rr B9 rr  
0006D1r 2  A4 rr        		ldy tmp_rgstY
0006D3r 2  99 09 07     		sta CHR_BUFF+$9, y
0006D6r 2  A0 03        		ldy #3
0006D8r 2  84 rr 8A 0A  		ldarr CHR_ID_TABLE
0006DCr 2  A8 B9 rr rr  
0006E0r 2  85 rr B9 rr  
0006EBr 2  A4 rr        		ldy tmp_rgstY
0006EDr 2  99 0D 07     		sta CHR_BUFF+$d, y
0006F0r 2               
0006F0r 2  60           		rts
0006F1r 2               		; ------------------------------
0006F1r 2               .endproc
0006F1r 2               
0006F1r 2               
0006F1r 2               ;*------------------------------------------------------------------------------
0006F1r 2               ; 上下反転してスプライトをバッファ転送する
0006F1r 2               ; @PARAMS		x: sprite id（-1された状態)
0006F1r 2               ; @PARAMS		y: buff index（ストアし始める最初のindex）
0006F1r 2               ; @PARAMS		tmp1: posY
0006F1r 2               ; @PARAMS		tmp2: posX
0006F1r 2               ; @CLOBBERS		A X Y
0006F1r 2               ; @RETURNS		None
0006F1r 2               ;*------------------------------------------------------------------------------
0006F1r 2               .proc _tfrSprToBuffFlipY
0006F1r 2               	; Lower left
0006F1r 2  A5 rr        	lda tmp1
0006F3r 2  18 69 08     	add #8
0006F6r 2  99 00 07     	sta CHR_BUFF+$0, y
0006F9r 2  BD rr rr     	lda CHR_ID, x
0006FCr 2  99 01 07     	sta CHR_BUFF+$1, y
0006FFr 2  BD rr rr     	lda CHR_ATTR, x
000702r 2  99 02 07     	sta CHR_BUFF+$2, y
000705r 2  A5 rr        	lda tmp2
000707r 2  99 03 07     	sta CHR_BUFF+$3, y
00070Ar 2               	; Lower right
00070Ar 2  E8           	inx
00070Br 2  A5 rr        	lda tmp1
00070Dr 2  18 69 08     	add #8
000710r 2  99 04 07     	sta CHR_BUFF+$4, y
000713r 2  BD rr rr     	lda CHR_ID, x
000716r 2  99 05 07     	sta CHR_BUFF+$5, y
000719r 2  BD rr rr     	lda CHR_ATTR, x
00071Cr 2  99 06 07     	sta CHR_BUFF+$6, y
00071Fr 2  A5 rr        	lda tmp2
000721r 2  18 69 08     	add #8
000724r 2  99 07 07     	sta CHR_BUFF+$7, y
000727r 2               	; Upper left
000727r 2  E8           	inx
000728r 2  A5 rr        	lda tmp1
00072Ar 2  99 08 07     	sta CHR_BUFF+$8, y
00072Dr 2  BD rr rr     	lda CHR_ID, x
000730r 2  99 09 07     	sta CHR_BUFF+$9, y
000733r 2  BD rr rr     	lda CHR_ATTR, x
000736r 2  99 0A 07     	sta CHR_BUFF+$a, y
000739r 2  A5 rr        	lda tmp2
00073Br 2  99 0B 07     	sta CHR_BUFF+$b, y
00073Er 2               	; Upper right
00073Er 2  E8           	inx
00073Fr 2  A5 rr        	lda tmp1
000741r 2  99 0C 07     	sta CHR_BUFF+$c, y
000744r 2  BD rr rr     	lda CHR_ID, x
000747r 2  99 0D 07     	sta CHR_BUFF+$d, y
00074Ar 2  BD rr rr     	lda CHR_ATTR, x
00074Dr 2  99 0E 07     	sta CHR_BUFF+$e, y
000750r 2  A5 rr        	lda tmp2
000752r 2  18 69 08     	add #8
000755r 2  99 0F 07     	sta CHR_BUFF+$f, y
000758r 2  60           	rts
000759r 2               	; ------------------------------
000759r 2               .endproc
000759r 2               
000759r 2               
000759r 2               ;*------------------------------------------------------------------------------
000759r 2               ; transfar to chr buff
000759r 2               ; @PARAMS		X: sprite id, Y = BUFF index
000759r 2               ; @CLOBBERS		A X Y
000759r 2               ; @RETURNS		None
000759r 2               ;*------------------------------------------------------------------------------
000759r 2               .proc _tfrToChrBuff
000759r 2  E0 00        		cpx #0								; sprid=0 -> スプライトなし
00075Br 2  F0 20        		beq @EXIT
00075Dr 2  CA           		dex									; spridを0～に変更
00075Er 2               
00075Er 2  C8           		iny									; 0スプライトの分空けるため(buff indexを0に設定しても0スプライトを上書きしない)
00075Fr 2  98           		tya
000760r 2  0A 0A        		shl #2
000762r 2  A8           		tay
000763r 2               
000763r 2  BD rr rr     		lda spr_posY_arr, x
000766r 2  85 rr        		sta tmp1							; posY
000768r 2  BD rr rr     		lda spr_posX_arr, x
00076Br 2  85 rr        		sta tmp2							; posX
00076Dr 2               
00076Dr 2  BD rr rr     		lda spr_attr_arr, x
000770r 2  29 01        		and #BIT0
000772r 2  F0 06        		beq :+
000774r 2  20 rr rr     		jsr _tfrSprToBuffNormal
000777r 2  4C rr rr     		jmp @EXIT
00077Ar 2               :
00077Ar 2  20 rr rr     		jsr _tfrSprToBuffFlipX
00077Dr 2               
00077Dr 2               @EXIT:
00077Dr 2  60           		rts
00077Er 2               		; ------------------------------
00077Er 2               .endproc
00077Er 2               
00077Er 2               
00077Er 2               .endscope
00077Er 2               
00077Er 1               .include "player_move.asm"
00077Er 2               .scope Player							; スコープ名注意！
00077Er 2               
00077Er 2               DOWN_SPEED_LIMIT = $04					; 落下の最高速度
00077Er 2               VER_FORCE_DECIMAL_PART_DATA:			; 加速度の増加値
00077Er 2  20 20 1E 28  		.byte $20, $20, $1e, $28, $28
000782r 2  28           
000783r 2               VER_FALL_FORCE_DATA:					; 降下時の加速度
000783r 2  70 70 60 90  		.byte $70, $70, $60, $90, $90
000787r 2  90           
000788r 2               INITIAL_VER_SPEED_DATA:					; 初速度(v0)
000788r 2  FC FC FC FB  		.byte $fc, $fc, $fc, $fb, $fb
00078Cr 2  FB           
00078Dr 2               INITIAL_VER_FORCE_DATA:					; 初期加速度(a)
00078Dr 2  00 00 00 00  		.byte $00, $00, $00, $00, $00
000791r 2  00           
000792r 2               
000792r 2               .ZeroPage
000034r 2  00           is_fly: 					.byte 0		; 空中にいるか
000035r 2  00           is_jumping:					.byte 0		; ジャンプ中か（ジャンプ後の下降中もフラグオン）
000036r 2  00           is_collision_down:			.byte 0		; collisionDownの関数を通ったか（床に触れたか）
000037r 2  00           player_current_screen:		.byte 0		; プレイヤーのいる画面番号
000038r 2  00           player_actual_pos_left:		.byte 0		; 画面上の座標ではなく，実際の座標
000039r 2  00           player_actual_pos_right:	.byte 0
00003Ar 2  00           player_pos_top:				.byte 0
00003Br 2  00           player_pos_bottom:			.byte 0
00003Cr 2  00           player_offset_flags:		.byte 0		; ずれのフラグ（bit1: X方向，bit0: Y方向）
00003Dr 2  00           player_collision_flags:		.byte 0		; マリオ周辺のブロックフラグ（ブロックがあれば1, bit3-0は左上，右上，左下，右下の順）
00003Er 2  00           player_block_pos_X:			.byte 0		; ブロック単位での座標
00003Fr 2  00           player_block_pos_Y:			.byte 0
000040r 2  00           player_block_pos_right:		.byte 0
000041r 2  00           player_block_pos_bottom:	.byte 0
000042r 2               
000042r 2               .code
000792r 2               
000792r 2               ;*------------------------------------------------------------------------------
000792r 2               ; player physics
000792r 2               ; @PARAMS		None
000792r 2               ; @CLOBBERS		A X
000792r 2               ; @RETURNS		None
000792r 2               ;*------------------------------------------------------------------------------
000792r 2               .proc _physicsX
000792r 2  A9 00        		lda #0							; 初期化
000794r 2  8D rr rr     		sta spr_velocity_x_arr+$0
000797r 2               
000797r 2  A5 rr        		lda Joypad::joy1
000799r 2  29 02        		and #Joypad::BTN_L
00079Br 2  D0 51        		bne @ACCELERATE_LEFT
00079Dr 2  A5 rr        		lda Joypad::joy1
00079Fr 2  29 01        		and #Joypad::BTN_R
0007A1r 2  F0 03        		beq @DEC_ACCELERATION
0007A3r 2  4C rr rr     		jmp @ACCELERATE_RIGHT
0007A6r 2               
0007A6r 2               @DEC_ACCELERATION:						; 減速
0007A6r 2  AD rr rr     		lda spr_float_velocity_x_arr+$0
0007A9r 2  F0 40        		beq @EXIT1
0007ABr 2  30 1E        		bmi @INC_SPEED
0007ADr 2               
0007ADr 2               		; 右向きに進んでいるときの減速
0007ADr 2  38 E9 01     		sub #1							; 減速
0007B0r 2  8D rr rr     		sta spr_float_velocity_x_arr+$0
0007B3r 2  F0 36        		beq @EXIT1						; 速度0なら終了
0007B5r 2               
0007B5r 2  AA           		tax
0007B6r 2  4A 4A 4A 4A  		shr #4
0007BAr 2  8D rr rr     		sta spr_velocity_x_arr+$0
0007BDr 2               
0007BDr 2  E0 10        		cpx #$10
0007BFr 2  B0 2A        		bcs @EXIT1
0007C1r 2  E0 0A        		cpx #$0A
0007C3r 2  90 26        		bcc @EXIT1
0007C5r 2  EE rr rr     		inc spr_velocity_x_arr+$0
0007C8r 2  4C rr rr     		jmp @EXIT1	; ------------------
0007CBr 2               
0007CBr 2               @INC_SPEED:
0007CBr 2               		; 左向きに進んでいるときの減速
0007CBr 2  18 69 01     		add #1
0007CEr 2  8D rr rr     		sta spr_float_velocity_x_arr+$0
0007D1r 2  F0 18        		beq @EXIT1
0007D3r 2               
0007D3r 2  AA           		tax
0007D4r 2  4A 4A 4A 4A  		shr #4
0007D8r 2  09 F0        		ora #%11110000					; 上位4ビットを埋める（負の数にする）
0007DAr 2  8D rr rr     		sta spr_velocity_x_arr+$0
0007DDr 2               
0007DDr 2  E0 F0        		cpx #$f0
0007DFr 2  90 07        		bcc @EXIT2
0007E1r 2  E0 FA        		cpx #$fA
0007E3r 2  B0 03        		bcs @EXIT2
0007E5r 2  CE rr rr     		dec spr_velocity_x_arr+$0
0007E8r 2               @EXIT2:
0007E8r 2  EE rr rr     		inc spr_velocity_x_arr+$0		; 負の向きは求めた速度+1（小数の速度がfbの時→速度はffではなく0になってほしい）
0007EBr 2               @EXIT1:
0007EBr 2  4C rr rr     		jmp EXIT	; ------------------
0007EEr 2               
0007EEr 2               @ACCELERATE_LEFT:						; 左向きに加速度を上昇させる
0007EEr 2  A2 00        		ldx #0							; AMOUNT_INC_SPD_L[]のindex決定処理
0007F0r 2  A5 rr        		lda Joypad::joy1
0007F2r 2  29 40        		and #Joypad::BTN_B
0007F4r 2  F0 01        		beq :+
0007F6r 2  E8           		inx
0007F7r 2               :
0007F7r 2  BD rr rr     		lda AMOUNT_INC_SPD_L, x			; 加速度を足す
0007FAr 2  18 6D rr rr  		add spr_float_velocity_x_arr+$0
0007FEr 2  DD rr rr     		cmp MAX_SPD_L, x
000801r 2  10 05        		bpl :+
000803r 2  E8           		inx
000804r 2  38           		sec
000805r 2  FD rr rr     		sbc AMOUNT_INC_SPD_L, x			; 足した加速度よりも大きな加速度で引く（加速度が負に）
000808r 2               :
000808r 2  8D rr rr     		sta spr_float_velocity_x_arr+$0
00080Br 2  85 rr        		sta tmp1
00080Dr 2  AD rr rr     		lda spr_decimal_part_velocity_x_arr+$0
000810r 2  09 F0        		ora #%1111_0000
000812r 2  18 65 rr     		add tmp1
000815r 2  85 rr        		sta tmp1
000817r 2  29 0F        		and #BYT_GET_LO
000819r 2  8D rr rr     		sta spr_decimal_part_velocity_x_arr+$0
00081Cr 2  A5 rr        		lda tmp1
00081Er 2  C9 00        		cmp #0
000820r 2  10 08        		bpl :+
000822r 2  4A 4A 4A 4A  		shr #4							; 加速度が負のとき（左に進んでて，右に入力がある場合）
000826r 2  09 F0        		ora #%11110000					; 上位4ビットを埋める（負の数にする）
000828r 2  D0 04        		bne :++
00082Ar 2               :
00082Ar 2  4A 4A 4A 4A  		shr #4							; 加速度が正のとき
00082Er 2               :
00082Er 2  8D rr rr     		sta spr_velocity_x_arr+$0
000831r 2               		; 向きの更新
000831r 2  F0 14        		beq :++							; 速度が0のとき向きフラグを更新しない（今の向きを継続利用）
000833r 2  30 0A        		bmi :+
000835r 2  A9 01        		lda #%0000_0001					; 速度が正のとき向きフラグを1に
000837r 2  0D rr rr     		ora spr_attr_arr+$0
00083Ar 2  8D rr rr     		sta spr_attr_arr+$0
00083Dr 2  D0 08        		bne :++
00083Fr 2               :
00083Fr 2  AD rr rr     		lda spr_attr_arr+$0				; 速度が負のとき向きフラグを0に
000842r 2  29 FE        		and #%1111_1110
000844r 2  8D rr rr     		sta spr_attr_arr+$0
000847r 2               :
000847r 2               		; 速度調整
000847r 2  A5 rr        		lda tmp1
000849r 2  E0 F0        		cpx #$f0
00084Br 2  90 07        		bcc :+
00084Dr 2  E0 FA        		cpx #$fA
00084Fr 2  B0 03        		bcs :+
000851r 2  CE rr rr     		dec spr_velocity_x_arr+$0		; 速度が遅めのときに進んでいる方向に速度を1足す
000854r 2               :
000854r 2  EE rr rr     		inc spr_velocity_x_arr+$0
000857r 2  4C rr rr     		jmp EXIT	; ------------------
00085Ar 2               
00085Ar 2               @ACCELERATE_RIGHT:
00085Ar 2  A2 00        		ldx #0
00085Cr 2  A5 rr        		lda Joypad::joy1
00085Er 2  29 40        		and #Joypad::BTN_B
000860r 2  F0 01        		beq :+
000862r 2  E8           		inx
000863r 2               :
000863r 2  BD rr rr     		lda AMOUNT_INC_SPD_R, x
000866r 2  18 6D rr rr  		add spr_float_velocity_x_arr+$0
00086Ar 2  DD rr rr     		cmp MAX_SPD_R, x
00086Dr 2  30 05        		bmi :+
00086Fr 2  E8           		inx
000870r 2  38           		sec
000871r 2  FD rr rr     		sbc AMOUNT_INC_SPD_R, x
000874r 2               :
000874r 2  8D rr rr     		sta spr_float_velocity_x_arr+$0
000877r 2  18 6D rr rr  		add spr_decimal_part_velocity_x_arr+$0
00087Br 2  85 rr        		sta tmp1
00087Dr 2  29 0F        		and #BYT_GET_LO
00087Fr 2  8D rr rr     		sta spr_decimal_part_velocity_x_arr+$0
000882r 2  A5 rr        		lda tmp1
000884r 2  C9 00        		cmp #0
000886r 2  10 08        		bpl :+
000888r 2  4A 4A 4A 4A  		shr #4
00088Cr 2  09 F0        		ora #%11110000
00088Er 2  D0 04        		bne :++
000890r 2               :
000890r 2  4A 4A 4A 4A  		shr #4
000894r 2               :
000894r 2  8D rr rr     		sta spr_velocity_x_arr+$0
000897r 2               		; 向きの更新
000897r 2  AD rr rr     		lda spr_float_velocity_x_arr+$0
00089Ar 2  F0 14        		beq :++							; 速度が0のとき向きフラグを更新しない（今の向きを継続利用）
00089Cr 2  30 0A        		bmi :+
00089Er 2  AD rr rr     		lda spr_attr_arr				; 速度が正のとき向きフラグを1に
0008A1r 2  09 01        		ora #%0000_0001
0008A3r 2  8D rr rr     		sta spr_attr_arr+$0
0008A6r 2  D0 08        		bne :++		; ------------------
0008A8r 2               :
0008A8r 2  AD rr rr     		lda spr_attr_arr+$0				; 速度が負のとき向きフラグを0に
0008ABr 2  29 FE        		and #%1111_1110
0008ADr 2  8D rr rr     		sta spr_attr_arr+$0
0008B0r 2               :
0008B0r 2               		; 速度調整
0008B0r 2  A5 rr        		lda tmp1
0008B2r 2  C9 10        		cmp #$10
0008B4r 2  B0 07        		bcs EXIT
0008B6r 2  C9 06        		cmp #$06
0008B8r 2  90 03        		bcc EXIT
0008BAr 2  EE rr rr     		inc spr_velocity_x_arr+$0
0008BDr 2               EXIT:
0008BDr 2  AD rr rr     		lda spr_posX_arr+$0
0008C0r 2  18 6D rr rr  		add spr_velocity_x_arr+$0
0008C4r 2  8D rr rr     		sta spr_posX_tmp_arr+$0
0008C7r 2  60           		rts
0008C8r 2               		; ------------------------------
0008C8r 2               .endproc
0008C8r 2               
0008C8r 2               
0008C8r 2               ;*------------------------------------------------------------------------------
0008C8r 2               ; player animate
0008C8r 2               ; @PARAMS		None
0008C8r 2               ; @CLOBBERS		A tmp1
0008C8r 2               ; @RETURNS		None
0008C8r 2               ;*------------------------------------------------------------------------------
0008C8r 2               .proc _animate
0008C8r 2  A5 rr        		lda Player::is_jumping
0008CAr 2  F0 06        		beq :+
0008CCr 2  A9 04        		lda #4							; ジャンプ時のアニメーション番号
0008CEr 2  8D rr rr     		sta spr_anime_num
0008D1r 2  60           		rts
0008D2r 2               		; ------------------------------
0008D2r 2               :
0008D2r 2  A5 rr        	lda Player::is_fly
0008D4r 2  F0 06        	beq :+
0008D6r 2  A9 03        	lda #3
0008D8r 2  8D rr rr     	sta spr_anime_num
0008DBr 2  60           	rts
0008DCr 2               	; ------------------------------
0008DCr 2               :
0008DCr 2  AD rr rr     	lda spr_float_velocity_x_arr+$0
0008DFr 2  D0 0C        	bne :+
0008E1r 2  A5 rr        	lda Joypad::joy1
0008E3r 2  29 03        	and #(Joypad::BTN_L|Joypad::BTN_R)
0008E5r 2  D0 35        	bne @NORMAL_MOVE				; 当たり判定で動きが封じられているとき（速度0でボタンは押されている）
0008E7r 2  A9 00        	lda #0
0008E9r 2  8D rr rr     	sta spr_anime_num+$0
0008ECr 2  60           	rts
0008EDr 2               	; ------------------------------
0008EDr 2               :										; 速度が0でないとき
0008EDr 2  A5 rr        		lda Joypad::joy1
0008EFr 2  29 03        		and #(Joypad::BTN_L|Joypad::BTN_R)
0008F1r 2  F0 29        		beq @NORMAL_MOVE
0008F3r 2  29 02        		and #Joypad::BTN_L
0008F5r 2  4A           		shr #1							; 左ボタンのフラグを最下位ビットに
0008F6r 2  85 rr        		sta tmp1
0008F8r 2  AD rr rr     		lda spr_float_velocity_x_arr+$0
0008FBr 2  0A           		asl								; 速度の最上位ビットを最下位ビットに入れる
0008FCr 2  A9 00        		lda #0
0008FEr 2  2A           		rol
0008FFr 2  C5 rr        		cmp tmp1
000901r 2  F0 19        		beq @NORMAL_MOVE
000903r 2               		; ブレーキ時の動作
000903r 2  C9 00        		cmp #0
000905r 2  F0 07        		beq @RIGHT
000907r 2  AD rr rr     		lda spr_attr_arr+$0				; 左ボタンが押されているとき
00090Ar 2  09 01        		ora #%0000_0001
00090Cr 2  D0 05        		bne :+		; ------------------
00090Er 2               @RIGHT:
00090Er 2  AD rr rr     		lda spr_attr_arr+$0
000911r 2  29 FE        		and #%1111_1110
000913r 2               :
000913r 2  8D rr rr     		sta spr_attr_arr+$0
000916r 2  A9 05        		lda #5							; ブレーキ時のアニメーション番号
000918r 2  8D rr rr     		sta spr_anime_num+$0
00091Br 2  60           		rts
00091Cr 2               		; ------------------------------
00091Cr 2               @NORMAL_MOVE:							; 通常の進み方（ブレーキでない）をしているとき
00091Cr 2               		; MEMO: 工夫すればバイト数削れそうなプログラム
00091Cr 2  AD rr rr     		lda spr_float_velocity_x_arr+$0
00091Fr 2  10 05        		bpl :+
000921r 2  49 FF 18 69  		cnn								; 速度の絶対値を取る
000925r 2  01           
000926r 2               :
000926r 2  C9 10        		cmp #$10
000928r 2  10 04        		bpl :+
00092Ar 2               		; スピードが$10以下
00092Ar 2  A9 04        		lda #4
00092Cr 2  D0 16        		bne @ANIMATE
00092Er 2               :
00092Er 2  C9 18        		cmp #$18
000930r 2  10 04        		bpl :+
000932r 2  A9 03        		lda #3
000934r 2  D0 0E        		bne @ANIMATE
000936r 2               :
000936r 2  C9 20        		cmp #$20
000938r 2  10 04        		bpl :+
00093Ar 2  A9 02        		lda #2
00093Cr 2  D0 06        		bne @ANIMATE
00093Er 2               :
00093Er 2  C9 28        		cmp #$28
000940r 2  10 02        		bpl @ANIMATE
000942r 2  A9 01        		lda #1
000944r 2               @ANIMATE:								; タイマーと速度に応じた値を比較しアニメーションを進める
000944r 2  CD rr rr     		cmp spr_anime_timer+$0
000947r 2  10 14        		bpl @NO_CHANGE_CHR
000949r 2               
000949r 2  A9 00        		lda #0							; アニメーション変更
00094Br 2  8D rr rr     		sta spr_anime_timer+$0
00094Er 2               
00094Er 2  EE rr rr     		inc spr_anime_num+$0
000951r 2  AD rr rr     		lda spr_anime_num+$0
000954r 2  C9 04        		cmp #4
000956r 2  90 05        		bcc @NO_CHANGE_CHR
000958r 2  A9 01        		lda #1							; アニメーション番号が超えたので最初に戻す
00095Ar 2  8D rr rr     		sta spr_anime_num+$0
00095Dr 2               @NO_CHANGE_CHR:
00095Dr 2  AD rr rr     		lda spr_anime_num+$0
000960r 2  D0 0A        		bne @EXIT
000962r 2               		; 歩き始め（止まっている状態から進み出した時）
000962r 2  A9 01        		lda #1							; 1F目から歩いているアニメーションにする
000964r 2  8D rr rr     		sta spr_anime_num+$0
000967r 2  A9 00        		lda #0							; タイマーリセット
000969r 2  8D rr rr     		sta spr_anime_timer+$0
00096Cr 2               @EXIT:
00096Cr 2  60           		rts
00096Dr 2               		; ------------------------------
00096Dr 2               
00096Dr 2               .endproc
00096Dr 2               
00096Dr 2               
00096Dr 2               ;*------------------------------------------------------------------------------
00096Dr 2               ; ジャンプするかの確認
00096Dr 2               ; @PARAMS		None
00096Dr 2               ; @CLOBBERS		A
00096Dr 2               ; @RETURNS		None
00096Dr 2               ;*------------------------------------------------------------------------------
00096Dr 2               .proc _jumpCheck
00096Dr 2  A5 rr        		lda Joypad::joy1_pushstart
00096Fr 2  29 80        		and #Joypad::BTN_A
000971r 2  F0 07        		beq @EXIT
000973r 2  A5 rr        		lda Player::is_fly
000975r 2  D0 03        		bne @EXIT
000977r 2               		; 地面にいるときジャンプ開始準備
000977r 2  20 rr rr     		jsr Player::_prepareJumping
00097Ar 2               @EXIT:
00097Ar 2  60           		rts
00097Br 2               		; ------------------------------
00097Br 2               .endproc
00097Br 2               
00097Br 2               
00097Br 2               ;*------------------------------------------------------------------------------
00097Br 2               ; ジャンプの初期設定
00097Br 2               ; @PARAMS		None
00097Br 2               ; @CLOBBERS		A X
00097Br 2               ; @RETURNS		None
00097Br 2               ;*------------------------------------------------------------------------------
00097Br 2               .proc _prepareJumping
00097Br 2  A2 01        		ldx #1
00097Dr 2  86 rr        		stx Player::is_fly				; 空中にいるかつ
00097Fr 2  86 rr        		stx Player::is_jumping			; ジャンプ中
000981r 2               
000981r 2  CA           		dex
000982r 2  8E rr rr     		stx spr_decimal_part_velocity_y_arr+$0	; 補正値を0に
000985r 2               
000985r 2  AD rr rr     		lda spr_posY_arr+$0				; 現在のY座標を保存
000988r 2  8D rr rr     		sta spr_pos_y_origin+$0
00098Br 2               
00098Br 2               		; X = 0
00098Br 2  AD rr rr     		lda spr_velocity_x_arr+$0
00098Er 2  10 05        		bpl :+
000990r 2  49 FF 18 69  		cnn								; X方向のスピードの絶対値を求める
000994r 2  01           
000995r 2               :
000995r 2  C9 1C        		cmp #$1c
000997r 2  30 01        		bmi @SKIP1
000999r 2  E8           		inx								; x = 1
00099Ar 2               @SKIP1:
00099Ar 2  C9 19        		cmp #$19
00099Cr 2  30 01        		bmi @SKIP2
00099Er 2  E8           		inx								; x = 2
00099Fr 2               @SKIP2:
00099Fr 2  C9 10        		cmp #$10
0009A1r 2  30 01        		bmi @SKIP3
0009A3r 2  E8           		inx								; x = 3
0009A4r 2               @SKIP3:
0009A4r 2  C9 09        		cmp #$09
0009A6r 2  30 01        		bmi @SKIP4
0009A8r 2  E8           		inx								; x = 4
0009A9r 2               @SKIP4:
0009A9r 2               		; 現在の速度に応じた初期データを格納
0009A9r 2  BD rr rr     		lda VER_FORCE_DECIMAL_PART_DATA, x
0009ACr 2  8D rr rr     		sta spr_decimal_part_force_y+$0
0009AFr 2  BD rr rr     		lda VER_FALL_FORCE_DATA, x
0009B2r 2  8D rr rr     		sta spr_force_fall_y+$0
0009B5r 2  BD rr rr     		lda INITIAL_VER_FORCE_DATA, x
0009B8r 2  8D rr rr     		sta spr_decimal_part_velocity_y_arr+$0
0009BBr 2  BD rr rr     		lda INITIAL_VER_SPEED_DATA, x
0009BEr 2  8D rr rr     		sta spr_velocity_y_arr+$0
0009C1r 2               
0009C1r 2  60           		rts
0009C2r 2               		; ------------------------------
0009C2r 2               .endproc
0009C2r 2               
0009C2r 2               
0009C2r 2               ;*------------------------------------------------------------------------------
0009C2r 2               ; Y方向の速度決定前のちょっとした動作（よくわかんない）
0009C2r 2               ; @PARAMS		None
0009C2r 2               ; @CLOBBERS		A
0009C2r 2               ; @RETURNS		None
0009C2r 2               ;*------------------------------------------------------------------------------
0009C2r 2               .proc _moveYProcess
0009C2r 2  AD rr rr     		lda spr_velocity_y_arr+$0
0009C5r 2  10 0C        		bpl @SKIP1						; 速度が正（落下中）はスキップ
0009C7r 2  A5 rr        		lda Joypad::joy1
0009C9r 2  29 80        		and #Joypad::BTN_A
0009CBr 2  D0 0C        		bne @SKIP2
0009CDr 2  A5 rr        		lda Joypad::joy1_prev
0009CFr 2  29 80        		and #Joypad::BTN_A
0009D1r 2  F0 06        		beq @SKIP2
0009D3r 2               @SKIP1:
0009D3r 2               		; Aボタンが離されたタイミング
0009D3r 2  AD rr rr     		lda spr_force_fall_y+$0
0009D6r 2  8D rr rr     		sta spr_decimal_part_force_y+$0	; 初期化
0009D9r 2               @SKIP2:
0009D9r 2  20 rr rr     		jsr Player::_physicsY
0009DCr 2  60           		rts
0009DDr 2               		; ------------------------------
0009DDr 2               .endproc
0009DDr 2               
0009DDr 2               
0009DDr 2               ;*------------------------------------------------------------------------------
0009DDr 2               ; Y方向の速度決定，仮Y座標決定
0009DDr 2               ; @PARAMS		None
0009DDr 2               ; @CLOBBERS		A X
0009DDr 2               ; @RETURNS		None
0009DDr 2               ;*------------------------------------------------------------------------------
0009DDr 2               .proc _physicsY
0009DDr 2  A2 00        		ldx #0
0009DFr 2  8E rr rr     		stx spr_fix_val_y+$0			; 初期化
0009E2r 2               
0009E2r 2  AD rr rr     		lda spr_pos_y_decimal_part+$0
0009E5r 2  18 6D rr rr  		add spr_decimal_part_force_y+$0
0009E9r 2  8D rr rr     		sta spr_pos_y_decimal_part+$0
0009ECr 2  90 07        		bcc @SKIP_OVERFLOW
0009EEr 2               		; オーバーフローしてたら
0009EEr 2  8E rr rr     		stx spr_pos_y_decimal_part+$0	; x = 0
0009F1r 2  E8           		inx								; x = 1
0009F2r 2  8E rr rr     		stx spr_fix_val_y+$0			; 補正値があったらここで修正
0009F5r 2               @SKIP_OVERFLOW:
0009F5r 2  AD rr rr     		lda spr_decimal_part_velocity_y_arr+$0
0009F8r 2  18 6D rr rr  		add spr_decimal_part_force_y+$0
0009FCr 2  8D rr rr     		sta spr_decimal_part_velocity_y_arr+$0
0009FFr 2  90 17        		bcc @EXIT
000A01r 2               
000A01r 2  A9 00        		lda #0
000A03r 2  8D rr rr     		sta spr_decimal_part_velocity_y_arr+$0
000A06r 2  AE rr rr     		ldx spr_velocity_y_arr+$0
000A09r 2  E8           		inx
000A0Ar 2  E0 04        		cpx #DOWN_SPEED_LIMIT
000A0Cr 2  30 07        		bmi @STORE_VER_SPEED
000A0Er 2               
000A0Er 2  A2 04        		ldx #DOWN_SPEED_LIMIT
000A10r 2  A9 00        		lda #0
000A12r 2  8D rr rr     		sta spr_decimal_part_velocity_y_arr+$0
000A15r 2               @STORE_VER_SPEED:
000A15r 2  8E rr rr     		stx spr_velocity_y_arr+$0
000A18r 2               
000A18r 2               @EXIT:
000A18r 2  AD rr rr     		lda spr_posY_arr+$0
000A1Br 2  18 6D rr rr  		add spr_velocity_y_arr+$0
000A1Fr 2  8D rr rr     		sta spr_posY_tmp_arr+$0			; 仮Y座標
000A22r 2  60           		rts
000A23r 2               		; ------------------------------
000A23r 2               .endproc
000A23r 2               
000A23r 2               
000A23r 2               ;*------------------------------------------------------------------------------
000A23r 2               ; あたり判定
000A23r 2               ; @PARAMS		None
000A23r 2               ; @CLOBBERS		A X
000A23r 2               ; @RETURNS		None
000A23r 2               ;*------------------------------------------------------------------------------
000A23r 2               .proc _checkCollision
000A23r 2  A9 00        	lda #0
000A25r 2  85 rr        	sta player_offset_flags
000A27r 2  85 rr        	sta player_collision_flags
000A29r 2  85 rr        	sta is_collision_down
000A2Br 2               
000A2Br 2  AD rr rr     	lda spr_posX_tmp_arr+$0
000A2Er 2  C9 F2        	cmp #$f0+PLAYER_PADDING
000A30r 2  90 1E        	bcc @SKIP1
000A32r 2  C9 F8        	cmp #$f8
000A34r 2  90 0D        	bcc @RIGHT
000A36r 2               	; 左端衝突
000A36r 2  A9 00        	lda #0
000A38r 2  8D rr rr     	sta spr_posX_tmp_arr+$0
000A3Br 2               	; lda #1
000A3Br 2  8D rr rr     	sta spr_float_velocity_x_arr+$0
000A3Er 2  8D rr rr     	sta spr_velocity_x_arr+$0
000A41r 2               	; sta spr_decimal_part_velocity_x_arr+$0
000A41r 2  F0 0D        	beq @SKIP1
000A43r 2               @RIGHT:
000A43r 2  A9 F2        	lda #($100-PLAYER_WIDTH-PLAYER_PADDING)
000A45r 2  8D rr rr     	sta spr_posX_tmp_arr+$0
000A48r 2               	; lda #1
000A48r 2  A9 00        	lda #0
000A4Ar 2  8D rr rr     	sta spr_float_velocity_x_arr+$0
000A4Dr 2  8D rr rr     	sta spr_velocity_x_arr+$0
000A50r 2               	; sta spr_decimal_part_velocity_x_arr+$0
000A50r 2               @SKIP1:
000A50r 2               
000A50r 2               	; マリオのY座標を取得してブロック単位に変換
000A50r 2  AD rr rr     	lda spr_posY_tmp_arr+$0
000A53r 2  18 69 02     	add #2
000A56r 2  4A 4A 4A 4A  	shr #4
000A5Ar 2  C9 02        	cmp #2
000A5Cr 2  B0 01        	bcs :+
000A5Er 2  60           	rts									; 上1列にマリオ（の頭）がいるとき
000A5Fr 2               	; ------------------------------
000A5Fr 2               :
000A5Fr 2  38 E9 02     	sub #2
000A62r 2  85 rr        	sta player_block_pos_Y
000A64r 2               
000A64r 2  AD rr rr     	lda spr_posY_tmp_arr+$0
000A67r 2  18 69 02     	add #2
000A6Ar 2  85 rr        	sta player_pos_top
000A6Cr 2  18 69 0E     	add #$10-2
000A6Fr 2  85 rr        	sta player_pos_bottom
000A71r 2  38 E9 01     	sub #1
000A74r 2  4A 4A 4A 4A  	shr #4
000A78r 2  38 E9 02     	sub #2
000A7Br 2  85 rr        	sta player_block_pos_bottom
000A7Dr 2               
000A7Dr 2               
000A7Dr 2               	; スクロール量と画面を考慮してマリオのX座標を取得
000A7Dr 2  A2 00        	ldx #0
000A7Fr 2  86 rr        	stx tmp1
000A81r 2  AD rr rr     	lda spr_posX_tmp_arr+$0
000A84r 2  18 69 02     	add #PLAYER_PADDING
000A87r 2  90 03        	bcc :+
000A89r 2  E8           	inx
000A8Ar 2  86 rr        	stx tmp1
000A8Cr 2               :
000A8Cr 2  18 65 rr     	add scroll_x
000A8Fr 2  85 rr        	sta player_actual_pos_left
000A91r 2  A5 rr        	lda main_disp
000A93r 2  65 rr        	adc tmp1								; キャリーフラグ（tmp1もキャリーフラグ代わり）を足し算
000A95r 2  29 01        	and #%0000_0001
000A97r 2  85 rr        	sta player_current_screen
000A99r 2               
000A99r 2  A5 rr        	lda player_actual_pos_left
000A9Br 2  4A 4A 4A 4A  	shr #4
000A9Fr 2  85 rr        	sta player_block_pos_X
000AA1r 2  A5 rr        	lda player_actual_pos_left
000AA3r 2  18 69 0C     	add #PLAYER_WIDTH
000AA6r 2  85 rr        	sta player_actual_pos_right
000AA8r 2  38 E9 01     	sub #1
000AABr 2  4A 4A 4A 4A  	shr #4
000AAFr 2  85 rr        	sta player_block_pos_right
000AB1r 2               
000AB1r 2               
000AB1r 2               	; 下方向のあたり判定
000AB1r 2  A5 rr        	lda player_block_pos_Y
000AB3r 2  C5 rr        	cmp player_block_pos_bottom
000AB5r 2  F0 06        	beq :+
000AB7r 2  A5 rr        	lda player_offset_flags
000AB9r 2  09 01        	ora #%0000_0001					; Y方向にずれあり
000ABBr 2  85 rr        	sta player_offset_flags
000ABDr 2               :
000ABDr 2               	; 右方向のあたり判定
000ABDr 2  A5 rr        	lda player_block_pos_right
000ABFr 2  C5 rr        	cmp player_block_pos_X
000AC1r 2  F0 06        	beq :+
000AC3r 2  A5 rr        	lda player_offset_flags
000AC5r 2  09 02        	ora #%0000_0010
000AC7r 2  85 rr        	sta player_offset_flags
000AC9r 2               :
000AC9r 2               
000AC9r 2               
000AC9r 2               	; マリオの周辺のブロックフラグをセット=
000AC9r 2               	; ----- 左上 -----
000AC9r 2  A5 rr        	lda player_block_pos_Y
000ACBr 2  0A 0A 0A 0A  	shl #4
000ACFr 2  05 rr        	ora player_block_pos_X
000AD1r 2  AA           	tax
000AD2r 2  18           	clc								; 後で使うためにキャリークリア
000AD3r 2  A5 rr        	lda player_current_screen
000AD5r 2  D0 05        	bne :+
000AD7r 2  BD 00 04     	lda $0400, x
000ADAr 2  90 03        	bcc :++	; ---------------------
000ADCr 2               :
000ADCr 2  BD 00 05     	lda $0500, x
000ADFr 2               :
000ADFr 2  F0 01        	beq :+							; ブロック判定
000AE1r 2  38           	sec								; ブロックがあったときキャリーセット
000AE2r 2               :
000AE2r 2  26 rr        	rol player_collision_flags		; キャリーを入れていく（あと三回ローテートするのでbit3に格納される）
000AE4r 2               
000AE4r 2               	; ----- 右上 -----
000AE4r 2  A5 rr        	lda player_block_pos_X
000AE6r 2  C9 0F        	cmp #$0f
000AE8r 2  D0 16        	bne @NORMAL1
000AEAr 2  A5 rr        	lda player_block_pos_Y
000AECr 2  0A 0A 0A 0A  	shl #4							; 下位（X座標）は0
000AF0r 2  AA           	tax
000AF1r 2  18           	clc
000AF2r 2  A5 rr        	lda player_current_screen
000AF4r 2  D0 05        	bne :+
000AF6r 2  BD 00 05     	lda $0500, x
000AF9r 2  90 1E        	bcc @CHECK1
000AFBr 2               :
000AFBr 2  BD 00 04     	lda $0400, x
000AFEr 2  90 19        	bcc @CHECK1
000B00r 2               @NORMAL1:
000B00r 2  A5 rr        	lda player_block_pos_Y
000B02r 2  0A 0A 0A 0A  	shl #4
000B06r 2  05 rr        	ora player_block_pos_X
000B08r 2  18 69 01     	add #1
000B0Br 2  AA           	tax
000B0Cr 2  18           	clc
000B0Dr 2  A5 rr        	lda player_current_screen
000B0Fr 2  D0 05        	bne :+
000B11r 2  BD 00 04     	lda $0400, x
000B14r 2  90 03        	bcc @CHECK1
000B16r 2               :
000B16r 2  BD 00 05     	lda $0500, x
000B19r 2               @CHECK1:
000B19r 2  F0 01        	beq :+
000B1Br 2  38           	sec
000B1Cr 2               :
000B1Cr 2  26 rr        	rol player_collision_flags
000B1Er 2               
000B1Er 2               	; ----- 左下 -----
000B1Er 2  A5 rr        	lda player_block_pos_bottom
000B20r 2  0A 0A 0A 0A  	shl #4
000B24r 2  05 rr        	ora player_block_pos_X
000B26r 2  AA           	tax
000B27r 2  18           	clc								; 後で使うためにキャリークリア
000B28r 2  A5 rr        	lda player_current_screen
000B2Ar 2  D0 05        	bne :+
000B2Cr 2  BD 00 04     	lda $0400, x
000B2Fr 2  90 03        	bcc :++	; ---------------------
000B31r 2               :
000B31r 2  BD 00 05     	lda $0500, x
000B34r 2               :
000B34r 2  F0 01        	beq :+							; ブロック判定
000B36r 2  38           	sec								; ブロックがあったときキャリーセット
000B37r 2               :
000B37r 2  26 rr        	rol player_collision_flags		; キャリーを入れていく（あと三回ローテートするのでbit3に格納される）
000B39r 2               
000B39r 2               	; ----- 右下 -----
000B39r 2  A5 rr        	lda player_block_pos_X
000B3Br 2  C9 0F        	cmp #$0f
000B3Dr 2  D0 16        	bne @NORMAL2
000B3Fr 2  A5 rr        	lda player_block_pos_bottom
000B41r 2  0A 0A 0A 0A  	shl #4							; 下位（X座標）は0
000B45r 2  AA           	tax
000B46r 2  18           	clc
000B47r 2  A5 rr        	lda player_current_screen
000B49r 2  D0 05        	bne :+
000B4Br 2  BD 00 05     	lda $0500, x
000B4Er 2  90 1E        	bcc @CHECK2
000B50r 2               :
000B50r 2  BD 00 04     	lda $0400, x
000B53r 2  90 19        	bcc @CHECK2
000B55r 2               @NORMAL2:
000B55r 2  A5 rr        	lda player_block_pos_bottom
000B57r 2  0A 0A 0A 0A  	shl #4
000B5Br 2  05 rr        	ora player_block_pos_X
000B5Dr 2  18 69 01     	add #1
000B60r 2  AA           	tax
000B61r 2  18           	clc
000B62r 2  A5 rr        	lda player_current_screen
000B64r 2  D0 05        	bne :+
000B66r 2  BD 00 04     	lda $0400, x
000B69r 2  90 03        	bcc @CHECK2
000B6Br 2               :
000B6Br 2  BD 00 05     	lda $0500, x
000B6Er 2               @CHECK2:
000B6Er 2  F0 01        	beq :+
000B70r 2  38           	sec
000B71r 2               :
000B71r 2  26 rr        	rol player_collision_flags
000B73r 2               
000B73r 2               
000B73r 2               	; フラグを元にしてあたり判定・位置調整
000B73r 2  A5 rr        	lda player_offset_flags
000B75r 2  C9 03        	cmp #%0000_0011
000B77r 2  F0 0A        	beq @CHECK_XY
000B79r 2  C9 01        	cmp #%0000_0001
000B7Br 2  F0 0B        	beq @CHECK_BOTTOM
000B7Dr 2  C9 02        	cmp #%0000_0010
000B7Fr 2  F0 0C        	beq @CHECK_RIGHT
000B81r 2  D0 13        	bne @EXIT
000B83r 2               @CHECK_XY:
000B83r 2  A9 0F        	lda #%0000_1111
000B85r 2  4C rr rr     	jmp @JMP_SUB
000B88r 2               @CHECK_BOTTOM:
000B88r 2  A9 0A        	lda #%0000_1010					; 右側は無視
000B8Ar 2  4C rr rr     	jmp @JMP_SUB
000B8Dr 2               @CHECK_RIGHT:
000B8Dr 2  A9 0C        	lda #%0000_1100					; 下側は無視
000B8Fr 2               @JMP_SUB:
000B8Fr 2  25 rr        	and player_collision_flags
000B91r 2  85 rr        	sta player_collision_flags
000B93r 2  20 rr rr     	jsr _fixCollision
000B96r 2               @EXIT:
000B96r 2  A5 rr        	lda is_collision_down
000B98r 2  49 01        	eor #%0000_0001
000B9Ar 2  85 rr        	sta is_fly
000B9Cr 2  60           	rts
000B9Dr 2               	; ------------------------------
000B9Dr 2               .endproc
000B9Dr 2               
000B9Dr 2               
000B9Dr 2               .proc _fixCollision
000B9Dr 2  A5 rr        	lda player_collision_flags
000B9Fr 2  D0 01        	bne :+
000BA1r 2  60           	rts
000BA2r 2               	; ------------------------------
000BA2r 2               :
000BA2r 2               
000BA2r 2  C9 0C        	cmp #%0000_1100
000BA4r 2  F0 24        	beq @UPPER
000BA6r 2  C9 03        	cmp #%0000_0011
000BA8r 2  F0 1A        	beq @LOWER
000BAAr 2  C9 05        	cmp #%0000_0101
000BACr 2  F0 22        	beq @RIGHT
000BAEr 2  C9 0A        	cmp #%0000_1010
000BB0r 2  F0 24        	beq @LEFT
000BB2r 2               
000BB2r 2  C9 07        	cmp #%0000_0111
000BB4r 2  F0 26        	beq @LOWER_RIGHT				; 右下→着地する方向に動かし，左にずらす
000BB6r 2  C9 0B        	cmp #%0000_1011
000BB8r 2  F0 2B        	beq @LOWER_LEFT
000BBAr 2  C9 0D        	cmp #%0000_1101
000BBCr 2  F0 30        	beq @UPPER_RIGHT
000BBEr 2  C9 0E        	cmp #%0000_1110
000BC0r 2  F0 35        	beq @UPPER_LEFT
000BC2r 2  D0 3A        	bne @OTHER_CHECK
000BC4r 2               
000BC4r 2               @LOWER:
000BC4r 2  20 rr rr     	jsr _fixCollisionDown
000BC7r 2  4C rr rr     	jmp @EXIT
000BCAr 2               @UPPER:
000BCAr 2  20 rr rr     	jsr _fixCollisionUp
000BCDr 2  4C rr rr     	jmp @EXIT
000BD0r 2               @RIGHT:
000BD0r 2  20 rr rr     	jsr _fixCollisionRight
000BD3r 2  4C rr rr     	jmp @EXIT
000BD6r 2               @LEFT:
000BD6r 2  20 rr rr     	jsr _fixCollisionLeft
000BD9r 2  4C rr rr     	jmp @EXIT
000BDCr 2               @LOWER_RIGHT:
000BDCr 2  20 rr rr     	jsr _fixCollisionDown
000BDFr 2  20 rr rr     	jsr _fixCollisionRight
000BE2r 2  4C rr rr     	jmp @EXIT
000BE5r 2               @LOWER_LEFT:
000BE5r 2  20 rr rr     	jsr _fixCollisionDown
000BE8r 2  20 rr rr     	jsr _fixCollisionLeft
000BEBr 2  4C rr rr     	jmp @EXIT
000BEEr 2               @UPPER_RIGHT:
000BEEr 2  20 rr rr     	jsr _fixCollisionUp
000BF1r 2  20 rr rr     	jsr _fixCollisionRight
000BF4r 2  4C rr rr     	jmp @EXIT
000BF7r 2               @UPPER_LEFT:
000BF7r 2  20 rr rr     	jsr _fixCollisionUp
000BFAr 2  20 rr rr     	jsr _fixCollisionLeft
000BFDr 2               @EXIT:
000BFDr 2  60           	rts
000BFEr 2               	; ------------------------------
000BFEr 2               
000BFEr 2               @OTHER_CHECK:
000BFEr 2  C9 01        	cmp #%0000_0001					; 右下→着地する方向に動かし，左にずらす
000C00r 2  D0 18        	bne :+
000C02r 2  A5 rr        	lda player_offset_flags
000C04r 2  C9 01        	cmp #%0000_0001					; Y座標のずれの確認
000C06r 2  F0 BC        	beq @LOWER
000C08r 2  A5 rr        	lda player_actual_pos_right
000C0Ar 2  29 0F        	and #BYT_GET_LO
000C0Cr 2  85 rr        	sta tmp1
000C0Er 2  A5 rr        	lda player_pos_bottom
000C10r 2  29 0F        	and #BYT_GET_LO
000C12r 2  C5 rr        	cmp tmp1
000C14r 2  90 AE        	bcc @LOWER						; right-bottom<0 → right<bottom（左右<上下）
000C16r 2  F0 C4        	beq @LOWER_RIGHT
000C18r 2  B0 B6        	bcs @RIGHT						; 上下のずれ < 左右のずれ
000C1Ar 2               :
000C1Ar 2  C9 02        	cmp #%0000_0010					; 左下
000C1Cr 2  D0 1D        	bne :+
000C1Er 2  A5 rr        	lda player_offset_flags
000C20r 2  C9 01        	cmp #%0000_0001					; Y座標のずれの確認
000C22r 2  F0 A0        	beq @LOWER
000C24r 2  A5 rr        	lda player_actual_pos_left
000C26r 2  49 FF 18 69  	cnn
000C2Ar 2  01           
000C2Br 2  29 0F        	and #BYT_GET_LO
000C2Dr 2  85 rr        	sta tmp1
000C2Fr 2  A5 rr        	lda player_pos_bottom
000C31r 2  29 0F        	and #BYT_GET_LO
000C33r 2  C5 rr        	cmp tmp1
000C35r 2  90 8D        	bcc @LOWER
000C37r 2  F0 AC        	beq @LOWER_LEFT
000C39r 2  B0 9B        	bcs @LEFT						; 上下のずれ < 左右のずれ
000C3Br 2               :
000C3Br 2  C9 04        	cmp #%0000_0100					; 右上
000C3Dr 2  D0 18        	bne :+
000C3Fr 2  A5 rr        	lda player_offset_flags
000C41r 2  C9 02        	cmp #%0000_0010					; X座標のずれの確認
000C43r 2  F0 3B        	beq @RIGHT2
000C45r 2  A5 rr        	lda player_actual_pos_right
000C47r 2  29 0F        	and #BYT_GET_LO
000C49r 2  85 rr        	sta tmp1
000C4Br 2  A5 rr        	lda player_pos_top
000C4Dr 2  29 0F        	and #BYT_GET_LO
000C4Fr 2  C5 rr        	cmp tmp1
000C51r 2  90 2D        	bcc @RIGHT2
000C53r 2  F0 49        	beq @UPPER_RIGHT2
000C55r 2  B0 23        	bcs @UPPER2						; 上下のずれ <= 左右のずれ
000C57r 2               :
000C57r 2               ; 	bne :+
000C57r 2               ; 	ldx player_offset_flags
000C57r 2               ; 	cpx #%0000_0010
000C57r 2               ; 	beq @RIGHT
000C57r 2               ; 	bne @UPPER_RIGHT
000C57r 2               ; :
000C57r 2  C9 08        	cmp #%0000_1000					; 左上
000C59r 2  D0 18        	bne :+
000C5Br 2  A5 rr        	lda player_offset_flags
000C5Dr 2  C9 02        	cmp #%0000_0010					; X座標のずれの確認
000C5Fr 2  F0 25        	beq @LEFT2
000C61r 2  A5 rr        	lda player_actual_pos_left
000C63r 2  29 0F        	and #BYT_GET_LO
000C65r 2  85 rr        	sta tmp1
000C67r 2  A5 rr        	lda player_pos_top
000C69r 2  29 0F        	and #BYT_GET_LO
000C6Br 2  C5 rr        	cmp tmp1
000C6Dr 2  90 17        	bcc @LEFT2
000C6Fr 2  F0 36        	beq @UPPER_LEFT2
000C71r 2  B0 07        	bcs @UPPER2						; 上下のずれ <= 左右のずれ
000C73r 2               :
000C73r 2  60           	rts
000C74r 2               	; ------------------------------
000C74r 2               
000C74r 2               @LOWER2:
000C74r 2  20 rr rr     	jsr _fixCollisionDown
000C77r 2  4C rr rr     	jmp @EXIT2
000C7Ar 2               @UPPER2:
000C7Ar 2  20 rr rr     	jsr _fixCollisionUp
000C7Dr 2  4C rr rr     	jmp @EXIT2
000C80r 2               @RIGHT2:
000C80r 2  20 rr rr     	jsr _fixCollisionRight
000C83r 2  4C rr rr     	jmp @EXIT2
000C86r 2               @LEFT2:
000C86r 2  20 rr rr     	jsr _fixCollisionLeft
000C89r 2  4C rr rr     	jmp @EXIT2
000C8Cr 2               @LOWER_RIGHT2:
000C8Cr 2  20 rr rr     	jsr _fixCollisionDown
000C8Fr 2  20 rr rr     	jsr _fixCollisionRight
000C92r 2  4C rr rr     	jmp @EXIT2
000C95r 2               @LOWER_LEFT2:
000C95r 2  20 rr rr     	jsr _fixCollisionDown
000C98r 2  20 rr rr     	jsr _fixCollisionLeft
000C9Br 2  4C rr rr     	jmp @EXIT2
000C9Er 2               @UPPER_RIGHT2:
000C9Er 2  20 rr rr     	jsr _fixCollisionUp
000CA1r 2  20 rr rr     	jsr _fixCollisionRight
000CA4r 2  4C rr rr     	jmp @EXIT2
000CA7r 2               @UPPER_LEFT2:
000CA7r 2  20 rr rr     	jsr _fixCollisionUp
000CAAr 2  20 rr rr     	jsr _fixCollisionLeft
000CADr 2               @EXIT2:
000CADr 2  60           	rts
000CAEr 2               	; ------------------------------
000CAEr 2               .endproc
000CAEr 2               
000CAEr 2               
000CAEr 2               .proc _fixCollisionUp
000CAEr 2               	; 上で衝突→下にずらす
000CAEr 2  A5 rr        	lda player_pos_top
000CB0r 2  38 E9 02     	sub #2							; 上のパディング分
000CB3r 2  29 F0        	and #BYT_GET_HI
000CB5r 2  18 69 0E     	add #$10-2
000CB8r 2  8D rr rr     	sta spr_posY_tmp_arr+$0
000CBBr 2               
000CBBr 2  A9 00        	lda #0							; 初期化
000CBDr 2  8D rr rr     	sta spr_velocity_y_arr+$0
000CC0r 2  8D rr rr     	sta spr_decimal_part_velocity_y_arr+$0
000CC3r 2  AD rr rr     	lda spr_force_fall_y+$0
000CC6r 2  8D rr rr     	sta spr_decimal_part_force_y+$0
000CC9r 2  60           	rts
000CCAr 2               	; ------------------------------
000CCAr 2               .endproc
000CCAr 2               
000CCAr 2               
000CCAr 2               .proc _fixCollisionDown
000CCAr 2  A5 rr        	lda player_pos_bottom
000CCCr 2  29 F0        	and #BYT_GET_HI
000CCEr 2  38 E5 rr     	sub player_pos_bottom
000CD1r 2  18 6D rr rr  	add spr_posY_tmp_arr+$0
000CD5r 2  8D rr rr     	sta spr_posY_tmp_arr+$0
000CD8r 2  A2 00        	ldx #0
000CDAr 2  86 rr        	stx is_fly
000CDCr 2  86 rr        	stx is_jumping
000CDEr 2  E8           	inx
000CDFr 2  86 rr        	stx is_collision_down
000CE1r 2  AD rr rr     	lda spr_velocity_y_arr+$0
000CE4r 2  30 08        	bmi :+
000CE6r 2  A9 01        	lda #1							; Y方向の加速度が正（下向き）の場合
000CE8r 2  8D rr rr     	sta spr_velocity_y_arr+$0
000CEBr 2  8D rr rr     	sta spr_decimal_part_velocity_y_arr+$0
000CEEr 2               :
000CEEr 2  60           	rts
000CEFr 2               	; ------------------------------
000CEFr 2               .endproc
000CEFr 2               
000CEFr 2               
000CEFr 2               ;! -----------------------------------------------------------------------------
000CEFr 2               ;! 不具合内容
000CEFr 2               ;! スクロール，速度決定のプロセスに何らかのバグ→修正済み
000CEFr 2               ;! 上からマリオが降ってきたときには左右にずらさない→修正済み
000CEFr 2               ;! -----------------------------------------------------------------------------
000CEFr 2               
000CEFr 2               .proc _fixCollisionRight
000CEFr 2               	; 右で衝突→左にずらす
000CEFr 2  A5 rr        	lda player_actual_pos_right
000CF1r 2  29 F0        	and #BYT_GET_HI
000CF3r 2  38 E5 rr     	sub player_actual_pos_right
000CF6r 2  18 6D rr rr  	add spr_posX_tmp_arr+$0
000CFAr 2  8D rr rr     	sta spr_posX_tmp_arr+$0
000CFDr 2  A9 00        	lda #0
000CFFr 2  8D rr rr     	sta spr_float_velocity_x_arr+$0
000D02r 2  60           	rts
000D03r 2               	; ------------------------------
000D03r 2               .endproc
000D03r 2               
000D03r 2               
000D03r 2               .proc _fixCollisionLeft
000D03r 2               	; lda player_actual_pos_left
000D03r 2               	; and #BYT_GET_HI
000D03r 2               	; sta spr_posX_tmp_arr+$0
000D03r 2  A5 rr        	lda player_actual_pos_left
000D05r 2  29 F0        	and #BYT_GET_HI
000D07r 2  18 69 10     	add #$10
000D0Ar 2  38 E5 rr     	sub player_actual_pos_left
000D0Dr 2  18 6D rr rr  	add spr_posX_tmp_arr+$0
000D11r 2  8D rr rr     	sta spr_posX_tmp_arr+$0
000D14r 2  A9 00        	lda #0
000D16r 2  8D rr rr     	sta spr_float_velocity_x_arr+$0
000D19r 2  60           	rts
000D1Ar 2               	; ------------------------------
000D1Ar 2               .endproc
000D1Ar 2               
000D1Ar 2               
000D1Ar 2               .endscope
000D1Ar 2               
000D1Ar 1               .include "nes.inc"
000D1Ar 2               ;
000D1Ar 2               ; NES definitions
000D1Ar 2               ;
000D1Ar 2               
000D1Ar 2               .ifndef	__NES_INC__
000D1Ar 2               
000D1Ar 2               .define	__NES_INC__
000D1Ar 2               
000D1Ar 2               ;; PPU defines
000D1Ar 2               PPU_CTRL1	= $2000
000D1Ar 2               PPU_CTRL2	= $2001
000D1Ar 2               ;PPU_STATUS	= $2002
000D1Ar 2               PPU_SPR_ADDR	= $2003
000D1Ar 2               PPU_SPR_IO  	= $2004
000D1Ar 2               PPU_VRAM_ADDR1	= $2005
000D1Ar 2               PPU_VRAM_ADDR2	= $2006
000D1Ar 2               PPU_VRAM_IO	= $2007
000D1Ar 2               
000D1Ar 2               ;; APU defines
000D1Ar 2               APU_PULSE1CTRL  = $4000         ; Pulse #1 Control Register (W)
000D1Ar 2               APU_PULSE1RAMP  = $4001         ; Pulse #1 Ramp Control Register (W)
000D1Ar 2               APU_PULSE1FTUNE = $4002         ; Pulse #1 Fine Tune (FT) Register (W)
000D1Ar 2               APU_PULSE1CTUNE = $4003         ; Pulse #1 Coarse Tune (CT) Register (W)
000D1Ar 2               APU_PULSE2CTRL  = $4004         ; Pulse #2 Control Register (W)
000D1Ar 2               APU_PULSE2RAMP  = $4005         ; Pulse #2 Ramp Control Register (W)
000D1Ar 2               APU_PULSE2FTUNE = $4006         ; Pulse #2 Fine Tune Register (W)
000D1Ar 2               APU_PULSE2STUNE = $4007         ; Pulse #2 Coarse Tune Register (W)
000D1Ar 2               APU_TRICTRL1    = $4008         ; Triangle Control Register #1 (W)
000D1Ar 2               APU_TRICTRL2    = $4009         ; Triangle Control Register #2 (?)
000D1Ar 2               APU_TRIFREQ1    = $400A         ; Triangle Frequency Register #1 (W)
000D1Ar 2               APU_TRIFREQ2    = $400B         ; Triangle Frequency Register #2 (W)
000D1Ar 2               APU_NOISECTRL   = $400C         ; Noise Control Register #1 (W)
000D1Ar 2               ;;APU_ = $400D  ; Unused (???)
000D1Ar 2               APU_NOISEFREQ1  = $400E         ; Noise Frequency Register #1 (W)
000D1Ar 2               APU_NOISEFREQ2  = $400F         ; Noise Frequency Register #2 (W)
000D1Ar 2               APU_MODCTRL     = $4010         ; Delta Modulation Control Register (W)
000D1Ar 2               APU_MODDA       = $4011         ; Delta Modulation D/A Register (W)
000D1Ar 2               APU_MODADDR     = $4012         ; Delta Modulation Address Register (W)
000D1Ar 2               APU_MODLEN      = $4013         ; Delta Modulation Data Length Register (W)
000D1Ar 2               APU_SPR_DMA    	= $4014         ; Sprite DMA Register (W)
000D1Ar 2               APU_CHANCTRL   	= $4015         ; Sound/Vertical Clock Signal Register (R)
000D1Ar 2               APU_PAD1       	= $4016         ; Joypad #1 (RW)
000D1Ar 2               APU_PAD2	= $4017         ; Joypad #2/SOFTCLK (RW)
000D1Ar 2               
000D1Ar 2               .endif
000D1Ar 2               
000D1Ar 1               .include "nsd.inc"
000D1Ar 2               ;===============================================================================|
000D1Ar 2               ;										|
000D1Ar 2               ;		NES Sound Driver & library	(NSD.lib)			|
000D1Ar 2               ;										|
000D1Ar 2               ;-------------------------------------------------------------------------------|
000D1Ar 2               ;										|
000D1Ar 2               ;  Copyright (c) 2012 A.Watanabe (S.W.)						|
000D1Ar 2               ;  All rights reserved.								|
000D1Ar 2               ;										|
000D1Ar 2               ;  Redistribution and use in source and binary forms, with or without		|
000D1Ar 2               ;  modification, are permitted provided that the following conditions		|
000D1Ar 2               ;  are met:									|
000D1Ar 2               ;										|
000D1Ar 2               ;    1. Redistributions of source code must retain the above copyright		|
000D1Ar 2               ;       notice, this list of conditions and the following disclaimer.		|
000D1Ar 2               ;										|
000D1Ar 2               ;    2. Redistributions in binary form must reproduce the above copyright	|
000D1Ar 2               ;       notice, this list of conditions and the following disclaimer in the	|
000D1Ar 2               ;       documentation and/or other materials provided with the distribution.	|
000D1Ar 2               ;										|
000D1Ar 2               ;  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS		|
000D1Ar 2               ;  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT		|
000D1Ar 2               ;  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR	|
000D1Ar 2               ;  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER	|
000D1Ar 2               ;  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,	|
000D1Ar 2               ;  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,		|
000D1Ar 2               ;  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR		|
000D1Ar 2               ;  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF	|
000D1Ar 2               ;  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING		|
000D1Ar 2               ;  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS		|
000D1Ar 2               ;  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.			|
000D1Ar 2               ;										|
000D1Ar 2               ;===============================================================================|
000D1Ar 2               
000D1Ar 2               	.include	"nsddef.inc"
000D1Ar 3               ;=======================================================================
000D1Ar 3               ;
000D1Ar 3               ;	NES Sound Driver & library (NSD.lib)	Define file
000D1Ar 3               ;
000D1Ar 3               ;-----------------------------------------------------------------------
000D1Ar 3               ;
000D1Ar 3               ;	Copyright (c) 2012 A.Watanabe (S.W.), All rights reserved.
000D1Ar 3               ;	For conditions of distribution and use, see copyright notice
000D1Ar 3               ;	  in "nsd.h" or "nsd.inc".
000D1Ar 3               ;
000D1Ar 3               ;=======================================================================
000D1Ar 3               
000D1Ar 3               
000D1Ar 3               
000D1Ar 3               ;****************************************************************
000D1Ar 3               ;*	NTSC / PAL						*
000D1Ar 3               ;****************************************************************
000D1Ar 3               
000D1Ar 3               .ifndef PAL
000D1Ar 3               Tempo_Sub		= 150
000D1Ar 3               .else
000D1Ar 3               Tempo_Sub		= 125
000D1Ar 3               .endif
000D1Ar 3               
000D1Ar 3               Tempo_Cmp		= 256 - Tempo_Sub
000D1Ar 3               
000D1Ar 3               ;****************************************************************
000D1Ar 3               ;*	Sound I/O Device address defines			*
000D1Ar 3               ;****************************************************************
000D1Ar 3               
000D1Ar 3               ;---------------------------------------
000D1Ar 3               ;FDS define
000D1Ar 3               
000D1Ar 3               FDS_Control		= $4023
000D1Ar 3               FDS_Wave_Table		= $4040		; to $407F
000D1Ar 3               FDS_Volume		= $4080
000D1Ar 3               FDS_FTUNE		= $4082
000D1Ar 3               FDS_CTUNE		= $4083
000D1Ar 3               FDS_Sweep_Envelope	= $4084
000D1Ar 3               FDS_Sweep_Bias		= $4085
000D1Ar 3               FDS_Mod_FTUNE		= $4086
000D1Ar 3               FDS_Mod_CTUNE		= $4087
000D1Ar 3               FDS_Mod_Append		= $4088
000D1Ar 3               FDS_Write_Enable	= $4089
000D1Ar 3               FDS_Envelope_Speed	= $408A
000D1Ar 3               FDS_Volume_Gain		= $4090		;$4080's value
000D1Ar 3               FDS_Sweep_Gain		= $4092		;$4084's value
000D1Ar 3               
000D1Ar 3               ;---------------------------------------
000D1Ar 3               ;VRC6 define
000D1Ar 3               
000D1Ar 3               VRC6_Frequency		= $9003		;.... .ABH	Normally you should write $00 to this register on startup to initialize it.
000D1Ar 3               VRC6_Pulse1_CTRL	= $9000		;MDDD vvvv	mode DT vol
000D1Ar 3               VRC6_Pulse1_FTUNE	= $9001		;FFFF FFFF
000D1Ar 3               VRC6_Pulse1_CTUNE	= $9002		;E... FFFF
000D1Ar 3               VRC6_Pulse2_CTRL	= $A000
000D1Ar 3               VRC6_Pulse2_FTUNE	= $A001
000D1Ar 3               VRC6_Pulse2_CTUNE	= $A002
000D1Ar 3               VRC6_SAW_CTRL		= $B000		;..AA AAAA	volume
000D1Ar 3               VRC6_SAW_FTUNE		= $B001		;FFFF FFFF
000D1Ar 3               VRC6_SAW_CTUNE		= $B002		;E... FFFF
000D1Ar 3               
000D1Ar 3               ;---------------------------------------
000D1Ar 3               ;VRC7 define
000D1Ar 3               
000D1Ar 3               VRC7_Resister		= $9010		;wait  6 clk
000D1Ar 3               VRC7_Data		= $9030		;wait 42 clk
000D1Ar 3               
000D1Ar 3               VRC7_Patch0		= $00
000D1Ar 3               VRC7_Patch1		= $01
000D1Ar 3               VRC7_Patch2		= $02
000D1Ar 3               VRC7_Patch3		= $03
000D1Ar 3               VRC7_Patch4		= $04
000D1Ar 3               VRC7_Patch5		= $05
000D1Ar 3               VRC7_Patch6		= $06
000D1Ar 3               VRC7_Patch7		= $07
000D1Ar 3               
000D1Ar 3               VRC7_Frequency		= $10
000D1Ar 3               VRC7_Octave		= $20
000D1Ar 3               VRC7_Volume		= $30
000D1Ar 3               
000D1Ar 3               ;---------------------------------------
000D1Ar 3               ;OPLL define
000D1Ar 3               
000D1Ar 3               .ifdef	HFX4
000D1Ar 3               OPLL_Resister		= $5F90		;wait  6 clk
000D1Ar 3               OPLL_Data		= $5FB0		;wait 42 clk
000D1Ar 3               .else
000D1Ar 3               OPLL_Resister		= $9010		;wait  6 clk
000D1Ar 3               OPLL_Data		= $9030		;wait 42 clk
000D1Ar 3               .endif
000D1Ar 3               
000D1Ar 3               OPLL_Patch0		= $00
000D1Ar 3               OPLL_Patch1		= $01
000D1Ar 3               OPLL_Patch2		= $02
000D1Ar 3               OPLL_Patch3		= $03
000D1Ar 3               OPLL_Patch4		= $04
000D1Ar 3               OPLL_Patch5		= $05
000D1Ar 3               OPLL_Patch6		= $06
000D1Ar 3               OPLL_Patch7		= $07
000D1Ar 3               
000D1Ar 3               OPLL_RHYTHM		= $0E
000D1Ar 3               OPLL_Frequency		= $10
000D1Ar 3               OPLL_Octave		= $20
000D1Ar 3               OPLL_Volume		= $30
000D1Ar 3               
000D1Ar 3               OPLL_Frequency_BD	= $16
000D1Ar 3               OPLL_Frequency_HH_SD	= $17
000D1Ar 3               OPLL_Frequency_TOM_CYM	= $18
000D1Ar 3               
000D1Ar 3               OPLL_Octave_BD		= $26
000D1Ar 3               OPLL_Octave_HH_SD	= $27
000D1Ar 3               OPLL_Octave_TOM_CYM	= $28
000D1Ar 3               
000D1Ar 3               OPLL_BD			= $36
000D1Ar 3               OPLL_HH_SD		= $37
000D1Ar 3               OPLL_TOM_CYM		= $38
000D1Ar 3               
000D1Ar 3               
000D1Ar 3               ;---------------------------------------
000D1Ar 3               ;MMC5 define
000D1Ar 3               
000D1Ar 3               MMC5_Pulse1_CTRL	= $5000         ; Pulse_ #1 Control Register (W)
000D1Ar 3               MMC5_Pulse1_FTUNE	= $5002         ; Pulse_ #1 Fine Tune (FT) Register (W)
000D1Ar 3               MMC5_Pulse1_CTUNE	= $5003         ; Pulse_ #1 Coarse Tune (CT) Register (W)
000D1Ar 3               MMC5_Pulse2_CTRL	= $5004         ; Pulse_ #2 Control Register (W)
000D1Ar 3               MMC5_Pulse2_FTUNE	= $5006         ; Pulse_ #2 Fine Tune Register (W)
000D1Ar 3               MMC5_Pulse2_CTUNE	= $5007         ; Pulse_ #2 Coarse Tune Register (W)
000D1Ar 3               MMC5_CHANCTRL		= $5015         ;
000D1Ar 3               
000D1Ar 3               ;---------------------------------------
000D1Ar 3               ;N163 define
000D1Ar 3               
000D1Ar 3               N163_Resister		= $F800
000D1Ar 3               N163_Data		= $4800
000D1Ar 3               
000D1Ar 3               N163_Frequency_Low	= $78
000D1Ar 3               N163_Frequency_Middle	= $7A
000D1Ar 3               N163_Frequency_High	= $7C
000D1Ar 3               N163_Waveform		= $7E
000D1Ar 3               N163_Volume		= $7F
000D1Ar 3               
000D1Ar 3               ;---------------------------------------
000D1Ar 3               ;PSG define
000D1Ar 3               
000D1Ar 3               .ifdef	HFE4
000D1Ar 3               PSG_Register		= $5FE0
000D1Ar 3               PSG_Data		= $5FE1
000D1Ar 3               .else
000D1Ar 3               PSG_Register		= $C000
000D1Ar 3               PSG_Data		= $E000
000D1Ar 3               .endif
000D1Ar 3               
000D1Ar 3               PSG_1_Frequency_Low	= $00
000D1Ar 3               PSG_1_Frequency_High	= $01
000D1Ar 3               PSG_2_Frequency_Low	= $02
000D1Ar 3               PSG_2_Frequency_High	= $03
000D1Ar 3               PSG_3_Frequency_Low	= $04
000D1Ar 3               PSG_3_Frequency_High	= $05
000D1Ar 3               PSG_Noise_Frequency	= $06
000D1Ar 3               PSG_Switch		= $07	;00ABCabc
000D1Ar 3               PSG_1_Volume		= $08
000D1Ar 3               PSG_2_Volume		= $09
000D1Ar 3               PSG_3_Volume		= $0A
000D1Ar 3               PSG_Envelope_Low	= $0B
000D1Ar 3               PSG_Envelope_High	= $0C
000D1Ar 3               PSG_Envelope_Form	= $0D
000D1Ar 3               
000D1Ar 3               
000D1Ar 3               
000D1Ar 3               
000D1Ar 3               
000D1Ar 3               ;****************************************************************
000D1Ar 3               ;*	NSD.lib General Define					*
000D1Ar 3               ;****************************************************************
000D1Ar 3               
000D1Ar 3               .scope	nsd
000D1Ar 3               	APU_Track	= 5			;
000D1Ar 3               
000D1Ar 3               	TR_FDS		= APU_Track * 2
000D1Ar 3               	.ifdef	FDS
000D1Ar 3               		FDS_Track	= 1		;
000D1Ar 3               	.else
000D1Ar 3               		FDS_Track	= 0		;
000D1Ar 3               	.endif
000D1Ar 3               
000D1Ar 3               	TR_VRC6		= TR_FDS + FDS_Track * 2
000D1Ar 3               	.ifdef	VRC6
000D1Ar 3               		VRC6_Track	= 3		;
000D1Ar 3               	.else
000D1Ar 3               		VRC6_Track	= 0		;
000D1Ar 3               	.endif
000D1Ar 3               
000D1Ar 3               	TR_VRC7		= TR_VRC6 + VRC6_Track * 2
000D1Ar 3               	.ifdef	VRC7
000D1Ar 3               		VRC7_Track	= 6		;
000D1Ar 3               	.else
000D1Ar 3               		VRC7_Track	= 0		;
000D1Ar 3               	.endif
000D1Ar 3               
000D1Ar 3               	TR_OPLL		= TR_VRC7 + VRC7_Track * 2
000D1Ar 3               	.ifdef	OPLL
000D1Ar 3               		OPLL_Track_FM		= 9
000D1Ar 3               		OPLL_Track_Rhythm	= 5
000D1Ar 3               		OPLL_Track	= OPLL_Track_FM + OPLL_Track_Rhythm
000D1Ar 3               	.else
000D1Ar 3               		OPLL_Track	= 0		;
000D1Ar 3               	.endif
000D1Ar 3               
000D1Ar 3               	TR_MMC5		= TR_OPLL + OPLL_Track * 2
000D1Ar 3               	.ifdef	MMC5
000D1Ar 3               		MMC5_Track	= 2		; (without DPCM)
000D1Ar 3               	.else
000D1Ar 3               		MMC5_Track	= 0		;
000D1Ar 3               	.endif
000D1Ar 3               
000D1Ar 3               	TR_N163		= TR_MMC5 + MMC5_Track * 2
000D1Ar 3               	.ifdef	N163
000D1Ar 3               		N163_Track	= 8		;
000D1Ar 3               	.else
000D1Ar 3               		N163_Track	= 0		;
000D1Ar 3               	.endif
000D1Ar 3               
000D1Ar 3               	TR_PSG		= TR_N163 + N163_Track * 2
000D1Ar 3               	.ifdef	PSG
000D1Ar 3               		PSG_Track	= 3		;
000D1Ar 3               	.else
000D1Ar 3               		PSG_Track	= 0		;
000D1Ar 3               	.endif
000D1Ar 3               
000D1Ar 3               	TR_NULL		= TR_PSG + PSG_Track * 2
000D1Ar 3               	.ifdef	NULL
000D1Ar 3               		NULL_Track	= 1		;
000D1Ar 3               	.else
000D1Ar 3               		NULL_Track	= 0		;
000D1Ar 3               	.endif
000D1Ar 3               
000D1Ar 3               	BGM_Track	= APU_Track + FDS_Track + VRC6_Track + VRC7_Track + OPLL_Track + MMC5_Track + N163_Track + PSG_Track + NULL_Track
000D1Ar 3               	.ifdef	SE
000D1Ar 3               	  SE_Track	= 5		;
000D1Ar 3               	.else
000D1Ar 3               	  SE_Track	= 2		;
000D1Ar 3               	.endif
000D1Ar 3               
000D1Ar 3               	Track		= BGM_Track + SE_Track
000D1Ar 3               
000D1Ar 3               	TR_BGM1		= 0
000D1Ar 3               	TR_BGM2		= 2
000D1Ar 3               	TR_BGM3		= 4
000D1Ar 3               	TR_BGM4		= 6
000D1Ar 3               	TR_BGM5		= 8
000D1Ar 3               	TR_SE		= BGM_Track * 2
000D1Ar 3               	.ifdef	SE
000D1Ar 3               	TR_SE_Pluse1	= TR_SE + 0
000D1Ar 3               	TR_SE_Pluse2	= TR_SE + 2
000D1Ar 3               	TR_SE_Tri	= TR_SE + 4
000D1Ar 3               	TR_SE_Noise	= TR_SE + 6
000D1Ar 3               	TR_SE_Dpcm	= TR_SE + 8
000D1Ar 3               	.else
000D1Ar 3               	TR_SE_Pluse2	= TR_SE + 0
000D1Ar 3               	TR_SE_Noise	= TR_SE + 2
000D1Ar 3               	.endif
000D1Ar 3               
000D1Ar 3               .endscope
000D1Ar 3               
000D1Ar 3               
000D1Ar 3               
000D1Ar 3               
000D1Ar 3               
000D1Ar 3               ;****************************************************************
000D1Ar 3               ;*	Struct Define						*
000D1Ar 3               ;****************************************************************
000D1Ar 3               
000D1Ar 3               ;=======================================================================
000D1Ar 3               ;	Working Struct define in Zero-page area
000D1Ar 3               ;-----------------------------------------------------------------------
000D1Ar 3               
000D1Ar 3               .Struct		NSD_Envelop
000D1Ar 3               	V		.byte		;Volume & Voice (ch3:Tempo / ch5:Tempo_ctr)
000D1Ar 3               	F		.byte		;Frequency & Note
000D1Ar 3               .Endstruct
000D1Ar 3               
000D1Ar 3               .Struct		NSD_Length_Cnt
000D1Ar 3               	counter		.byte		;now length of note
000D1Ar 3               	gate		.byte		;length - u
000D1Ar 3               .Endstruct
000D1Ar 3               
000D1Ar 3               .Struct		NSD_work_zp
000D1Ar 3               	_ptr		.word					;00 General pointer value
000D1Ar 3               	_tmp		.word					;02 General value
000D1Ar 3               	channel		.byte					;04 channel (x resister)
000D1Ar 3               	flag		.byte					;05 flag
000D1Ar 3               	Sequence_ptr	.word			nsd::Track	;06 Address of playing sequence
000D1Ar 3               .ifndef	HFX4
000D1Ar 3               	LengthCnt	.tag	NSD_Length_Cnt	nsd::Track	;16 Length Counter
000D1Ar 3               .endif
000D1Ar 3               	Envelop		.tag	NSD_Envelop	nsd::Track	;26 Envelop counter
000D1Ar 3               .Endstruct
000D1Ar 3               
000D1Ar 3               ; 6 + ( 6 [Byte] * 28 [ch] ) = 174
000D1Ar 3               
000D1Ar 3               ;---------------------------------------
000D1Ar 3               ;	Defines for work structures
000D1Ar 3               
000D1Ar 3               .scope	nsd_flag
000D1Ar 3               	BGM		= $01	;Playing BGM
000D1Ar 3               	SE		= $02	;Playing SE
000D1Ar 3               	Jump		= $10	;
000D1Ar 3               	Priority	= $0C	;Priority of now SE
000D1Ar 3               	Disable		= $80	;Disable of sound driver
000D1Ar 3               .endscope
000D1Ar 3               
000D1Ar 3               ;Zero Page Works
000D1Ar 3               .define	__ptr		nsd_work_zp + NSD_work_zp::_ptr
000D1Ar 3               .define	__tmp		nsd_work_zp + NSD_work_zp::_tmp
000D1Ar 3               .define	__flag		nsd_work_zp + NSD_work_zp::flag
000D1Ar 3               .define	__channel	nsd_work_zp + NSD_work_zp::channel
000D1Ar 3               .define	__Sequence_ptr	nsd_work_zp + NSD_work_zp::Sequence_ptr
000D1Ar 3               
000D1Ar 3               .define	__Envelop_V	nsd_work_zp + NSD_work_zp::Envelop + NSD_Envelop::V	;upper 4bit Voice / lower 4bit:Volume
000D1Ar 3               .define	__Envelop_F	nsd_work_zp + NSD_work_zp::Envelop + NSD_Envelop::F	;upper 4bit:Note  / lower 4bit:Frequency
000D1Ar 3               
000D1Ar 3               ;.define	__flag		nsd_work_zp + NSD_work_zp::Envelop + NSD_Envelop::V + nsd::TR_BGM3
000D1Ar 3               .define	__Tempo		nsd_work_zp + NSD_work_zp::Envelop + NSD_Envelop::F + nsd::TR_BGM5
000D1Ar 3               .define	__Tempo_ctr	nsd_work_zp + NSD_work_zp::Envelop + NSD_Envelop::V + nsd::TR_BGM5
000D1Ar 3               
000D1Ar 3               
000D1Ar 3               
000D1Ar 3               
000D1Ar 3               
000D1Ar 3               ;=======================================================================
000D1Ar 3               ;	Working  Struct define in RAM area
000D1Ar 3               ;-----------------------------------------------------------------------
000D1Ar 3               
000D1Ar 3               .Struct		NSD_Flag
000D1Ar 3               	flag		.byte		;flag
000D1Ar 3               	gatemode	.byte		;gate mode
000D1Ar 3               .Endstruct
000D1Ar 3               
000D1Ar 3               .Struct		NSD_length
000D1Ar 3               	length		.byte		;`l' command value
000D1Ar 3               	tai		.byte		;flag of Tai & Slur
000D1Ar 3               .Endstruct
000D1Ar 3               
000D1Ar 3               .Struct		NSD_gatetime
000D1Ar 3               	q		.byte		;`q' command value
000D1Ar 3               	u		.byte		;`u' command value
000D1Ar 3               .Endstruct
000D1Ar 3               
000D1Ar 3               .Struct		NSD_note
000D1Ar 3               	note		.byte		;`note' command value (bit 7 = `H' : rest)
000D1Ar 3               	octave		.byte		;`o' command value
000D1Ar 3               .Endstruct
000D1Ar 3               
000D1Ar 3               .Struct		NSD_Detune
000D1Ar 3               	cent		.byte		;`D' command value
000D1Ar 3               	fine		.byte		;`D%' command value
000D1Ar 3               .Endstruct
000D1Ar 3               
000D1Ar 3               .Struct		NSD_Por_Lv		;(ch5 : BGM1 & BGM2 Frequency)
000D1Ar 3               	target		.byte		;`P' target
000D1Ar 3               	depth		.byte		;`P' add value
000D1Ar 3               .Endstruct
000D1Ar 3               
000D1Ar 3               .Struct		NSD_Por_Co		;(ch5 : BGM3 & SE  Frequency)
000D1Ar 3               	count		.byte		;rate control
000D1Ar 3               	rate		.byte		;now depth
000D1Ar 3               .Endstruct
000D1Ar 3               
000D1Ar 3               .Struct		NSD_Trans
000D1Ar 3               	trans		.byte		;`_' command value
000D1Ar 3               	onetime		.byte		;`'', `"' command value
000D1Ar 3               .Endstruct
000D1Ar 3               
000D1Ar 3               .Struct		NSD_Repeat
000D1Ar 3               	count1		.byte		;counter of repeat(A)
000D1Ar 3               	count2		.byte		;counter of repeat(B)
000D1Ar 3               .Endstruct
000D1Ar 3               
000D1Ar 3               .Struct		NSD_volume
000D1Ar 3               	volume		.byte		;`v' & `vR' command value
000D1Ar 3               	volume_env	.byte		;now envelop volume	(ch3,5 : sweep value of ch1,2)
000D1Ar 3               .Endstruct
000D1Ar 3               
000D1Ar 3               ;.Struct		NSD_voice
000D1Ar 3               ;	voice		.byte		;`@R' command value (upper 4bit)	;p~
000D1Ar 3               ;	voice_set	.byte		;deveice setting value
000D1Ar 3               ;.Endstruct
000D1Ar 3               
000D1Ar 3               .Struct		NSD_Env_V_Ptr		;(ch5 : pointer of PCM information)
000D1Ar 3               	Volume		.byte		;Volume
000D1Ar 3               	Voice		.byte		;Voice
000D1Ar 3               .Endstruct
000D1Ar 3               
000D1Ar 3               .Struct		NSD_Env_F_Ptr
000D1Ar 3               	Frequency	.byte		;Freeuqncy
000D1Ar 3               	Note		.byte		;Note
000D1Ar 3               .Endstruct
000D1Ar 3               
000D1Ar 3               .Struct		NSD_Env_F_Now
000D1Ar 3               	Frequency	.byte		;now envelop Freeuqncy
000D1Ar 3               	Note		.byte		;now envelop Note
000D1Ar 3               .Endstruct
000D1Ar 3               
000D1Ar 3               .Struct		NSD_work
000D1Ar 3               	Flag		.tag	NSD_Flag	nsd::Track	;flag
000D1Ar 3               .ifdef	HFX4
000D1Ar 3               	LengthCnt	.tag	NSD_Length_Cnt	nsd::Track	;16 Length Counter
000D1Ar 3               .endif
000D1Ar 3               	Length		.tag	NSD_length	nsd::Track	;note length [tick]
000D1Ar 3               	Gatetime	.tag	NSD_gatetime	nsd::Track	;gate time [tick]
000D1Ar 3               	Note		.tag	NSD_note	nsd::Track	;octave and note command
000D1Ar 3               	Detune		.tag	NSD_Detune	nsd::Track	;detune
000D1Ar 3               	Por_Lv		.tag	NSD_Por_Lv	nsd::Track	;Portamento / TR5: BGM1 & BGM2 frequency
000D1Ar 3               	Por_Co		.tag	NSD_Por_Co	nsd::Track	;Portamento / TR5: BGM3 & SE1  frequency
000D1Ar 3               	Por_now		.word			nsd::Track	;Portamento / TR5: SE2  & SE3  frequency
000D1Ar 3               	Trans		.tag	NSD_Trans	nsd::Track	;Transpose
000D1Ar 3               	Repeat		.tag	NSD_Repeat	nsd::Track	;Repeat
000D1Ar 3               	Volume		.tag	NSD_volume	nsd::Track	;volume	/ TR3: BGM1 sweep / TR5: BGM2 sweep
000D1Ar 3               	Env_F_Now	.tag	NSD_Env_F_Now	nsd::Track	;Now value of envelop
000D1Ar 3               	Env_V_Ptr	.tag	NSD_Env_V_Ptr	nsd::Track	;Address of envelop / TR5:DPCM info
000D1Ar 3               	Env_F_Ptr	.tag	NSD_Env_F_Ptr	nsd::Track	;Address of envelop
000D1Ar 3               	Envelop_Volume	.word			nsd::Track	;Pointer of envelop
000D1Ar 3               	Envelop_Voice	.word			nsd::Track	;Pointer of envelop
000D1Ar 3               	Envelop_Freq	.word			nsd::Track	;Pointer of envelop
000D1Ar 3               	Envelop_Note	.word			nsd::Track	;Pointer of envelop
000D1Ar 3               	Frequency	.word			nsd::Track	;Setting frequency
000D1Ar 3               	SubRoutine	.word			nsd::Track	;Pointer of sub-routine return address
000D1Ar 3               	Repeat2		.word			nsd::Track	;Pointer of repeat2 goto point
000D1Ar 3               
000D1Ar 3               ;.ifdef	MMC5
000D1Ar 3               ;	MMC5_Frequency	.byte			nsd::MMC5_Track	;MMC5 frequency
000D1Ar 3               ;.endif
000D1Ar 3               
000D1Ar 3               .ifdef	FDS
000D1Ar 3               	FDS_Frequency	.byte					;FDS frequency
000D1Ar 3               	FDS_SweepBias	.byte					;FDS Sweep bias
000D1Ar 3               .endif
000D1Ar 3               
000D1Ar 3               .ifdef	MMC5
000D1Ar 3               	MMC5_VoiceSet	.byte			nsd::MMC5_Track
000D1Ar 3               	MMC5_Frequency	.byte			nsd::MMC5_Track	;MMC5 frequecny
000D1Ar 3               .endif
000D1Ar 3               
000D1Ar 3               .ifdef	VRC7
000D1Ar 3               	VRC7_VoiceSet	.byte			nsd::VRC7_Track
000D1Ar 3               	VRC7_Freq_old	.byte			nsd::VRC7_Track
000D1Ar 3               	VRC7_Frequency	.word			nsd::VRC7_Track	;VRC7 frequecny
000D1Ar 3               	VRC7_Reg	.word					;
000D1Ar 3               .endif
000D1Ar 3               
000D1Ar 3               .ifdef	OPLL
000D1Ar 3               	OPLL_VoiceSet	.byte			nsd::OPLL_Track_FM
000D1Ar 3               	OPLL_Freq_old	.byte			nsd::OPLL_Track_FM
000D1Ar 3               	OPLL_Frequency	.word			nsd::OPLL_Track_FM	;OPLL frequency (FM)
000D1Ar 3               	OPLL_Reg	.word
000D1Ar 3               	OPLL_Rhythm	.byte						;OPLL Rhythm
000D1Ar 3               .endif
000D1Ar 3               
000D1Ar 3               .ifdef	N163
000D1Ar 3               	N163_num	.byte					;N163 ch number
000D1Ar 3               	N163_Frequency	.byte			nsd::N163_Track	;N163 frequency
000D1Ar 3               .endif
000D1Ar 3               
000D1Ar 3               .ifdef	PSG
000D1Ar 3               	PSG_switch	.byte					;PSG switch
000D1Ar 3               .endif
000D1Ar 3               
000D1Ar 3               .Endstruct
000D1Ar 3               
000D1Ar 3               
000D1Ar 3               
000D1Ar 3               ;---------------------------------------
000D1Ar 3               ;	Defines for work structures
000D1Ar 3               
000D1Ar 3               .scope	nsd_chflag
000D1Ar 3               .ifdef	MASK
000D1Ar 3               	Mask	= $80
000D1Ar 3               .endif
000D1Ar 3               	Sustain	= $20		;for VRC7
000D1Ar 3               	KeyOn	= $10		;for VRC7
000D1Ar 3               	Envelop	= $10		;for PSG
000D1Ar 3               	FDSVOL	= $0C
000D1Ar 3               	NoKeyOff= $04		;for VRC7
000D1Ar 3               	KeyOff	= $03		;00	Key Off	: Vol = 0
000D1Ar 3               				;01	Key Off	: Release command
000D1Ar 3               				;10	Key Off	:  envelop
000D1Ar 3               				;11	Note On	: (envelop)
000D1Ar 3               .endscope
000D1Ar 3               
000D1Ar 3               .scope	nsd_mode
000D1Ar 3               	voiceR		= $F0	;1111 0000	Release Volume
000D1Ar 3               	voice		= $08	;0000 1000
000D1Ar 3               	RetSE		= $04	;0000 0100	Key On (Ch.3)
000D1Ar 3               	gatemode	= $03	;0000 0011	Gate mode
000D1Ar 3               .endscope
000D1Ar 3               
000D1Ar 3               
000D1Ar 3               ;RAM Works
000D1Ar 3               .ifdef	HFX4
000D1Ar 3               .define	__Length_ctr	nsd_work + NSD_work::LengthCnt + NSD_Length_Cnt::counter
000D1Ar 3               .define	__Gate		nsd_work + NSD_work::LengthCnt + NSD_Length_Cnt::gate
000D1Ar 3               .else
000D1Ar 3               .define	__Length_ctr	nsd_work_zp + NSD_work_zp::LengthCnt + NSD_Length_Cnt::counter
000D1Ar 3               .define	__Gate		nsd_work_zp + NSD_work_zp::LengthCnt + NSD_Length_Cnt::gate
000D1Ar 3               .endif
000D1Ar 3               
000D1Ar 3               .define	__chflag	nsd_work + NSD_work::Flag + NSD_Flag::flag
000D1Ar 3               .define	__gatemode	nsd_work + NSD_work::Flag + NSD_Flag::gatemode
000D1Ar 3               .define	__tai		nsd_work + NSD_work::Length + NSD_length::tai
000D1Ar 3               .define	__length	nsd_work + NSD_work::Length + NSD_length::length
000D1Ar 3               .define	__gate_q	nsd_work + NSD_work::Gatetime + NSD_gatetime::q
000D1Ar 3               .define	__gate_u	nsd_work + NSD_work::Gatetime + NSD_gatetime::u
000D1Ar 3               .define __note		nsd_work + NSD_work::Note + NSD_note::note
000D1Ar 3               .define	__octave	nsd_work + NSD_work::Note + NSD_note::octave
000D1Ar 3               .define	__detune_cent	nsd_work + NSD_work::Detune + NSD_Detune::cent
000D1Ar 3               .define	__detune_fine	nsd_work + NSD_work::Detune + NSD_Detune::fine
000D1Ar 3               .define	__por_target	nsd_work + NSD_work::Por_Lv + NSD_Por_Lv::target
000D1Ar 3               .define	__por_depth	nsd_work + NSD_work::Por_Lv + NSD_Por_Lv::depth
000D1Ar 3               .define	__por_ctr	nsd_work + NSD_work::Por_Co + NSD_Por_Co::count
000D1Ar 3               .define	__por_rate	nsd_work + NSD_work::Por_Co + NSD_Por_Co::rate
000D1Ar 3               .define __por_now	nsd_work + NSD_work::Por_now
000D1Ar 3               .define	__trans		nsd_work + NSD_work::Trans + NSD_Trans::trans
000D1Ar 3               .define	__trans_one	nsd_work + NSD_work::Trans + NSD_Trans::onetime
000D1Ar 3               .define	__repeat_ctr	nsd_work + NSD_work::Repeat + NSD_Repeat::count1
000D1Ar 3               .define	__repeat_ctr2	nsd_work + NSD_work::Repeat + NSD_Repeat::count2
000D1Ar 3               .define	__volume	nsd_work + NSD_work::Volume + NSD_volume::volume
000D1Ar 3               .define	__frequency	nsd_work + NSD_work::Frequency
000D1Ar 3               .define	__subroutine	nsd_work + NSD_work::SubRoutine
000D1Ar 3               .define	__repeat2	nsd_work + NSD_work::Repeat2
000D1Ar 3               .define	__env_volume	nsd_work + NSD_work::Envelop_Volume
000D1Ar 3               .define	__env_voice	nsd_work + NSD_work::Envelop_Voice
000D1Ar 3               .define	__env_frequency	nsd_work + NSD_work::Envelop_Freq
000D1Ar 3               .define	__env_note	nsd_work + NSD_work::Envelop_Note
000D1Ar 3               .define	__env_vol_ptr	nsd_work + NSD_work::Env_V_Ptr + NSD_Env_V_Ptr::Volume
000D1Ar 3               .define	__env_voi_ptr	nsd_work + NSD_work::Env_V_Ptr + NSD_Env_V_Ptr::Voice
000D1Ar 3               .define	__env_freq_ptr	nsd_work + NSD_work::Env_F_Ptr + NSD_Env_F_Ptr::Frequency
000D1Ar 3               .define	__env_note_ptr	nsd_work + NSD_work::Env_F_Ptr + NSD_Env_F_Ptr::Note
000D1Ar 3               ;	voiceɊւẮǍ̉Ẑ͖ŁAXVȂꍇ̓Gx[vIB
000D1Ar 3               .define	__env_vol_now	nsd_work + NSD_work::Volume + NSD_volume::volume_env
000D1Ar 3               .define	__env_freq_now	nsd_work + NSD_work::Env_F_Now + NSD_Env_F_Now::Frequency
000D1Ar 3               .define	__env_note_now	nsd_work + NSD_work::Env_F_Now + NSD_Env_F_Now::Note
000D1Ar 3               
000D1Ar 3               ;---------------
000D1Ar 3               ;PCM
000D1Ar 3               .define	__dpcm_info		nsd_work + NSD_work::Env_V_Ptr + nsd::TR_BGM5		;.word
000D1Ar 3               
000D1Ar 3               ;Sweep
000D1Ar 3               .define	__sweep_ch1		nsd_work + NSD_work::Envelop_Voice  + nsd::TR_BGM3
000D1Ar 3               .define	__sweep_ch2		nsd_work + NSD_work::Envelop_Voice  + nsd::TR_BGM3 + 1
000D1Ar 3               ;.define	__sweep_ch1		nsd_work + NSD_work::Volume + NSD_volume::volume     + nsd::TR_BGM5
000D1Ar 3               ;.define	__sweep_ch2		nsd_work + NSD_work::Volume + NSD_volume::volume_env + nsd::TR_BGM5
000D1Ar 3               
000D1Ar 3               
000D1Ar 3               ;Voice
000D1Ar 3               ;.define	__apu_tri_time		nsd_work + NSD_work::Envelop_Voice  + nsd::TR_BGM5
000D1Ar 3               ;.define	__apu_voice_set4	nsd_work + NSD_work::Envelop_Voice  + nsd::TR_BGM5 + 1
000D1Ar 3               ;.define	__se_voice_set1		nsd_work + NSD_work::Env_F_Ptr + NSD_Env_F_Ptr::Frequency  + nsd::TR_BGM5
000D1Ar 3               ;.define	__se_voice_set2		nsd_work + NSD_work::Env_F_Ptr + NSD_Env_F_Ptr::Note       + nsd::TR_BGM5
000D1Ar 3               .define	__apu_voice_set1	nsd_work + NSD_work::Envelop_Volume + nsd::TR_BGM5
000D1Ar 3               .define	__apu_voice_set2	nsd_work + NSD_work::Envelop_Volume + nsd::TR_BGM5 + 1
000D1Ar 3               .define	__apu_tri_time		nsd_work + NSD_work::Envelop_Freq   + nsd::TR_BGM5
000D1Ar 3               .define	__apu_voice_set4	nsd_work + NSD_work::Envelop_Freq   + nsd::TR_BGM5 + 1
000D1Ar 3               
000D1Ar 3               .ifdef	SE
000D1Ar 3               .define	__se_voice_set1		nsd_work + NSD_work::Frequency      + nsd::TR_BGM5
000D1Ar 3               .endif
000D1Ar 3               .define	__se_voice_set2		nsd_work + NSD_work::Frequency      + nsd::TR_BGM5 + 1
000D1Ar 3               .ifdef	SE
000D1Ar 3               .define	__se_tri_time		nsd_work + NSD_work::Envelop_Voice  + nsd::TR_BGM5
000D1Ar 3               .endif
000D1Ar 3               .define	__se_voice_set4		nsd_work + NSD_work::Envelop_Voice  + nsd::TR_BGM5 + 1
000D1Ar 3               
000D1Ar 3               ;Frequency	iv`mCYh~j
000D1Ar 3               .define	__apu_frequency1	nsd_work + NSD_work::Por_Lv    + nsd::TR_BGM5		;.byte
000D1Ar 3               .define	__apu_frequency2	nsd_work + NSD_work::Por_Lv    + nsd::TR_BGM5 + 1	;.byte
000D1Ar 3               .define	__apu_frequency3	nsd_work + NSD_work::Por_Co    + nsd::TR_BGM5		;.byte
000D1Ar 3               .ifdef	SE
000D1Ar 3               .define	__se_frequency1		nsd_work + NSD_work::Por_Co    + nsd::TR_BGM5 + 1	;.byte
000D1Ar 3               .endif
000D1Ar 3               .define	__se_frequency2		nsd_work + NSD_work::Por_now   + nsd::TR_BGM5		;.byte
000D1Ar 3               .ifdef	SE
000D1Ar 3               .define	__se_frequency3		nsd_work + NSD_work::Por_now   + nsd::TR_BGM5 + 1	;.byte
000D1Ar 3               .endif
000D1Ar 3               
000D1Ar 3               .ifdef	FDS
000D1Ar 3               .define	__fds_frequency		nsd_work + NSD_work::FDS_Frequency
000D1Ar 3               .define	__fds_sweepbias		nsd_work + NSD_work::FDS_SweepBias
000D1Ar 3               .endif
000D1Ar 3               
000D1Ar 3               .ifdef	MMC5
000D1Ar 3               ;.define	__mmc5_voice_set1	nsd_work + NSD_work::Envelop_Freq   + nsd::TR_BGM5	;.byte
000D1Ar 3               ;.define	__mmc5_voice_set2	nsd_work + NSD_work::Envelop_Freq   + nsd::TR_BGM5 + 1	;.byte
000D1Ar 3               .define	__mmc5_voice_set1	nsd_work + NSD_work::MMC5_VoiceSet
000D1Ar 3               .define	__mmc5_voice_set2	nsd_work + NSD_work::MMC5_VoiceSet + 1
000D1Ar 3               .define	__mmc5_frequency1	nsd_work + NSD_work::MMC5_Frequency
000D1Ar 3               .define	__mmc5_frequency2	nsd_work + NSD_work::MMC5_Frequency + 1
000D1Ar 3               .endif
000D1Ar 3               
000D1Ar 3               .ifdef	VRC6
000D1Ar 3               .define	__vrc6_voice_set1	nsd_work + NSD_work::Envelop_Note   + nsd::TR_BGM5	;.byte
000D1Ar 3               .define	__vrc6_voice_set2	nsd_work + NSD_work::Envelop_Note   + nsd::TR_BGM5 + 1	;.byte
000D1Ar 3               .endif
000D1Ar 3               
000D1Ar 3               .ifdef	VRC7
000D1Ar 3               .define	__vrc7_voice_set	nsd_work + NSD_work::VRC7_VoiceSet
000D1Ar 3               .define	__vrc7_frequency	nsd_work + NSD_work::VRC7_Frequency
000D1Ar 3               .define	__vrc7_freq_old		nsd_work + NSD_work::VRC7_Freq_old
000D1Ar 3               .define	__vrc7_reg		nsd_work + NSD_work::VRC7_Reg
000D1Ar 3               .endif
000D1Ar 3               
000D1Ar 3               .ifdef	OPLL
000D1Ar 3               .define	__opll_voice_set	nsd_work + NSD_work::OPLL_VoiceSet
000D1Ar 3               .define	__opll_frequency	nsd_work + NSD_work::OPLL_Frequency
000D1Ar 3               .define	__opll_freq_old		nsd_work + NSD_work::OPLL_Freq_old
000D1Ar 3               .define	__opll_reg		nsd_work + NSD_work::OPLL_Reg
000D1Ar 3               .define	__opll_ryhthm		nsd_work + NSD_work::OPLL_Rhythm
000D1Ar 3               .endif
000D1Ar 3               
000D1Ar 3               .ifdef	N163
000D1Ar 3               .define	__n163_num		nsd_work + NSD_work::N163_num
000D1Ar 3               .define	__n163_frequency	nsd_work + NSD_work::N163_Frequency
000D1Ar 3               .endif
000D1Ar 3               
000D1Ar 3               .ifdef	PSG
000D1Ar 3               .define	__psg_switch		nsd_work + NSD_work::PSG_switch
000D1Ar 3               .endif
000D1Ar 3               
000D1Ar 3               
000D1Ar 3               
000D1Ar 3               
000D1Ar 3               
000D1Ar 3               ;=======================================================================
000D1Ar 3               ;		Struct of DPCM
000D1Ar 3               ;-----------------------------------------------------------------------
000D1Ar 3               .Struct		nsd_dpcm
000D1Ar 3               	Control		.byte		;I/O 0x4010
000D1Ar 3               	DA		.byte		;I/O 0x4011
000D1Ar 3               	Address		.byte		;I/O 0x4012
000D1Ar 3               	Size		.byte		;I/O 0x4013
000D1Ar 3               .ifdef	DPCMBank
000D1Ar 3               	Bank		.byte		;Bank number
000D1Ar 3               	Next		.byte		;Next number(note)
000D1Ar 3               .endif
000D1Ar 3               .Endstruct
000D1Ar 3               
000D1Ar 3               
000D1Ar 3               
000D1Ar 3               
000D1Ar 3               
000D1Ar 3               ;****************************************************************
000D1Ar 3               ;*	Macros							*
000D1Ar 3               ;****************************************************************
000D1Ar 3               
000D1Ar 3               ;=======================================================================
000D1Ar 3               ;	void	NSD_MAIN_BGM()
000D1Ar 3               ;-----------------------------------------------------------------------
000D1Ar 3               ;<<Contents>>
000D1Ar 3               ;	BGM main routine
000D1Ar 3               ;<<Input>>
000D1Ar 3               ;	none
000D1Ar 3               ;<<Output>>
000D1Ar 3               ;	none
000D1Ar 3               ;=======================================================================
000D1Ar 3               .macro	NSD_MAIN_BGM
000D1Ar 3               	.local	BGM_Begin
000D1Ar 3               	.local	BGM_SEQ_Exit
000D1Ar 3               	.local	BGM_Exit
000D1Ar 3               
000D1Ar 3               	lda	#nsd_flag::BGM
000D1Ar 3               	bit	__flag
000D1Ar 3               	jne	BGM_Exit		;BGM disable ?
000D1Ar 3               
000D1Ar 3               	;-------------------------------
000D1Ar 3               	;Tempo
000D1Ar 3               	lda	__Tempo_ctr
000D1Ar 3               	add	__Tempo
000D1Ar 3               	sta	__Tempo_ctr
000D1Ar 3               	jcc	BGM_SEQ_Exit
000D1Ar 3               
000D1Ar 3               	;-------------------------------
000D1Ar 3               	;BGM
000D1Ar 3               BGM_Begin:
000D1Ar 3               	.repeat	nsd::BGM_Track, I
000D1Ar 3               		ldx	#I*2 + nsd::TR_BGM1
000D1Ar 3               		jsr	nsd_sequence
000D1Ar 3               	.endrepeat
000D1Ar 3               
000D1Ar 3               	lda	#nsd_flag::Jump
000D1Ar 3               	bit	__flag
000D1Ar 3               	jne	BGM_Begin
000D1Ar 3               
000D1Ar 3               	lda	__Tempo_ctr
000D1Ar 3               	sub	#Tempo_Sub
000D1Ar 3               	sta	__Tempo_ctr
000D1Ar 3               	cmp	#Tempo_Cmp
000D1Ar 3               	jcc	BGM_Begin
000D1Ar 3               
000D1Ar 3               BGM_SEQ_Exit:
000D1Ar 3               
000D1Ar 3               	;-------
000D1Ar 3               	;Envelop
000D1Ar 3               	.repeat	nsd::BGM_Track, I
000D1Ar 3               	  ;No envelope: DPCM, NULL
000D1Ar 3               	  .if	(I <> 4) && (!(.defined(NULL) && (I = (nsd::TR_NULL / 2))))
000D1Ar 3               		ldx	#I*2 + nsd::TR_BGM1
000D1Ar 3               		jsr	nsd_envelop
000D1Ar 3               	  .endif
000D1Ar 3               	.endrepeat
000D1Ar 3               
000D1Ar 3               BGM_Exit:
000D1Ar 3               
000D1Ar 3               .endmacro
000D1Ar 3               
000D1Ar 3               ;=======================================================================
000D1Ar 3               ;	void	NSD_MAIN_SE()
000D1Ar 3               ;-----------------------------------------------------------------------
000D1Ar 3               ;<<Contents>>
000D1Ar 3               ;	SE main routine
000D1Ar 3               ;<<Input>>
000D1Ar 3               ;	none
000D1Ar 3               ;<<Output>>
000D1Ar 3               ;	none
000D1Ar 3               ;=======================================================================
000D1Ar 3               .macro	NSD_MAIN_SE
000D1Ar 3               	.local	SE1
000D1Ar 3               	.local	SE2
000D1Ar 3               	.local	SE3
000D1Ar 3               	.local	SE4
000D1Ar 3               	.local	SE5
000D1Ar 3               	.local	SE_Exit
000D1Ar 3               
000D1Ar 3               	lda	#nsd_flag::SE
000D1Ar 3               	bit	__flag
000D1Ar 3               	bne	SE_Exit			;SE disable ?
000D1Ar 3               
000D1Ar 3               ;---------------------------------------
000D1Ar 3               .ifdef	SE
000D1Ar 3               SE1:
000D1Ar 3               	ldx	#nsd::TR_SE_Pluse1
000D1Ar 3               	lda	__Sequence_ptr + 1,x
000D1Ar 3               .ifdef	DPCMBank
000D1Ar 3               	ora	__Sequence_ptr,x
000D1Ar 3               .endif
000D1Ar 3               	beq	@L
000D1Ar 3               	jsr	nsd_sequence
000D1Ar 3               	jsr	nsd_envelop
000D1Ar 3               @L:
000D1Ar 3               .endif
000D1Ar 3               
000D1Ar 3               ;---------------------------------------
000D1Ar 3               SE2:
000D1Ar 3               	ldx	#nsd::TR_SE_Pluse2
000D1Ar 3               	lda	__Sequence_ptr + 1,x
000D1Ar 3               .ifdef	DPCMBank
000D1Ar 3               	ora	__Sequence_ptr,x
000D1Ar 3               .endif
000D1Ar 3               	beq	@L
000D1Ar 3               	jsr	nsd_sequence
000D1Ar 3               	jsr	nsd_envelop
000D1Ar 3               @L:
000D1Ar 3               
000D1Ar 3               ;---------------------------------------
000D1Ar 3               .ifdef	SE
000D1Ar 3               SE3:
000D1Ar 3               	ldx	#nsd::TR_SE_Tri
000D1Ar 3               	lda	__Sequence_ptr + 1,x
000D1Ar 3               .ifdef	DPCMBank
000D1Ar 3               	ora	__Sequence_ptr,x
000D1Ar 3               .endif
000D1Ar 3               	beq	@L
000D1Ar 3               	jsr	nsd_sequence
000D1Ar 3               	jsr	nsd_envelop
000D1Ar 3               @L:
000D1Ar 3               .endif
000D1Ar 3               
000D1Ar 3               ;---------------------------------------
000D1Ar 3               SE4:
000D1Ar 3               	ldx	#nsd::TR_SE_Noise
000D1Ar 3               	lda	__Sequence_ptr + 1,x
000D1Ar 3               .ifdef	DPCMBank
000D1Ar 3               	ora	__Sequence_ptr,x
000D1Ar 3               .endif
000D1Ar 3               	beq	@L
000D1Ar 3               	jsr	nsd_sequence
000D1Ar 3               	jsr	nsd_envelop
000D1Ar 3               @L:
000D1Ar 3               
000D1Ar 3               ;---------------------------------------
000D1Ar 3               .ifdef	SE
000D1Ar 3               SE5:
000D1Ar 3               	ldx	#nsd::TR_SE_Dpcm
000D1Ar 3               	lda	__Sequence_ptr + 1,x
000D1Ar 3               .ifdef	DPCMBank
000D1Ar 3               	ora	__Sequence_ptr,x
000D1Ar 3               .endif
000D1Ar 3               	beq	@L
000D1Ar 3               	jsr	nsd_sequence
000D1Ar 3               @L:
000D1Ar 3               .endif
000D1Ar 3               ;---------------------------------------
000D1Ar 3               
000D1Ar 3               	lda	__Sequence_ptr + 1 + nsd::TR_SE_Pluse2
000D1Ar 3               	ora	__Sequence_ptr + 1 + nsd::TR_SE_Noise
000D1Ar 3               .ifdef	SE
000D1Ar 3               	ora	__Sequence_ptr + 1 + nsd::TR_SE_Pluse1
000D1Ar 3               	ora	__Sequence_ptr + 1 + nsd::TR_SE_Tri
000D1Ar 3               	ora	__Sequence_ptr + 1 + nsd::TR_SE_Dpcm
000D1Ar 3               .endif
000D1Ar 3               .ifdef	DPCMBank
000D1Ar 3               	ora	__Sequence_ptr + nsd::TR_SE_Pluse2
000D1Ar 3               	ora	__Sequence_ptr + nsd::TR_SE_Noise
000D1Ar 3               .ifdef	SE
000D1Ar 3               	ora	__Sequence_ptr + nsd::TR_SE_Pluse1
000D1Ar 3               	ora	__Sequence_ptr + nsd::TR_SE_Tri
000D1Ar 3               	ora	__Sequence_ptr + nsd::TR_SE_Dpcm
000D1Ar 3               .endif
000D1Ar 3               .endif
000D1Ar 3               
000D1Ar 3               	bne	SE_Exit
000D1Ar 3               
000D1Ar 3               ;-----------------------------------------------------------
000D1Ar 3               ;
000D1Ar 3               ;	ldx	#nsd::TR_SE_Pluse2
000D1Ar 3               ;	lda	__Sequence_ptr + 1,x
000D1Ar 3               ;.ifdef	DPCMBank
000D1Ar 3               ;	ora	__Sequence_ptr,x
000D1Ar 3               ;.endif
000D1Ar 3               ;	beq	SE0
000D1Ar 3               ;	jsr	nsd_sequence
000D1Ar 3               ;	jsr	nsd_envelop
000D1Ar 3               ;SE0:
000D1Ar 3               ;	ldx	#nsd::TR_SE_Noise
000D1Ar 3               ;	lda	__Sequence_ptr + 1,x
000D1Ar 3               ;.ifdef	DPCMBank
000D1Ar 3               ;	ora	__Sequence_ptr,x
000D1Ar 3               ;.endif
000D1Ar 3               ;	beq	SE1
000D1Ar 3               ;	jsr	nsd_sequence
000D1Ar 3               ;	jsr	nsd_envelop
000D1Ar 3               ;	jmp	SE_Exit
000D1Ar 3               ;SE1:
000D1Ar 3               ;	ora	__Sequence_ptr + nsd::TR_SE_Pluse2 + 1
000D1Ar 3               ;.ifdef	DPCMBank
000D1Ar 3               ;	ora	__Sequence_ptr + nsd::TR_SE_Pluse2
000D1Ar 3               ;.endif
000D1Ar 3               ;	bne	SE_Exit
000D1Ar 3               ;
000D1Ar 3               ;-----------------------------------------------------------
000D1Ar 3               
000D1Ar 3               	;SE Disable
000D1Ar 3               	lda	#nsd_flag::SE
000D1Ar 3               	ora	__flag
000D1Ar 3               	sta	__flag
000D1Ar 3               SE_Exit:
000D1Ar 3               
000D1Ar 3               .endmacro
000D1Ar 3               
000D1Ar 2               
000D1Ar 2               ;****************************************************************
000D1Ar 2               ;*		Function of Library				*
000D1Ar 2               ;****************************************************************
000D1Ar 2               ;-----------------------------------------------
000D1Ar 2               ;	void	__fastcall__	nsd_main(void);
000D1Ar 2               ;-----------------------------------------------
000D1Ar 2               ;	Summary :		main routine of this sound driver
000D1Ar 2               ;	Arguments :		None
000D1Ar 2               ;	Return :		None
000D1Ar 2               ;	Modifies :		A X Y
000D1Ar 2               ;	Useage :		Call by 60[Hz].  e.g. V-Blank
000D1Ar 2               ;-----------------------------------------------
000D1Ar 2               	.import		_nsd_main
000D1Ar 2               	.import		_nsd_main_bgm
000D1Ar 2               	.import		_nsd_main_se
000D1Ar 2               
000D1Ar 2               
000D1Ar 2               ;-----------------------------------------------
000D1Ar 2               ;	void	__fastcall__	nsd_init(void);
000D1Ar 2               ;-----------------------------------------------
000D1Ar 2               ;	Summary :		Initraize this sound driver.
000D1Ar 2               ;	Arguments :		None
000D1Ar 2               ;	Return :		None
000D1Ar 2               ;	Modifies :		A X Y
000D1Ar 2               ;	Useage :		Call when start up.
000D1Ar 2               ;-----------------------------------------------
000D1Ar 2               	.import		_nsd_init
000D1Ar 2               
000D1Ar 2               
000D1Ar 2               ;-----------------------------------------------
000D1Ar 2               ;	void	__fastcall__	nsd_set_dpcm(nsd_dpcm* dpcm);
000D1Ar 2               ;-----------------------------------------------
000D1Ar 2               ;	Summary :		Set the Delta PCM information.
000D1Ar 2               ;	Arguments :	AX	Pointer of the Delta PCM information.
000D1Ar 2               ;	Return :		None
000D1Ar 2               ;	Modifies :		A X Y
000D1Ar 2               ;-----------------------------------------------
000D1Ar 2               	.import		_nsd_set_dpcm
000D1Ar 2               
000D1Ar 2               
000D1Ar 2               ;-----------------------------------------------
000D1Ar 2               ;	void	__fastcall__	nsd_play_bgm(void* ptr);
000D1Ar 2               ;-----------------------------------------------
000D1Ar 2               ;	Summary :		Play the BGM
000D1Ar 2               ;	Arguments :	AX	Pointer of the BGM data.
000D1Ar 2               ;	Return :		None
000D1Ar 2               ;	Modifies :		A X Y
000D1Ar 2               ;-----------------------------------------------
000D1Ar 2               	.import		_nsd_play_bgm
000D1Ar 2               
000D1Ar 2               
000D1Ar 2               ;-----------------------------------------------
000D1Ar 2               ;	void	__fastcall__	nsd_stop_bgm(void);
000D1Ar 2               ;-----------------------------------------------
000D1Ar 2               ;	Summary :		Stop the BGM
000D1Ar 2               ;	Arguments :		None
000D1Ar 2               ;	Return :		None
000D1Ar 2               ;	Modifies :		A X Y
000D1Ar 2               ;-----------------------------------------------
000D1Ar 2               	.import		_nsd_stop_bgm
000D1Ar 2               
000D1Ar 2               
000D1Ar 2               ;-----------------------------------------------
000D1Ar 2               ;	void	__fastcall__	nsd_pause_bgm(void);
000D1Ar 2               ;-----------------------------------------------
000D1Ar 2               ;	Summary :		Pause the BGM
000D1Ar 2               ;	Arguments :		None
000D1Ar 2               ;	Return :		None
000D1Ar 2               ;	Modifies :		A X Y
000D1Ar 2               ;-----------------------------------------------
000D1Ar 2               	.import		_nsd_pause_bgm
000D1Ar 2               
000D1Ar 2               
000D1Ar 2               ;-----------------------------------------------
000D1Ar 2               ;	void	__fastcall__	nsd_resume_bgm(void);
000D1Ar 2               ;-----------------------------------------------
000D1Ar 2               ;	Summary :		Resume the BGM
000D1Ar 2               ;	Arguments :		None
000D1Ar 2               ;	Return :		None
000D1Ar 2               ;	Modifies :		A X Y
000D1Ar 2               ;-----------------------------------------------
000D1Ar 2               	.import		_nsd_resume_bgm
000D1Ar 2               
000D1Ar 2               
000D1Ar 2               ;-----------------------------------------------
000D1Ar 2               ;	void	__fastcall__	_nsd_save(void* buff);
000D1Ar 2               ;-----------------------------------------------
000D1Ar 2               ;	Summary :		Save state and pause
000D1Ar 2               ;	Arguments :	AX	Pointer of Save buff
000D1Ar 2               ;	Return :		None
000D1Ar 2               ;	Modifies :		A X Y
000D1Ar 2               ;-----------------------------------------------
000D1Ar 2               	.import		_nsd_save
000D1Ar 2               
000D1Ar 2               
000D1Ar 2               ;-----------------------------------------------
000D1Ar 2               ;	void	__fastcall__	_nsd_load(void* buff);
000D1Ar 2               ;-----------------------------------------------
000D1Ar 2               ;	Summary :		Pause and Load state
000D1Ar 2               ;	Arguments :	AX	Pointer of Save buff
000D1Ar 2               ;	Return :		None
000D1Ar 2               ;	Modifies :		A X Y
000D1Ar 2               ;-----------------------------------------------
000D1Ar 2               	.import		_nsd_load
000D1Ar 2               
000D1Ar 2               
000D1Ar 2               ;-----------------------------------------------
000D1Ar 2               ;	void	__fastcall__	nsd_play_se(void* ptr);
000D1Ar 2               ;-----------------------------------------------
000D1Ar 2               ;	Summary :		Play the SE
000D1Ar 2               ;	Arguments :	AX	Pointer of the SE data.
000D1Ar 2               ;	Return :		None
000D1Ar 2               ;	Modifies :		A X Y
000D1Ar 2               ;-----------------------------------------------
000D1Ar 2               	.import		_nsd_play_se
000D1Ar 2               
000D1Ar 2               
000D1Ar 2               ;-----------------------------------------------
000D1Ar 2               ;	void	__fastcall__	nsd_stop_se(void);
000D1Ar 2               ;-----------------------------------------------
000D1Ar 2               ;	Summary :		Stop the SE
000D1Ar 2               ;	Arguments :		None
000D1Ar 2               ;	Return :		None
000D1Ar 2               ;	Modifies :		A X Y
000D1Ar 2               ;-----------------------------------------------
000D1Ar 2               	.import		_nsd_stop_se
000D1Ar 2               
000D1Ar 2               
000D1Ar 2               
000D1Ar 2               ;-----------------------------------------------
000D1Ar 2               ;	Work area of nsd.lib
000D1Ar 2               ;-----------------------------------------------
000D1Ar 2               	.importzp	nsd_work_zp
000D1Ar 2               	.import		nsd_work
000D1Ar 2               
000D1Ar 2               
000D1Ar 2               
000D1Ar 2               
000D1Ar 1               .include "nmi.asm"
000D1Ar 2               ;*------------------------------------------------------------------------------
000D1Ar 2               ; bg_buffを読み取り，指定アドレスに書き込んでカウンタをインクリメント
000D1Ar 2               ; Unused
000D1Ar 2               ; @PARAMS		ADDR: Forwarding address
000D1Ar 2               ; @CLOBBERS		A X
000D1Ar 2               ; @RETURNS		None
000D1Ar 2               ;*------------------------------------------------------------------------------
000D1Ar 2               
000D1Ar 2               .code									; ----- code -----
000D1Ar 2               
000D1Ar 2               .import _nsd_main_bgm
000D1Ar 2               
000D1Ar 2               .macro tfrDataToPPU ADDR
000D1Ar 2               	lda bg_buff, x
000D1Ar 2               	sta ADDR
000D1Ar 2               	inx
000D1Ar 2               .endmacro
000D1Ar 2               
000D1Ar 2               ; memo
000D1Ar 2               ; ----- PPU buff data structure -----
000D1Ar 2               ; r: Direction
000D1Ar 2               ; 	Bit0 is a flag, others are 1.
000D1Ar 2               ; 	-> 0b1111_111[0/1]
000D1Ar 2               ; 	-> 0xFE（Horizontal）/0xFF（Vertical）
000D1Ar 2               ; a: Addr
000D1Ar 2               ; d: Data
000D1Ar 2               ; r [a a] [d d d ... d] r [a a] [d d ... d]
000D1Ar 2               
000D1Ar 2               
000D1Ar 2               ;*------------------------------------------------------------------------------
000D1Ar 2               ; NMI (Interrupt)
000D1Ar 2               ; @CLOBBERS	 X Y (When end main process.)
000D1Ar 2               ; To shorten the clock, put the buffer data on the stack
000D1Ar 2               ; 	(Shorten clock by buff data length)
000D1Ar 2               ; 	pla -> 3 clc
000D1Ar 2               ; 	lda ZP/ABSORUTE, x -> 4 clc
000D1Ar 2               ;*------------------------------------------------------------------------------
000D1Ar 2               
000D1Ar 2               .code									; ----- code -----
000D1Ar 2               
000D1Ar 2               .proc _nmi
000D1Ar 2  48           		pha
000D1Br 2  E6 rr        		inc nmi_cnt
000D1Dr 2  A5 rr        		lda is_processing_main
000D1Fr 2  F0 05        		beq @NMI_MAIN
000D21r 2  68           		pla
000D22r 2  20 rr rr     		jsr Subfunc::_setScroll
000D25r 2  40           		rti	; --------------------------
000D26r 2               
000D26r 2               @NMI_MAIN:
000D26r 2  A5 rr        		lda is_updated_map
000D28r 2  F0 5E        		beq @PRINT
000D2Ar 2  A2 00        		ldx #0
000D2Cr 2  86 rr        		stx tmp1
000D2Er 2               @PLT_STORE_LOOP:
000D2Er 2  A5 rr        		lda plt_addr+1
000D30r 2  8D 06 20     		sta PPU_ADDR
000D33r 2               
000D33r 2  A5 rr        		lda plt_addr+0
000D35r 2  18 69 08     		add #8
000D38r 2  18 65 rr     		add tmp1
000D3Br 2  8D 06 20     		sta PPU_ADDR
000D3Er 2               
000D3Er 2  BD 34 01     		lda bg_plt_buff, x
000D41r 2  8D 07 20     		sta PPU_DATA
000D44r 2               
000D44r 2  A5 rr        		lda tmp1
000D46r 2  18 69 08     		add #8
000D49r 2  85 rr        		sta tmp1
000D4Br 2               
000D4Br 2  E8           		inx
000D4Cr 2  E0 07        		cpx #7
000D4Er 2  90 DE        		bcc @PLT_STORE_LOOP
000D50r 2               
000D50r 2  A5 rr        		lda ppu_ctrl1_cpy
000D52r 2  09 04        		ora #%0000_0100					; Vertical mode
000D54r 2  85 rr        		sta ppu_ctrl1_cpy
000D56r 2  8D 00 20     		sta PPU_CTRL1					; Not use restorePPUSet()
000D59r 2               
000D59r 2               		; line 1
000D59r 2  A5 rr        		lda ppu_bg_addr+HI
000D5Br 2  8D 06 20     		sta PPU_ADDR
000D5Er 2  A5 rr        		lda ppu_bg_addr+LO
000D60r 2  8D 06 20     		sta PPU_ADDR
000D63r 2               
000D63r 2  A2 00        		ldx #0
000D65r 2               @STORE_MAP_LOOP:
000D65r 2  BD 00 01     		lda bg_map_buff, x
000D68r 2  8D 07 20     		sta PPU_DATA
000D6Br 2  E8           		inx
000D6Cr 2  E0 1A        		cpx #$1a
000D6Er 2  D0 F5        		bne @STORE_MAP_LOOP
000D70r 2               
000D70r 2               		; line 2
000D70r 2  A5 rr        		lda ppu_bg_addr+HI
000D72r 2  8D 06 20     		sta PPU_ADDR
000D75r 2  A6 rr        		ldx ppu_bg_addr+LO
000D77r 2  E8           		inx
000D78r 2  8E 06 20     		stx PPU_ADDR
000D7Br 2               
000D7Br 2  A2 00        		ldx #0
000D7Dr 2               @STORE_MAP_LOOP2:
000D7Dr 2  BD 1A 01     		lda bg_map_buff+$1a, x
000D80r 2  8D 07 20     		sta PPU_DATA
000D83r 2  E8           		inx
000D84r 2  E0 1A        		cpx #$1a
000D86r 2  D0 F5        		bne @STORE_MAP_LOOP2
000D88r 2               
000D88r 2               @PRINT:
000D88r 2  A9 00        		lda #0
000D8Ar 2  C5 rr        		cmp bg_buff_pointer
000D8Cr 2  F0 35        		beq @STORE_CHR
000D8Er 2  AA           		tax
000D8Fr 2  BD 49 01     		lda bg_buff, x
000D92r 2               @SET_MODE:
000D92r 2  29 01        		and #%00000001					; Get flag
000D94r 2  0A 0A        		shl #2							; Move flag to Bit2
000D96r 2  85 rr        		sta tmp1						; Start using tmp1
000D98r 2  A5 rr        		lda ppu_ctrl1_cpy
000D9Ar 2  29 FB        		and #%11111011					; Mask direction flag(Horizontal(+1)/Vertical(+32))
000D9Cr 2  05 rr        		ora tmp1						; End using tmp1
000D9Er 2  85 rr        		sta ppu_ctrl1_cpy
000DA0r 2  8D 00 20     		sta PPU_CTRL1					; Not use restorePPUSet()
000DA3r 2               @SET_ADDR:
000DA3r 2  E8           		inx								; Not do inx when go to @EXIT
000DA4r 2  BD 49 01     		lda bg_buff, x
000DA7r 2  8D 06 20     		sta PPU_ADDR
000DAAr 2  E8           		inx
000DABr 2  BD 49 01     		lda bg_buff, x
000DAEr 2  8D 06 20     		sta PPU_ADDR
000DB1r 2  E8           		inx
000DB2r 2               @STORE_DATA:
000DB2r 2  BD 49 01     		lda bg_buff, x
000DB5r 2  A8           		tay
000DB6r 2  C9 FE        		cmp #$fe
000DB8r 2  B0 D8        		bcs @SET_MODE					; no inx
000DBAr 2  98           		tya
000DBBr 2  8D 07 20     		sta PPU_DATA
000DBEr 2  E8           		inx
000DBFr 2  E4 rr        		cpx bg_buff_pointer
000DC1r 2  D0 EF        		bne @STORE_DATA
000DC3r 2               
000DC3r 2               		; @SET_MODE + @SET_ADDR = 51 cycle
000DC3r 2               		; @STORE_DATA (return @STORE_DATA) = 24 cycle
000DC3r 2               		; @STORE_DATA (return @SET_MODE) = 13 cycle
000DC3r 2               
000DC3r 2               		; str1 = "A  B"
000DC3r 2               		; 	=> 51 + space_len * 24 cycle
000DC3r 2               		; 	=> mode(1) + addr(2) + data(2 + space_len) = (5 + space_len) bytes
000DC3r 2               		; 	|  len  || 1  | 2  |  3  |  4  |
000DC3r 2               		; 	| cycle || 75 | 99 | 123 | 147 |
000DC3r 2               		;	| bytes || 6  | 7  |  8  |  9  |
000DC3r 2               		; str2 = 'A', str3 = 'B'
000DC3r 2               		; 	=> (51 + 13) * 2 = 64 * 2 = 128 cycle
000DC3r 2               		; 	=> (mode(1) + addr(2) + data(1)) * 2 = 8 bytes
000DC3r 2               		; space length:
000DC3r 2               		; 	1: 75 cycle,	6 bytes (str1)
000DC3r 2               		; 	2: 99 cycle,	7 bytes
000DC3r 2               		; 	3: 123 cycle,	8 bytes
000DC3r 2               		; 	4~: 128 cycle,	8 bytes (str2)
000DC3r 2               @STORE_CHR:
000DC3r 2  A9 00        		lda #0
000DC5r 2  8D 03 20     		sta OAM_ADDR
000DC8r 2  A9 07        		lda #>CHR_BUFF
000DCAr 2  8D 14 40     		sta OAM_DMA
000DCDr 2               
000DCDr 2               @EXIT:
000DCDr 2  A9 01        		lda #1
000DCFr 2  85 rr        		sta is_processing_main
000DD1r 2  4A           		shr #1							; A = 0
000DD2r 2  85 rr        		sta bg_buff_pointer
000DD4r 2  85 rr        		sta is_updated_map
000DD6r 2  E6 rr        		inc frm_cnt
000DD8r 2  68           		pla
000DD9r 2  40           		rti	; --------------------------
000DDAr 2               .endproc
000DDAr 2               
000DDAr 1               .include "init.asm"
000DDAr 2               .code									; ----- code -----
000DDAr 2               
000DDAr 2               .import DQBGM0
000DDAr 2               
000DDAr 2  rr rr        bgm0:		.addr	DQBGM0
000DDCr 2               
000DDCr 2               .macro init
000DDCr 2               		sei								; Ban IRQ
000DDCr 2               		cld								; Ban BCD
000DDCr 2               		ldx #$40
000DDCr 2               		stx JOYPAD2
000DDCr 2               		ldx #$ff
000DDCr 2               		txs
000DDCr 2               		inx								; X = 0
000DDCr 2               		stx PPU_CTRL1
000DDCr 2               		stx PPU_CTRL2
000DDCr 2               		stx SOUND_DP_1					; Ban IRQ of APU DMC (bit7)
000DDCr 2               		stx SOUND_CHANNEL
000DDCr 2               
000DDCr 2               		/*
000DDCr 2               		A & $2002 -> set Z(zero flag)
000DDCr 2               		$2002 bit7(vblank) -> N(negative), bit6(sprite 0 hit) -> V(overflow)
000DDCr 2               		Reset vblank & sprite 0 hit flag
000DDCr 2               		(The state of this flag after reset is undefined.)
000DDCr 2               		*/
000DDCr 2               		bit $2002
000DDCr 2               		jsr Subfunc::_waitVblank		; 1st time
000DDCr 2               
000DDCr 2               		txa								; A = 0
000DDCr 2               @CLR_MEM:
000DDCr 2               		sta $00, x
000DDCr 2               		sta $0100, x
000DDCr 2               		sta $0200, x
000DDCr 2               		sta $0300, x
000DDCr 2               		sta $0400, x
000DDCr 2               		sta $0500, x
000DDCr 2               		sta $0600, x
000DDCr 2               		inx
000DDCr 2               		bne @CLR_MEM
000DDCr 2               
000DDCr 2               		lda #$ff
000DDCr 2               @CLR_CHR_MEM:
000DDCr 2               		sta $0700, x
000DDCr 2               		inx
000DDCr 2               		bne @CLR_CHR_MEM
000DDCr 2               
000DDCr 2               		; Zero sprite
000DDCr 2               		lda #$10-2-1
000DDCr 2               		sta CHR_BUFF+0
000DDCr 2               		lda #$ff
000DDCr 2               		sta CHR_BUFF+1
000DDCr 2               		lda #%0000_0010
000DDCr 2               		sta CHR_BUFF+2
000DDCr 2               		lda #$0f
000DDCr 2               		sta CHR_BUFF+3
000DDCr 2               
000DDCr 2               		jsr Subfunc::_waitVblank		; 2nd time
000DDCr 2               
000DDCr 2               		; ------- PPU stabilizes -------
000DDCr 2               
000DDCr 2               		lda #%00010000					; SPR = $0000, BG = $1000
000DDCr 2               		sta ppu_ctrl1_cpy
000DDCr 2               		jsr Subfunc::_restorePPUSet
000DDCr 2               
000DDCr 2               		; Clear VRAM
000DDCr 2               		lda #$20
000DDCr 2               		sta PPU_ADDR
000DDCr 2               		lda #$00
000DDCr 2               		sta PPU_ADDR
000DDCr 2               
000DDCr 2               		ldy #8
000DDCr 2               		tax
000DDCr 2               @CLR_VRAM:
000DDCr 2               		sta PPU_DATA
000DDCr 2               		inx
000DDCr 2               		bne @CLR_VRAM
000DDCr 2               		dey
000DDCr 2               		bne @CLR_VRAM
000DDCr 2               
000DDCr 2               
000DDCr 2               		jsr Subfunc::_waitVblank
000DDCr 2               
000DDCr 2               
000DDCr 2               		tfrPlt
000DDCr 2               
000DDCr 2               		; Change bg color (black)
000DDCr 2               		lda #$3f
000DDCr 2               		sta PPU_ADDR
000DDCr 2               		lda #$00
000DDCr 2               		sta PPU_ADDR
000DDCr 2               		lda #$0f
000DDCr 2               		sta PPU_DATA
000DDCr 2               		; 画面OFF中は最後に指定したアドレスの色が背景になる（指定なし→3f01の色が使用される）
000DDCr 2               		lda #$3f
000DDCr 2               		sta PPU_ADDR
000DDCr 2               		lda #$00
000DDCr 2               		sta PPU_ADDR
000DDCr 2               
000DDCr 2               	lda #'G'
000DDCr 2               	sta DrawMap::fill_ground_block
000DDCr 2               
000DDCr 2               	lda #0
000DDCr 2               	sta is_scroll_locked
000DDCr 2               
000DDCr 2               		jsr Subfunc::_dispStatus
000DDCr 2               
000DDCr 2               	; sprite
000DDCr 2               	lda #$20
000DDCr 2               	sta spr_posX_arr+0
000DDCr 2               	sta spr_posX_tmp_arr+0
000DDCr 2               	lda #$c0
000DDCr 2               	sta spr_posY_tmp_arr+0
000DDCr 2               	ldx #PLAYER_SPR_ID					; spr id
000DDCr 2               	ldy #PLAYER_CHR_BUFF_INDEX			; buff index (0は0爆弾用のスプライト)
000DDCr 2               	jsr Sprite::_tfrToChrBuff
000DDCr 2               
000DDCr 2               	lda #1							; Y方向の加速度が正（下向き）の場合
000DDCr 2               	sta spr_velocity_y_arr+$0
000DDCr 2               	sta spr_decimal_part_velocity_y_arr+$0\
000DDCr 2               
000DDCr 2               	lda APU_CHANCTRL
000DDCr 2               	ora #%00000001
000DDCr 2               	sta APU_CHANCTRL
000DDCr 2               	lda #%10011111
000DDCr 2               	sta APU_PULSE1CTRL						; Duty50%(2)、ループ無し、音響固定、ボリューム最大(4)
000DDCr 2               	lda #%00000000
000DDCr 2               	sta APU_PULSE1RAMP						; 周波数変化なし（bit7）、他は設定せず
000DDCr 2               
000DDCr 2               	jsr _nsd_init
000DDCr 2               
000DDCr 2               	lda	bgm0
000DDCr 2               	ldx	bgm0 + 1
000DDCr 2               	jsr	_nsd_play_bgm
000DDCr 2               
000DDCr 2               		lda #0
000DDCr 2               		sta is_updated_map
000DDCr 2               
000DDCr 2               		lda ppu_ctrl1_cpy				; NMI ON
000DDCr 2               		ora #%10000000
000DDCr 2               		sta ppu_ctrl1_cpy
000DDCr 2               		jsr Subfunc::_restorePPUSet
000DDCr 2               
000DDCr 2               		jsr Subfunc::_sleepOneFrame		; draw disp status
000DDCr 2               
000DDCr 2               		ldy #0
000DDCr 2               		jsr DrawMap::_changeStage
000DDCr 2               
000DDCr 2               .endmacro
000DDCr 2               
000DDCr 1               .include "func.asm"				; いくつかのファイルのインクルードが必要な関数群
000DDCr 2               .scope Func
000DDCr 2               
000DDCr 2               ;*------------------------------------------------------------------------------
000DDCr 2               ; スクロール
000DDCr 2               ; @PARAMS		A: amount of scroll
000DDCr 2               ; @CLOBBERS		A, tmp1, tmp2
000DDCr 2               ; @RETURNS		None
000DDCr 2               ;*------------------------------------------------------------------------------
000DDCr 2               
000DDCr 2               .proc _scroll
000DDCr 2  A5 rr        		lda is_scroll_locked
000DDEr 2  D0 28        		bne @SKIP_UPDATE_LINE
000DE0r 2               
000DE0r 2  A5 rr        		lda scroll_x
000DE2r 2  29 F0        		and #BYT_GET_HI
000DE4r 2  85 rr        		sta tmp1
000DE6r 2               
000DE6r 2  A5 rr        		lda scroll_x
000DE8r 2  18 65 rr     		add scroll_amount
000DEBr 2  85 rr        		sta scroll_x
000DEDr 2  29 F0        		and #BYT_GET_HI						; Not clobber carry
000DEFr 2  85 rr        		sta tmp2
000DF1r 2               
000DF1r 2  90 0C        		bcc @SKIP_CHANGE_DISP
000DF3r 2  A5 rr        		lda main_disp
000DF5r 2  49 01        		eor #%0000_0001
000DF7r 2  85 rr        		sta main_disp
000DF9r 2               
000DF9r 2  A5 rr        		lda ppu_ctrl1_cpy
000DFBr 2  49 01        		eor #%0000_0001
000DFDr 2  85 rr        		sta ppu_ctrl1_cpy
000DFFr 2               
000DFFr 2               @SKIP_CHANGE_DISP:
000DFFr 2  A5 rr        		lda tmp1
000E01r 2  C5 rr        		cmp tmp2
000E03r 2  F0 03        		beq @SKIP_UPDATE_LINE
000E05r 2  20 rr rr     		jsr DrawMap::_updateOneLine
000E08r 2               @SKIP_UPDATE_LINE:
000E08r 2               
000E08r 2  60           		rts
000E09r 2               		; ------------------------------
000E09r 2               .endproc
000E09r 2               
000E09r 2               
000E09r 2               .endscope
000E09r 2               
000E09r 1               .include "main.asm"
000E09r 2               ;*------------------------------------------------------------------------------
000E09r 2               ; メインルーチン
000E09r 2               ;*------------------------------------------------------------------------------
000E09r 2               
000E09r 2               .code									; ----- code -----
000E09r 2               
000E09r 2               .proc _main
000E09r 2               		; -------- Vblank終了待ち --------
000E09r 2  A5 rr        		lda is_processing_main
000E0Br 2  F0 FC        		beq _main
000E0Dr 2               
000E0Dr 2               		; ----------- 0爆弾前 -----------
000E0Dr 2               
000E0Dr 2  A5 rr        		lda ppu_ctrl1_cpy				; ステータス表示の為$2000の画面を表示
000E0Fr 2  29 FC        		and #%1111_1100
000E11r 2  8D 00 20     		sta PPU_CTRL1					; 後でrestoreできるようにRAMにはコピーを取らない -> ??? 分かったら書き換えておいて
000E14r 2               
000E14r 2  A9 00        		lda #0							; ステータス表示の為リセット
000E16r 2  8D 05 20     		sta PPU_SCROLL
000E19r 2  8D 05 20     		sta PPU_SCROLL
000E1Cr 2               
000E1Cr 2               @WAIT_FINISH_VBLANK:
000E1Cr 2  2C 02 20     		bit PPU_STATUS
000E1Fr 2  70 FB        		bvs @WAIT_FINISH_VBLANK
000E21r 2               
000E21r 2  20 rr rr     		jsr _nsd_main_bgm
000E24r 2               
000E24r 2  20 rr rr     		jsr Joypad::_getJoyData
000E27r 2               
000E27r 2               @WAIT_ZERO_BOMB:
000E27r 2  2C 02 20     		bit PPU_STATUS
000E2Ar 2  50 FB        		bvc @WAIT_ZERO_BOMB
000E2Cr 2               
000E2Cr 2  A0 14        		ldy #20							; 10ぐらいまで乱れる，余裕もって20に
000E2Er 2               :
000E2Er 2  88           		dey
000E2Fr 2  D0 FD        		bne :-
000E31r 2               
000E31r 2               		; ----------- 0爆弾後 -----------
000E31r 2               
000E31r 2  20 rr rr     		jsr Subfunc::_setScroll
000E34r 2               
000E34r 2               	; inc timer
000E34r 2  EE rr rr     	inc spr_anime_timer+$0
000E37r 2               
000E37r 2               	; chr move
000E37r 2  A2 01        	ldx #PLAYER_SPR_ID					; spr id
000E39r 2  20 rr rr     	jsr Sprite::_moveSprite
000E3Cr 2  A2 01        	ldx #PLAYER_SPR_ID					; spr id
000E3Er 2  A0 00        	ldy #PLAYER_CHR_BUFF_INDEX			; buff index (0は0爆弾用のスプライト)
000E40r 2  20 rr rr     	jsr Sprite::_tfrToChrBuff
000E43r 2               
000E43r 2  20 rr rr     	jsr Func::_scroll
000E46r 2               
000E46r 2               		; Aボタン
000E46r 2  A5 rr        		lda Joypad::joy1_pushstart
000E48r 2  29 80        		and #Joypad::BTN_A
000E4Ar 2  F0 00        		beq @NO_PUSHED_BTN_A
000E4Cr 2               
000E4Cr 2               		; jsr DrawMap::_updateOneLine
000E4Cr 2               @NO_PUSHED_BTN_A:
000E4Cr 2               		; Bボタン
000E4Cr 2  A5 rr        		lda Joypad::joy1
000E4Er 2  29 40        		and #Joypad::BTN_B
000E50r 2  F0 00        		beq @NO_PUSHED_BTN_B
000E52r 2               
000E52r 2               		; ldy #1
000E52r 2               		; jsr DrawMap::_changeStage
000E52r 2               @NO_PUSHED_BTN_B:
000E52r 2               		; ↑ボタン
000E52r 2  A5 rr        		lda Joypad::joy1_pushstart
000E54r 2  29 08        		and #Joypad::BTN_U
000E56r 2  F0 00        		beq @NO_PUSHED_BTN_U
000E58r 2               
000E58r 2               @NO_PUSHED_BTN_U:
000E58r 2               		; ↓ボタン
000E58r 2  A5 rr        		lda Joypad::joy1_pushstart
000E5Ar 2  29 04        		and #Joypad::BTN_D
000E5Cr 2  F0 00        		beq @NO_PUSHED_BTN_D
000E5Er 2               
000E5Er 2               @NO_PUSHED_BTN_D:
000E5Er 2               
000E5Er 2  20 rr rr     		jsr Player::_physicsX
000E61r 2  20 rr rr     		jsr Player::_jumpCheck
000E64r 2  20 rr rr     		jsr Player::_moveYProcess
000E67r 2  20 rr rr     		jsr Player::_checkCollision
000E6Ar 2  20 rr rr     		jsr Player::_animate
000E6Dr 2               
000E6Dr 2               
000E6Dr 2               		; ----- End main -----
000E6Dr 2  A9 00        		lda #0
000E6Fr 2  85 rr        		sta is_processing_main
000E71r 2  4C rr rr     		jmp _main
000E74r 2               		; ------------------------------
000E74r 2               .endproc
000E74r 2               
000E74r 1               
000E74r 1               
000E74r 1               .segment "DMA_MEM"
000000r 1  xx xx xx xx  		.tag SPR_TBL
000004r 1  xx xx xx xx  
000008r 1  xx xx xx xx  
000100r 1               
000100r 1               
000100r 1               .code									; ----- code -----
000E74r 1               .segment "STARTUP"
000000r 1               
000000r 1               .proc _reset
000000r 1  78 D8 A2 40  		init
000004r 1  8E 17 40 A2  
000008r 1  FF 9A E8 8E  
00012Br 1               
00012Br 1  A9 01        		lda #1
00012Dr 1  85 rr        		sta is_processing_main
00012Fr 1               
00012Fr 1  4C rr rr     		jmp _main
000132r 1               		; ------------------------------
000132r 1               .endproc
000132r 1               
000132r 1               
000132r 1               .proc _irq
000132r 1  40           		rti
000133r 1               .endproc
000133r 1               
000133r 1               
000133r 1               .segment "CHARS"
000000r 1  03 0F 1F 1F  		.incbin "spr_bg.chr"
000004r 1  1C 24 26 66  
000008r 1  00 00 00 00  
002000r 1               
002000r 1               
002000r 1               .segment "VECINFO"
000000r 1  rr rr        		.addr _nmi
000002r 1  rr rr        		.addr _reset
000004r 1  rr rr        		.addr _irq
000004r 1               
